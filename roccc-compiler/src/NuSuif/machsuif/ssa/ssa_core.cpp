/* file "ssa/ssa_core.cpp" */

/*
    Copyright (c) 2000-2001 The President and Fellows of Harvard College

    All rights reserved.

    This software is provided under the terms described in
    the "machine/copyright.h" include file.
*/

#include <machine/copyright.h>

#ifdef USE_PRAGMA_INTERFACE
#pragma implementation "ssa/ssa_core.h"
#endif

#include <machine/machine.h>
#include <cfg/cfg.h>
#include <cfa/cfa.h>
#include <bvd/bvd.h>

#include <ssa/ssa_ir.h>
#include <ssa/ssa_ir_factory.h>
#include <ssa/opi.h>
#include <ssa/init.h>
#include <ssa/ssa_core.h>

#ifdef USE_DMALLOC
#include <dmalloc.h>
#define new D_NEW
#endif

using namespace ssa;

typedef List<Operation>::iterator UseHandle;

// Handles on these distinguished lists are used to recognize the null
// instance of class Operation.

list<Instr*>   Operation::one_null_instr;
list<PhiNode*> Operation::one_null_phi;


static void
map_formal_defs(OptUnit *unit, OpndFilter &filter)
{
    for (int i = get_formal_param_count(unit) - 1; i >= 0; --i)
	filter(opnd_var(get_formal_param(unit, i)), OpndFilter::OUT);
}

/*
 * Return true iff `opnd' is a candidate for replacement by an SSA
 * "variable".  It must be a virtual register or a local variable whose
 * address is not taken.
 */
static bool
is_ssa_candidate(Opnd opnd)
{
    if (is_var(opnd))
	return is_auto(get_var(opnd)) && !is_addr_taken(get_var(opnd));
    return is_virtual_reg(opnd);
}

class LivenessInfo
{
  public:
    unsigned size;
    unsigned *names;
};

class DominanceChild
{
  public:
    DominanceChild(int node_number) { block_number = node_number; }
    ~DominanceChild() { if (next) delete next; }

    unsigned block_number;
    DominanceChild *next;
};

/*
 * A `phi source' is the parameter of a phi-node.  BHS calls this a `parm'.
 *
 * The `phi_src_map' entry for a block (`parm_map' in BHS) pairs each
 * successor of block with the corresponding index into the phi-node source
 * vectors of that successor.  Suppose S is a successor of block B, and
 * that B is designated the 2nd predecessor of S.  Then the phi_src_map
 * entry for B contains the pair <2, S>.
 */
struct PhiSrcMapEntry
{
    unsigned index;
    CfgNode *succ_block;
    PhiSrcMapEntry *next;
};

/*
 * An AssignmentListEntry links a definition to the CFG block that
 * contains it.  Assignment lists are anchored in the `assignments' array,
 * which is indexed by original location id number.
 */
struct AssignmentListEntry
{
    AssignmentListEntry(CfgNode *block_ptr, AssignmentListEntry *next_ptr)
      { block = block_ptr; next = next_ptr;}
    ~AssignmentListEntry() { delete next; }
    CfgNode *block;
    AssignmentListEntry *next;
};

/*
 * A "name", in Rice's terminology, is the representative of a location.
 * In our implementation, it has type Opnd.  An "old name" is an operand of
 * the untransformed program; a "new name" is one generated by conversion
 * to SSA form.
 *
 * The "name stack" for a given location is used in generating its new
 * names for SSA form.  The `next' field connects current stack members.
 * The `next_pushed' field connects entries for distinct locations that
 * need to popped at the same time.  It's an index into an array of name
 * stacks.
 */

struct NameStackEntry
{
    Opnd new_name;
    NameStackEntry *next;
    int next_pushed;
};

/*
 * CopyData keeps book on how one location is used in inserted copies during
 * rewrite_phi_nodes.  An instance of CopyData is always an entry in the
 * copy_stats table, which is indexed by the id of an SSA name.  That name is
 * thus an implicit part of the copy described by a table entry.
 *
 * src			Original source of the copy for which this entry is dst.
 * src_name_to_use	Source name to substitute for this in subsequent copies.
 * used_by_count	Number of times this is used as the src in another copy.
 * is_live_out		True iff this entry is live leaving current block.
 * temp_name		Temp name for this item, if there is one, else null.
 * new_name		Name stack used to substitute temp names for phi names.
 *
 * src_name_to_use is used for the `swap problem'.  temp_name and new_name
 * are used for the `lost-copy problem'.
 */

struct CopyData
{
    CopyData() { used_by_count = 0; is_live_out = false; new_name = NULL; }
    Opnd src;
    unsigned used_by_count;
    bool is_live_out;
    Opnd src_name_to_use;
    Opnd temp_name;
    NameStackEntry *new_name;
};


// --------------------  Filters for scanning instructions  --------------------

class CountOpnds : public OpndFilter
{
  public:
    CountOpnds(SsaCore *ssa_core) : ssa_core(ssa_core) { }
    Opnd operator()(Opnd, InOrOut);

  protected:
    SsaCore *ssa_core;
};

Opnd
CountOpnds::operator()(Opnd opnd, InOrOut usage)
{
    if (ssa_core->old_opnd_catalog->enroll(opnd))
	++ssa_core->_loc_count;
    return opnd;
}

class AddToLiveIn : public OpndFilter
{
  public:
    AddToLiveIn(SsaCore *ssa_core, NatSet *cur_killed, NatSet *cur_live_in)
	: ssa_core(ssa_core), cur_killed(cur_killed), cur_live_in(cur_live_in)
    { }
    Opnd operator()(Opnd, InOrOut);

  private:
    SsaCore *ssa_core;
    NatSet *cur_killed;
    NatSet *cur_live_in;
};

Opnd
AddToLiveIn::operator()(Opnd opnd, InOrOut in_or_out)
{
    if (in_or_out == IN)
    {
	int old_opnd_id = (ssa_core->*(ssa_core->enroll_opnd))(opnd);
	if (old_opnd_id >= 0 && !cur_killed->contains(old_opnd_id))
	    cur_live_in->insert(old_opnd_id);
    }
    return opnd;
}

class AddToCurKilled : public OpndFilter
{
  public:
    AddToCurKilled(SsaCore *ssa_core, NatSet *cur_killed)
	: ssa_core(ssa_core), cur_killed(cur_killed)
    { }
    Opnd operator()(Opnd, InOrOut);

  private:
    SsaCore *ssa_core;
    NatSet *cur_killed;
};

Opnd
AddToCurKilled::operator()(Opnd opnd, InOrOut in_or_out)
{
    if (in_or_out == OUT)
    {
	int old_opnd_id = (ssa_core->*(ssa_core->enroll_opnd))(opnd);
	if (old_opnd_id >= 0)
	    cur_killed->insert(old_opnd_id);
    }
    return opnd;
}

class AddUsesToGlobal : public OpndFilter
{
  public:
    AddUsesToGlobal(SsaCore *ssa_core, NatSet *killed_in_block)
	: ssa_core(ssa_core), killed_in_block(killed_in_block)
    { }
    Opnd operator()(Opnd, InOrOut);

  private:
    SsaCore *ssa_core;
    NatSet *killed_in_block;
};

Opnd
AddUsesToGlobal::operator()(Opnd opnd, InOrOut in_or_out)
{
    if (in_or_out == IN)
    {
	int old_opnd_id = ssa_core->enroll_old_opnd(opnd);
	if (old_opnd_id >= 0 && !killed_in_block->contains(old_opnd_id))
	    ssa_core->global_locs->insert(old_opnd_id);
    }
    return opnd;
}

class AddDefsToKilled : public OpndFilter
{
  public:
    AddDefsToKilled(SsaCore *ssa_core, NatSet *killed_in_block)
	: ssa_core(ssa_core), killed_in_block(killed_in_block)
    { }
    Opnd operator()(Opnd, InOrOut);

  private:
    SsaCore *ssa_core;
    NatSet *killed_in_block;
};

Opnd
AddDefsToKilled::operator()(Opnd opnd, InOrOut in_or_out)
{
    if (in_or_out == OUT)
    {
	int old_opnd_id = ssa_core->enroll_old_opnd(opnd);
	if (old_opnd_id >= 0)
	    killed_in_block->insert(old_opnd_id);
    }
    return opnd;
}

class FormAssignmentLists : public OpndFilter
{
  public:
    FormAssignmentLists(SsaCore *ssa_core, CfgNode *block)
	: ssa_core(ssa_core), block(block)
    { }
    Opnd operator()(Opnd, InOrOut);

  private:
    SsaCore *ssa_core;
    CfgNode *block;
};

Opnd
FormAssignmentLists::operator()(Opnd opnd, InOrOut in_or_out)
{
    if (in_or_out == OUT)
    {
	int old_opnd_id = ssa_core->enroll_old_opnd(opnd);
	if (old_opnd_id >= 0)
	{
	    ssa_core->def_count++;
	    if (ssa_core->get_build_minimal_form() ||
		ssa_core->global_locs->contains(old_opnd_id))
	    {
		AssignmentListEntry *first = ssa_core->assignments[old_opnd_id];

		if (!first || first->block != block)
		{
		    AssignmentListEntry *new_entry =
			new AssignmentListEntry(block, first);
		    ssa_core->assignments[old_opnd_id] = new_entry;
		}
	    }
	}
    }
    return opnd;
}

class ReplaceUsedLocs : public OpndFilter
{
  public:
    ReplaceUsedLocs(SsaCore *ssa_core, NameStackEntry **name_stacks,
		    int opcode, CfgNode *block)
	: ssa_core(ssa_core), name_stacks(name_stacks),
	  opcode(opcode), block(block)
    { }
    Opnd operator()(Opnd, InOrOut);

  protected:
    SsaCore *ssa_core;
    NameStackEntry **name_stacks;
    int opcode;
    CfgNode *block;
};

Opnd
ReplaceUsedLocs::operator()(Opnd opnd, InOrOut in_or_out)
{
    if (in_or_out == OUT)
	return opnd;

    int old_opnd_id = ssa_core->lookup_old_opnd(opnd);
    if (old_opnd_id < 0)
	return opnd;

    if (!name_stacks[old_opnd_id])
    {
	// BHS tries to eliminate any reference to an uninitialized location,
	// substituting an unrelated value if necessary.  We leave the code as
	// is.
	if (ssa_core->get_report_undefined_locs())
	    fprintf(stderr, "Found an uninitialized location: "
		    "opcode = %d, location #%d.\n",
		    opcode, old_opnd_id);
    }
    else
    {
	opnd = name_stacks[old_opnd_id]->new_name;
    }
    return opnd;
}

class RenameDefinedLocs : public OpndFilter
{
  public:
    RenameDefinedLocs(SsaCore *ssa_core, InstrHandle handle,
		      NameStackEntry **name_stacks, int *pushed_list)
	: ssa_core(ssa_core), handle(handle),
	  name_stacks(name_stacks), pushed_list(pushed_list)
    { }
    Opnd operator()(Opnd, InOrOut);

  private:
    SsaCore *ssa_core;
    InstrHandle handle;
    NameStackEntry **name_stacks;
    int *pushed_list;
};

Opnd
RenameDefinedLocs::operator()(Opnd opnd, InOrOut in_or_out)
{
    if (in_or_out == OUT)
    {
	int old_opnd_id = ssa_core->lookup_old_opnd(opnd);
	if (old_opnd_id >= 0)
	{
	    Opnd new_opnd = opnd_reg(get_type(opnd));
	    int new_opnd_id = ssa_core->enroll_new_opnd(new_opnd);
	    claim(new_opnd_id >= 0);

	    ssa_core->push_name(&name_stacks[old_opnd_id], ssa_core->pushed,
				pushed_list, old_opnd_id, new_opnd);
	    ssa_core->def_table[new_opnd_id] = Operation(handle);
	    ssa_core->set_old_id(new_opnd_id, old_opnd_id);

	    opnd = new_opnd;
	}
    }
    return opnd;
}

/*
 * Update the def-use chain for an SSA name found as an input operand of a
 * newly planted instruction or phi-node.  To avoid repeated entries, don't
 * actually extend a def-use chain until the commit method is called.
 * Instead, collect the used IDs during the scan of the operation.
 */
class RecordUses : public OpndFilter
{
  public:
    RecordUses(SsaCore *ssa_core) : ssa_core(ssa_core) { }
    Opnd operator()(Opnd, InOrOut);
    void commit(Operation) const;

  protected:
    SsaCore *ssa_core;
    NatSetSparse use_set;
};

Opnd
RecordUses::operator()(Opnd opnd, InOrOut in_or_out)
{
    if (in_or_out == IN)
    {
	unsigned value_id = ssa_core->lookup_new_opnd(opnd);

	if (value_id < ssa_core->def_count)
	    use_set.insert(value_id);
    }
    return opnd;
}

void
RecordUses::commit(Operation operation) const
{
    for (NatSetIter it = use_set.iter(); it.is_valid(); it.next())
	ssa_core->def_use_chains[it.current()].push_back(operation);
}

class RecordDefs : public OpndFilter
{
  public:
    RecordDefs(SsaCore *ssa_core, InstrHandle handle)
	: ssa_core(ssa_core), handle(handle) { }
    Opnd operator()(Opnd, InOrOut);

  protected:
    SsaCore *ssa_core;
    InstrHandle handle;
};

Opnd
RecordDefs::operator()(Opnd opnd, InOrOut in_or_out)
{
    if (in_or_out == OUT)
    {
	unsigned value_id = ssa_core->lookup_new_opnd(opnd);
	if (value_id < ssa_core->def_count)
	    ssa_core->def_table[value_id] = Operation(handle);
    }
    return opnd;
}

class ChangeNames : public OpndFilter
{
  public:
    ChangeNames(SsaCore *ssa_core, unsigned *loc_ids)
	: ssa_core(ssa_core), loc_ids(loc_ids)
    { }
    Opnd operator()(Opnd, InOrOut);

  private:
    SsaCore *ssa_core;
    unsigned *loc_ids;
};

Opnd
ChangeNames::operator()(Opnd opnd, InOrOut)
{
    int new_opnd_id = ssa_core->lookup_new_opnd(opnd);
    if (new_opnd_id >= 0)
	return ssa_core->get_new_name(loc_ids[new_opnd_id]);
    return opnd;
}

class RewriteTheUse : public OpndFilter
{
  public:
    RewriteTheUse(SsaCore *ssa_core, Opnd opnd_to_replace,
		  unsigned replacement_id)
	: ssa_core(ssa_core), opnd_to_replace(opnd_to_replace),
	  replacement_id(replacement_id)
    { }
    Opnd operator()(Opnd, InOrOut);

  private:
    SsaCore *ssa_core;
    Opnd opnd_to_replace;
    unsigned replacement_id;
};

Opnd
RewriteTheUse::operator()(Opnd opnd, InOrOut in_or_out)
{
    if ((in_or_out == IN) && (opnd == opnd_to_replace))
	opnd = ssa_core->get_new_name(replacement_id);
    return opnd;
}

class ReplaceSourceNames : public OpndFilter
{
  public:
    ReplaceSourceNames(SsaCore *ssa_core, CopyData *copy_stats)
	: ssa_core(ssa_core), copy_stats(copy_stats)
    { }
    Opnd operator()(Opnd, InOrOut);

  private:
    SsaCore *ssa_core;
    CopyData *copy_stats;
};

Opnd
ReplaceSourceNames::operator()(Opnd opnd, InOrOut in_or_out)
{
    if (in_or_out == IN)
    {
	int new_opnd_id = ssa_core->lookup_new_opnd(opnd);
	if ((new_opnd_id >= 0) && copy_stats[new_opnd_id].new_name)
	    opnd = copy_stats[new_opnd_id].new_name->new_name;
    }
    return opnd;
}

class RestoreRegisters : public OpndFilter
{
  public:
    RestoreRegisters(SsaCore *ssa_core) : ssa_core(ssa_core) { }
    Opnd operator()(Opnd, InOrOut);

  private:
    SsaCore *ssa_core;
};

Opnd
RestoreRegisters::operator()(Opnd opnd, InOrOut)
{
    int value_id = ssa_core->lookup_new_opnd(opnd);
    if (value_id >= 0)
    {
	if ((unsigned)value_id < ssa_core->def_count)
	{
	    int loc_id = ssa_core->get_old_id(value_id);
	    opnd = ssa_core->get_old_name(loc_id);
	}
	else
	{
	    opnd = opnd_reg(get_type(opnd));
	    warn("Creating $vr%d from thin air for value %d",
		  get_reg(opnd), value_id);
	}
    }
    return opnd;
}


// ----------------------------	 class SsaCore  --------------------------------

SsaCore::SsaCore(SsaCfg *ssa, bool is_ssa_cfg, bool is_deflated)
    : ssa(ssa), is_ssa_cfg(is_ssa_cfg), is_deflated(is_deflated)
{
    old_opnd_catalog = NULL;
    new_opnd_catalog = NULL;

    phi_src_map = NULL;
    edge_maps = NULL;

    live_in = NULL;
    live_out = NULL;

    dominator_analysis = NULL;
    dominator_children = NULL;

    private_live_in = NULL;
    private_live_out = NULL;

    assignments = NULL;

    global_locs = NULL;
    phi_node_uses = NULL;
    pushed = NULL;
    phi_srcs_indices = NULL;
    dst_list = NULL;
    worklist = NULL;
}

SsaCore::~SsaCore()
{
    delete old_opnd_catalog;
    delete new_opnd_catalog;

    delete phi_src_map;
    delete edge_maps;

    delete live_in;
    delete live_out;

    delete dominator_analysis;
    delete dominator_children;

    delete assignments;

    delete global_locs;
}

void
SsaCore::build(unsigned flags)
{
    claim(!is_ssa_cfg, "build: already in SSA form");
    assignments = NULL;

    old_opnd_catalog = new RegSymCatalog(false, is_ssa_candidate);
    new_opnd_catalog = new RegSymCatalog(false, is_ssa_candidate);

    // Declare the size of the old and new operand tables after we figure
    // out how many operands there are going to be.

    def_count = 0;
    live_in = NULL;
    live_out = NULL;
    replaced_phi_nodes = false;
    phi_src_map = NULL;

    enroll_opnd = &SsaCore::enroll_old_opnd;

    set_build_minimal_form    (!!(flags & BUILD_MINIMAL_FORM));
    set_build_semi_pruned_form(!!(flags & BUILD_SEMI_PRUNED_FORM));
    set_build_pruned_form     (!!(flags & BUILD_PRUNED_FORM));
    set_build_def_use_chains  (!!(flags & BUILD_DEF_USE_CHAINS));
    set_fold_copies           (!!(flags & FOLD_COPIES));
    set_omit_useless_phi_nodes(!!(flags & OMIT_USELESS_PHI_NODES));
    set_keep_live_in_info     (false);             // for now, we don't save ..
    set_keep_live_out_info    (false);             // .. liveness info from SSA
    set_report_undefined_locs (debuglvl > 0);

    unsigned flavor = flags & (BUILD_MINIMAL_FORM |
			       BUILD_SEMI_PRUNED_FORM |
			       BUILD_PRUNED_FORM);

    claim(   flavor == BUILD_MINIMAL_FORM
	  || flavor == BUILD_SEMI_PRUNED_FORM
	  || flavor == BUILD_PRUNED_FORM,
	"Ambiguous SSA kind.  Use exactly one of:\n"
	"\tBUILD_MINIMAL_FORM, BUILD_SEMI_PRUNED_FORM or BUILD_PRUNED_FORM.\n");

    // Iterate through every block, counting each one, and count every new
    // operand in each block.

    _loc_count = 0;
    block_count = 0;

    CountOpnds count_opnds(this);		// bumps _loc_count
    map_formal_defs(get_unit(), count_opnds);		// count formals first

    for (int i = 0; i < nodes_size(get_cfg()); i++)
    {
	CfgNode *block = get_node(get_cfg(), i);
	block_count++;

	InstrHandle h = instrs_start(block);
	for (int j = instrs_size(block); j > 0; --j, ++h)
	    map_opnds(*h, count_opnds);
    }

    resize_old_names(_loc_count);

    // Compute dominance frontiers and build dominator tree

    dominator_analysis = new DominanceInfo(get_cfg());
    dominator_analysis->find_dominators();
    dominator_analysis->find_dom_frontier();

    build_dominator_tree();

    // Now that block count and location count are known, initialize tables
    // having those sizes.

    if (get_build_pruned_form() || get_keep_live_in_info())
    {
    
      private_live_in = new NatSet*[block_count+1];
    
	for (unsigned i = 0; i <= block_count; ++i)
	    private_live_in[i] = NULL;
    }
    else
    {
	private_live_in = NULL;
    }
    if  (get_keep_live_out_info())
    {
        private_live_out = new NatSet*[block_count+1];
	for (unsigned i = 0; i <= block_count; ++i)
	    private_live_out[i] = NULL;
    }
    else
    {
	private_live_out = NULL;
    }
    assignments = new AssignmentListEntry*[_loc_count];
    for (unsigned i = 0; i < _loc_count; ++i)
         assignments[i] = NULL;
    if (!get_build_minimal_form())
        global_locs = new NatSetSparse();

    edge_maps = new CfgNode**[block_count+1];

    CfgNodeListRpo rpo(get_cfg());
    for (CfgNodeHandle h = rpo.start(); h != rpo.end(); ++h)
    {
	CfgNode *block = *h;
	if (block != get_entry_node(get_cfg()))
	{
	    unsigned pred_count = preds_size(block);
	    edge_maps[get_number(block)] = new CfgNode*[pred_count];
	}
    }

    phi_src_map = new PhiSrcMapEntry*[block_count + 1];
    for (unsigned l = 0; l < block_count + 1; ++l)
	phi_src_map[l] = NULL;

    if (get_build_pruned_form() || get_keep_live_in_info() ||
	get_keep_live_out_info())
	analyze_liveness();

    // <<Find assignments>>
    if (!get_build_minimal_form())
    {
	// <<Find global locations>>, i.e. those whose live ranges cross
	// basic-block boundaries.

	NatSet *killed_in_block = new NatSetSparse;

	CfgNodeListRpo rpo(get_cfg());
	for (CfgNodeHandle h = rpo.start(); h != rpo.end(); ++h)
	{
	    CfgNode *block = *h;
	    killed_in_block->remove_all();

	    InstrHandle list_iterator = instrs_start(block);
	    for (int j = 0; j < instrs_size(block);
		 j++, list_iterator++)
	    {
		Instr *instr = *list_iterator;

		AddUsesToGlobal add_uses_to_global(this, killed_in_block);
		map_opnds(instr, add_uses_to_global);
		AddDefsToKilled add_defs_to_killed(this, killed_in_block);
		map_dst_opnds(instr, add_defs_to_killed);
	    }
	}
    }

    // <<Accumulate assignment blocks for global locations>>

    for (CfgNodeHandle bh = rpo.start(); bh != rpo.end(); ++bh)
    {
	CfgNode *block = *bh;
	FormAssignmentLists form_assignment_lists(this, block);

	InstrHandle ih = instrs_start(block);
	for (int j = instrs_size(block); j > 0; --j, ++ih)
	{
	    Instr *instr = *ih;

	    // <<Examine all the definitions in [[instr]]>>
	    if (has_note(instr, k_proc_entry))
		map_formal_defs(get_unit(), form_assignment_lists);
	    else
		map_dst_opnds(instr, form_assignment_lists);
	}
    }

    // <<Place phi-nodes>>

    int loc_id;
    NatSet *in_list = new NatSetSparse;
    NatSet *has_node = new NatSetSparse;

    if (get_build_minimal_form())
    {
	int max_slot = old_opnd_catalog->num_slots();
	for (loc_id = 0; loc_id < max_slot; ++loc_id)
	{
	    // <<Place the phiNodes for [[loc_id]]>>
	    AssignmentListEntry *assignment_list =		// worklist
		assignments[loc_id];

	    has_node->remove_all();
	    has_node->insert(get_number(get_exit_node(get_cfg())));

	    // <<Initialize the set [[in_list]]>>

	    in_list->remove_all();
	    for (AssignmentListEntry *assignment = assignment_list;
		 assignment != NULL;
		 assignment = assignment->next)
		in_list->insert(get_number(assignment->block));

	    while (assignment_list)
	    {
		CfgNode *block = assignment_list->block;
		assignment_list = assignment_list->next;

		// <<Place phi-nodes for [[loc_id]] in [[block]]'s iterated
		//   dominance frontier and update [[assignment_list]]>>

		const NatSet *frontier =
		    dominator_analysis->dom_frontier(get_number(block));

		for (NatSetIter f = frontier->iter(); f.is_valid(); f.next())
		{
		    unsigned frontier_index = f.current();
		    CfgNode *frontier_block =
			get_node(get_cfg(), frontier_index);

		    if (!has_node->contains(frontier_index) &&
			(!get_build_pruned_form() ||
			 (private_live_in[frontier_index]->contains(loc_id))))
		    {
			has_node->insert(frontier_index);

			// <<Place a phi-node for [[loc_id]] in
			//   [[frontier_block]]>>

			unsigned pred_count = preds_size(frontier_block);

			PhiNode *phi = new_phi_node(pred_count);

			// Put old name in dst field till we have the SSA name.
			set_dst(phi, get_old_name(loc_id));
			def_count++;		// for the phi-node just created
			append_phi_node(frontier_block, phi);

			// <<Put [[frontier_block]] into [[assignment_list]]>>

			if (!in_list->contains(frontier_index))
			{
			    AssignmentListEntry *new_node =
				new AssignmentListEntry(frontier_block,
							assignment_list);
			    assignment_list = new_node;
			    in_list->insert(frontier_index);
			}
		    }
		}
	    }
	}
    }
    else			// (building semi-pruned or pruned)
    {
	NatSetIter ss_iterator = global_locs->iter();
	for (/* */; ss_iterator.is_valid(); ss_iterator.next())
	{
	    loc_id = ss_iterator.current();

	    // <<Place the phiNodes for [[loc_id]]>>

	    AssignmentListEntry *assignment_list =		// worklist
		assignments[loc_id];

	    has_node->remove_all();
	    has_node->insert(get_number(get_exit_node(get_cfg())));

	    // <<Initialize the set [[in_list]]>>

	    in_list->remove_all();
	    for (AssignmentListEntry *an = assignment_list; an; an = an->next)
		in_list->insert(get_number(an->block));

	    while (assignment_list)
	    {
		CfgNode *block = assignment_list->block;

		assignment_list = assignment_list->next;
		const NatSet *frontier =
		    dominator_analysis->dom_frontier(get_number(block));

		NatSetIter frontier_iter = frontier->iter();
		for (/* */; frontier_iter.is_valid(); frontier_iter.next())
		{
		    unsigned frontier_index = frontier_iter.current();
		    CfgNode *frontier_block =
			get_node(get_cfg(), frontier_index);

		    if (!has_node->contains(frontier_index) &&
			(!get_build_pruned_form() ||
			 (private_live_in[frontier_index]->contains(loc_id))))
		    {
			has_node->insert(frontier_index);

			unsigned pred_count = preds_size(frontier_block);

			PhiNode *phi = new_phi_node(pred_count);
			Opnd old_opnd = get_old_name(loc_id);

			// Put old name in dst field till we have the SSA name.
			set_dst(phi, old_opnd);
			def_count++;		// count new phi-node as a def
			append_phi_node(frontier_block, phi);

			if (!in_list->contains(frontier_index))
			{
			    AssignmentListEntry *new_node =
				new AssignmentListEntry(frontier_block,
							assignment_list);
			    assignment_list = new_node;
			    in_list->insert(frontier_index);
			}
		    }
		}
	    }
	}
    }

    // We are done with data-flow information.  On to renaming locations.
    // <<Rename resources>>

    NameStackEntry **name_stacks = new NameStackEntry*[_loc_count];
    for (unsigned l = 0; l < _loc_count; ++l)
	name_stacks[l] = NULL;

    // <<Initialize variables during renaming>>
    pushed = new NatSetSparse;

    phi_srcs_indices = new unsigned[block_count + 1];
    for (unsigned l = 0; l < block_count + 1; ++l)
	phi_srcs_indices[l] = 0;

    // <<Initialize variables whose size depends on [[def_count]]>>

    def_table.resize(def_count, Operation());
    resize_old_ids(def_count);
    resize_new_names(def_count);

    if (get_build_def_use_chains())
	def_use_chains.resize(def_count, List<Operation>());

    rename_locs(get_entry_node(get_cfg()), name_stacks);

    if_debug(5)
    {
	fputs("Original operands:\n", stderr);
	for (unsigned i = 0; i < _loc_count; ++i)
	{
	    fprintf(stderr, "%3d: ", i);
	    fprint (stderr, get_old_name(i));
	    putc('\n', stderr);
	}
	fputs("SSA operands:\n", stderr);
	for (int i = 0; i < new_opnd_catalog->size(); ++i)
	{
	    fprintf(stderr, "%3d: ", i);
	    fprint (stderr, get_new_name(i));
	    fprintf(stderr, "\twas: ");
	    fprint (stderr, get_old_name(get_old_id(i)));
	    putc('\n', stderr);
	}
    }

    delete [] phi_srcs_indices;
    delete    pushed;
    delete [] name_stacks;

    // <<Fold useless phi-nodes, if necessary>>

    if (get_omit_useless_phi_nodes())
    {
        if (get_build_def_use_chains() &&
	    !(get_keep_live_in_info() || get_keep_live_out_info()))
	{
	    // <<Remove useless phi-nodes using the worklist method>>

	    NatSet *worklist = new NatSetSparse;
	    PhiNode **phi_node_map = new PhiNode*[def_count];

	    unsigned number_removed = 0;
	    unsigned *loc_ids;

	    // <<Initialize [[loc_ids]]>>

	    loc_ids = new unsigned[def_count];
	    for (unsigned i = 0; i < def_count; ++i)
		loc_ids[i] = i;

	    // <<Initialize [[phi_node_map]] and the worklist for removing
	    //   useless phi-nodes>>

	    CfgNodeListRpo rpo(get_cfg());
	    for (CfgNodeHandle h = rpo.start(); h != rpo.end(); ++h)
	    {
		CfgNode *block = *h;

		const List<PhiNode*> &block_phi_nodes = get_phi_nodes(block);
		for (PhiHandle h = block_phi_nodes.begin();
		     h != block_phi_nodes.end(); ++h)
		{
		    PhiNode *phi_node = *h;
		    Opnd phi_node_name = get_dst(phi_node);
		    unsigned phi_node_number =
			lookup_new_opnd(phi_node_name);
		    claim(phi_node_number < def_count);
		    phi_node_map[phi_node_number] = phi_node;
		    worklist->insert(phi_node_number);
		}
	    }

	    while (worklist->size() > 0)
	    {
		// <<Examine the uses of the next phi-node on the worklist>>

		unsigned next_phi_id = worklist->iter().current();
		PhiNode *phi_node = phi_node_map[next_phi_id];
		int replacement_id = phi_src_compare(phi_node, loc_ids);

		worklist->remove(next_phi_id);
		if (replacement_id >= 0)
		{
		    if (loc_ids[next_phi_id] == next_phi_id)
			++number_removed;

		    // <<Rewrite uses and add any new phi-nodes to the
		    //   worklist>>

		    List<Operation> &chain = def_use_chains[next_phi_id];
		    for (UseHandle h = chain.begin(); h != chain.end(); ++h)
		    {
			Operation use = *h;

			// Search through use occurrences for the operand being
			// replaced, then replace it.

			Opnd replacee = get_new_name(next_phi_id);
			RewriteTheUse filter(this, replacee, replacement_id);

			if (use.is_phi_handle())
			{
			    // <<Rewrite the parameter and add it to the
			    //   worklist>>
			    // (This scrap descriptor is misleading: we actually
			    // add to the worklist the value ID defined by the
			    // phi-node whose parameter we are rewriting.)

			    PhiNode *phi = *use.get_phi_handle();
			    map_opnds(phi, filter);

			    Opnd definee = get_dst(phi);
			    worklist->insert(lookup_new_opnd(definee));
			}
			else
			{
			    map_opnds(*use.get_instr_handle(), filter);
			}
		    }

		    // <<Move the def-use list>>
		    end_splice(def_use_chains[replacement_id],
			       def_use_chains[next_phi_id]);
		    set_is_useless(phi_node, true);
		}
	    }
	    debug(2, "Number of useless phi-nodes removed: %d", number_removed);
	}
        else
	{
	    // <<Remove useless phi-nodes using the iterative method>>

	    unsigned *loc_ids, number_removed = 0;
	    bool changed = true;

	    // <<Initialize [[loc_ids]]>>

	    loc_ids = new unsigned[def_count];
	    for (unsigned i = 0; i < def_count; ++i)
		loc_ids[i] = i;

	    while (changed)
	    {
		changed = false;

		// <<Search the graph for useless phi-nodes and set [[changed]]
		//   if one is found>>

		CfgNodeListRpo rpo(get_cfg());
		for (CfgNodeHandle bh = rpo.start(); bh != rpo.end(); ++bh)
		{
		    const List<PhiNode*> &block_phi_nodes = get_phi_nodes(*bh);
		    for (PhiHandle ph = block_phi_nodes.begin();
			 ph != block_phi_nodes.end(); ++ph)
		    {
			PhiNode *phi_node = *ph;
			Opnd phi_name = get_dst(phi_node);
			unsigned phi_id = lookup_new_opnd(phi_name);
			int replacement_id =
			    phi_src_compare(phi_node, loc_ids);

			if (replacement_id >= 0 &&
			    replacement_id != find_root(phi_id, loc_ids))
			{
			    if (loc_ids[phi_id] == phi_id)
				number_removed++;
			    loc_ids[phi_id] = replacement_id;
			    changed = true;
			    set_is_useless(phi_node, true);
			}
		    }
		}
		if (!changed)
		{
		    // <<Compress the trees>>
		    for (unsigned i = 0; i < def_count; ++i)
			loc_ids[i] = find_root(i, loc_ids);
		}
	    }

	    // <<Rewrite the graph using the new names in [[loc_ids]]>>

	    CfgNodeListRpo rpo(get_cfg());
	    for (CfgNodeHandle bh = rpo.start(); bh != rpo.end(); ++bh)
	    {
		CfgNode *block = *bh;

		const List<PhiNode*> &block_phi_nodes = get_phi_nodes(block);
		for (PhiHandle ph = block_phi_nodes.begin();
		     ph != block_phi_nodes.end(); ++ph)
		{
		    PhiNode *phi_node = *ph;

		    for (int i = 0; i < srcs_size(phi_node); ++i)
			if (Opnd src = get_src(phi_node, i))
			{
			    int src_id = lookup_new_opnd(src);
			    claim(src_id >= 0);
			    Opnd new_opnd =
				get_new_name(loc_ids[src_id]);
			    set_src(phi_node, i, new_opnd);
			}
		}
		InstrHandle list_iterator = instrs_start(block);
		for (int j = 0; j < instrs_size(block); ++j, ++list_iterator)
		{
		    Instr *instr = *list_iterator;
		    ChangeNames opnd_function(this, loc_ids);
		    map_opnds(instr, opnd_function);
		}
		if (get_keep_live_in_info())
		{
		    // <<Rewrite liveness information to account for removal of
		    //   phi-nodes>>
		    LivenessInfo *current = &live_in[get_number(block)];
		    unsigned *names = current->names;

		    for (unsigned i = 0; i < current->size; ++i)
			names[i] = loc_ids[names[i]];
		}
		if (get_keep_live_out_info())
		{
		    // <<Rewrite liveness information to account for removal of
		    //   phi-nodes>>
		    LivenessInfo *current = &live_out[get_number(block)];
		    unsigned *names = current->names;

		    for (unsigned i = 0; i < current->size; ++i)
			names[i] = loc_ids[names[i]];
		}
	    }
	    debug(2, "Number of useless phi-nodes removed: %d", number_removed);
	}

	// <<Remove the useless phi-nodes' data structures from the graph>>
	// Clear their entries in def_table and def_use_chains (if any).
	// For each source of each useless phi-node, eliminate the phi-node
	// from the def-use chain of the source.  (There can only be one
	// such source that is non-null.)

        CfgNodeListRpo rpo(get_cfg());
        for (CfgNodeHandle bh = rpo.start(); bh != rpo.end(); ++bh)
        {
	    CfgNode *block = *bh;
	    const List<PhiNode*> &phi_list = get_phi_nodes(block);

	    for (PhiHandle ph = phi_list.begin(); ph != phi_list.end(); /**/)
	    {
		PhiNode *phi_node = *ph++;
		if (get_is_useless(phi_node)) {
		    unsigned value_id = lookup_new_opnd(get_dst(phi_node));

		    def_table[value_id] = Operation();
		    if (get_build_def_use_chains()) {
			clear(def_use_chains[value_id]);
			for (int i = 0; i < srcs_size(phi_node); ++i)
			    if (Opnd src = get_src(phi_node, i))
			    {
				int src_id = lookup_new_opnd(src);
				claim(src_id >= 0);
				List<Operation> &c = def_use_chains[src_id];
				for (UseHandle h = c.begin(); h != c.end();/**/)
				{
				    UseHandle this_h = h++;
				    if (*(*this_h).get_phi_handle() == phi_node)
				    {
					c.erase(this_h);
					break;  // Operation is unique in chain
				    }
				}
				break;		// Only one non-null source
			    }
		    }

		    delete remove_phi_node(block, phi_node);
		}
            }
        }
    }

    if (get_keep_live_out_info())
    {
        unsigned i;
        NatSet *temp = new NatSetSparse;
        CfgNode *block;
        CfgNode *successor;

        CfgNodeListRpo rpo(get_cfg());
        for (CfgNodeHandle bh = rpo.start(); bh != rpo.end(); ++bh)
        {
	    block = *bh;

	    unsigned block_num = get_number(block);
	    LivenessInfo *cur_live_out = &live_out[block_num];

	    if (block == get_entry_node(get_cfg()) ||
		block == get_exit_node(get_cfg()))
            {
		live_out[block_num].size = 0;
		continue;
            }
	    temp->remove_all();
	    CfgNodeHandle succ_iterator = succs_start(block);
	    for (/* */; succ_iterator != succs_end(block); ++succ_iterator)
            {
		successor = *succ_iterator;
		LivenessInfo *cur_live_in = &live_in[get_number(successor)];

		for (i = 0; i < cur_live_in->size; ++i)
		    temp->insert(cur_live_in->names[i]);
            }
	    cur_live_out->size = 0;
	    cur_live_out->names = new unsigned[temp->size()];
	    NatSetIter ss_iterator = temp->iter();
	    for (/* */; ss_iterator.is_valid(); ss_iterator.next())
            {
                i = ss_iterator.current();
		cur_live_out->names[cur_live_out->size++] = i;
            }
        }
        set_keep_live_out_info(false); /* we only do this once */
    }
    set_keep_live_in_info(false); /* we only do this once -- this information
				  was built inside of rename_locs */
    is_ssa_cfg = true;
    is_deflated = false;

    if (private_live_in != NULL)
    {
	for (unsigned i = 0; i <= block_count; ++i)
	    delete private_live_in[i];
	delete [] private_live_in;
	private_live_in = NULL;
    }

    if (private_live_out != NULL)
    {
	for (unsigned i = 0; i <= block_count; ++i)
	    delete private_live_out[i];
	delete [] private_live_out;
	private_live_out = NULL;
    }

    if_debug(4)
    {
	fprintf(stderr, "\nJust after building SSA form:\n");
	this->print(stderr);
    }
} // build

/*
 * Replace phi-nodes by inserting equivalent copy instructions.  Be careful
 * to avoid the lost-copy problem and the swap problem, as described in BHS.
 * The `lost_copy_risk' flag is true if copy-folding was done during trans-
 * formation to SSA form, or if subsequent optimizations may have triggered
 * the lost-copy problem.
 */
void
SsaCore::replace_phi_nodes(bool lost_copy_risk)
{
    CopyData *copy_stats = new CopyData[def_count];

    if (lost_copy_risk && !cfg_edges_split())
    {
        private_live_in  = new NatSet*[block_count + 1];
        private_live_out = new NatSet*[block_count + 1];
	for (unsigned i = 0; i <= block_count; ++i)
	    private_live_in[i] = private_live_out[i] = NULL;

	enroll_opnd = &SsaCore::enroll_new_opnd;

	analyze_liveness();

	for (unsigned i = 0; i <= block_count; ++i)
	    delete private_live_in[i];
	delete [] private_live_in;
	private_live_in = NULL;
    }
    else
	// Nullify private_live_out to indicate that we haven't
	// done liveness analysis.
        private_live_out = NULL;

    pushed   = new NatSetSparse;
    dst_list = new NatSetSparse;
    worklist = new NatSetSparse;

    insert_copies(get_entry_node(get_cfg()), copy_stats);

    delete pushed;
    delete dst_list;
    delete worklist;

    if (private_live_out)
    {
	for (unsigned i = 0; i <= block_count; ++i)
	    delete private_live_out[i];
	delete [] private_live_out;
	private_live_out = NULL;
    }

    replaced_phi_nodes = true;
} // replace_phi_nodes


/*
 * Restore SSA CFG to conventional (non-SSA) form and return the embedded
 * CFG..
 *
 * As explained in BHS, original names cannot be restored in general if
 * copy-folding is turned on, or if the client has performed some other
 * optimization that can cause the live ranges of different SSA names for
 * the same original name to overlap.  The caller indicates that such an
 * optimization has been performed by binding argument `not_old_names' to
 * true.
 */
Cfg*
SsaCore::restore(bool not_old_names)
{
    if (!is_ssa_cfg)
	return get_cfg();

    maybe_inflate();

    not_old_names |= get_fold_copies();

    if (not_old_names && !replaced_phi_nodes)
	replace_phi_nodes(not_old_names);

    CfgNodeListRpo rpo(get_cfg());
    for (CfgNodeHandle nh = rpo.start(); nh != rpo.end(); ++nh)
    {
	CfgNode *block = *nh;

	for (InstrHandle ih = instrs_start(block);
	     ih != instrs_end(block); ++ih)
        {
	    Instr *instr = *ih;
	    if (not_old_names)
            {
		// Original names aren't being restored, so we need to be
		// sure that the value of each formal parameter that has a
		// SSA name is transferred to that SSA variable at proc
		// entry.  In code that has been emitted by the gen pass,
		// this is not an issue, since formals are always moved
		// explicitly from their argument-passing locations to
		// local "symbolic registers".  But for SUIFvm code, we
		// must insert a copy for each each formal.  A cheesy way
		// to recognize the SUIFvm target is to check for an empty
		// register file.

		if (has_note(instr, k_proc_entry) &&
		    reg_allocables()->is_empty())
		    for (int i = get_formal_param_count(get_unit()) - 1;
			 i >= 0; --i)
		    {
			Opnd formal = opnd_var(get_formal_param(get_unit(), i));
			int id = get_formal_value_id(i);
			if (id < 0)
			    continue;
			Opnd value  = get_new_name(id);
			int opcode = opcode_move(get_type(value));
			Instr *copy = new_instr_alm(value, opcode, formal);

			if_debug(1)
			    set_comment(copy, "Copy formal to SSA variable");

			insert_after(block, ih, copy);
		    }
	    }
	    else
	    {
		RestoreRegisters opnd_function(this);
		map_opnds(instr, opnd_function);
	    }
        }
	while (SsaPhiAnnote *annote =
	           to<SsaPhiAnnote>(block->take_annote(k_phi_nodes)))
	{
	    while (annote->get_phi_count() > 0)
		delete annote->remove_phi(0);
	    delete annote;
	}
    }
    is_ssa_cfg = false;

    Cfg* result = get_cfg();
    
    ssa->set_cfg(NULL);
    return result;
} // restore

void
SsaCore::print(FILE *fp)
{
    maybe_inflate();

    print_name_map(fp);

    for (CfgNodeHandle h = start(get_cfg()); h != end(get_cfg()); ++h) {
	putc('\n', fp);
	fprint(fp, *h, false);			// no code, header only
	print_phi_nodes(fp, *h);
	fprint(fp, *h, true, true, true);	// show code, addrs, no header
    }

    // print_def_use_chains(fp);

}

void
SsaCore::print_name_map(FILE *fp)
{
    maybe_inflate();

    fprintf(fp, "SSA name map:\n");

    for (int i = 0; i < new_opnd_catalog->size(); ++i)
    {
	if (is_null(get_new_name(i)))
	{
	    claim(get_old_id(i) < 0);
	    continue;
	}
	fprintf(fp, "  ");
	fprint (fp, get_new_name(i));
	fprintf(fp, ":\t");
	fprint (fp, get_old_name(get_old_id(i)));
	fprintf(fp, "\n");
    }
}

void
SsaCore::print_phi_nodes(FILE *fp, CfgNode *block)
{
    const List<PhiNode*> &block_phi_nodes = get_phi_nodes(block);
    for (PhiHandle h = block_phi_nodes.begin();
	 h != block_phi_nodes.end(); ++h)
    {
	PhiNode *phi_node = *h;
	fprintf(fp, "[%lx]\t\t", (unsigned long)phi_node);
	fprint (fp, get_dst(phi_node));
        fprintf(fp, "\t<- PHI(");

	const char *sep = "";
	for (int i = 0; i < srcs_size(phi_node); ++i) {
	    fprintf(fp, sep);
	    sep = ", ";
	    fprint (fp, get_src(phi_node, i));
	}
        fprintf(fp, ")\n");
    }
}

int
SsaCore::get_loc_count() // const
{
    maybe_inflate();
    return _loc_count;
}

int
SsaCore::get_value_count() // const
{
    maybe_inflate();
    return def_count;
}

OpndCatalog*
SsaCore::get_value_catalog() // const
{
    maybe_inflate();
    return new_opnd_catalog;
}

Opnd
SsaCore::get_value_name(int value_id) // const
{
    return ssa->get_new_name(value_id);
}

Operation
SsaCore::get_unique_def(Opnd opnd) // const
{
    maybe_inflate();

    int new_opnd_id = lookup_new_opnd(opnd);
    if (new_opnd_id >= 0)
	return def_table[new_opnd_id];

    return Operation();
}

const List<Operation>&
SsaCore::get_def_use_chain(Opnd opnd) // const
{
    maybe_inflate();
    static List<Operation> none;

    if (get_build_def_use_chains())
    {
	int new_opnd_id = lookup_new_opnd(opnd);
	if (new_opnd_id >= 0)
	    return def_use_chains[new_opnd_id];
    }
    return none;
}

const List<PhiNode*>&
SsaCore::get_phi_nodes(CfgNode *block) const
{
    static List<PhiNode*> empty_phi_list;

    Annote *annote = block->peek_annote(k_phi_nodes);

    if (annote == NULL)
	return empty_phi_list;
    else
	claim(is_kind_of<SsaPhiAnnote>(annote),
	      "Wrong kind of \"phi_nodes\" annote");

    return static_cast<SsaPhiAnnote*>(annote)->phis();
}

PhiHandle
SsaCore::append_phi_node(CfgNode *block, PhiNode *phi)
{
    Annote *annote = block->peek_annote(k_phi_nodes);

    if (annote == NULL)
    {
	annote = create_ssa_phi_annote(the_suif_env, k_phi_nodes);
	block->append_annote(annote);
    }
    else
    {
	claim(is_kind_of<SsaPhiAnnote>(annote),
	      "Wrong kind of \"phi_nodes\" annote");
    }
    SsaPhiAnnote *phi_annote = static_cast<SsaPhiAnnote*>(annote);
    phi_annote->append_phi(phi);
    return get_last_handle(phi_annote->phis());
}

PhiNode*
SsaCore::remove_phi_node(CfgNode *block, PhiNode *phi)
{
    Annote *annote = block->peek_annote(k_phi_nodes);

    claim(annote != NULL, "Removing phi-node from block that has none");
    claim(is_kind_of<SsaPhiAnnote>(annote),
	  "Wrong kind of \"phi_nodes\" annote");

    SsaPhiAnnote *phi_annote = static_cast<SsaPhiAnnote*>(annote);
    const List<PhiNode*> &phis = phi_annote->phis();
    PhiHandle h = phis.begin();
    for (unsigned i = 0; i < phis.size(); ++i, ++h)
	if (*h == phi)
	    return phi_annote->remove_phi(i);

    claim(false, "Phi-node handle not found in block");
    return NULL;
}

CfgNode*
SsaCore::get_def_block(int value_id) // const
{
    maybe_inflate();

    Operation def = def_table[value_id];
    CfgNode *block = NULL;

    if (def.is_phi_handle())
	block = get_parent_node(*def.get_phi_handle());
    else
    if (def.is_instr_handle())
	block = get_parent_node(*def.get_instr_handle());

    return block;
}

/*
 * record_use_swap
 *
 * Reflect the replacement of a use occurrence (out) by another one (in).
 *
 * The actual change is performed by the caller.  The record_use_swap
 * methods just update the def-use chains, if those are being maintained.
 *
 * NB: If the name being swapped in is a newly-created SSA name, its
 * definition must already have been processed by record_def before
 * record_use_swap is called.
 */
void
SsaCore::record_use_swap(Opnd out, Opnd in, Operation operation)
{
    if (!get_build_def_use_chains())
	return;

    maybe_inflate();

    int out_id = lookup_new_opnd(out);
    if (out_id >= 0)
    {
	List<Operation> &chain = def_use_chains[out_id];
	for (UseHandle h = chain.begin(); h != chain.end(); /* */)
	{
	    UseHandle this_h = h++;
	    if ((*this_h).get_instr_handle() == operation.get_instr_handle() ||
		(*this_h).get_phi_handle()   == operation.get_phi_handle())
		chain.erase(this_h);
	}
    }
    int in_id = lookup_new_opnd(in);
    if (in_id >= 0)
	def_use_chains[in_id].push_back(operation);
}

/*
 * record_all_uses
 *
 * Take note of all the use occurrences within a newly planted instruction
 * or phi-node.
 *
 * Assume that any SSA names among these operands have already been
 * enrolled, e.g., by calling record_def on their defining instructions.
 * Update the def-use chains of any SSA names found among the input
 * operands.
 */

void
SsaCore::record_all_uses(Operation operation)
{
    if (get_build_def_use_chains())
    {
	maybe_inflate();

	RecordUses record_uses(this);
	map_opnds(operation, record_uses);
	record_uses.commit(operation);
    }
}


/*
 * record_def
 *
 * Reflect the introduction of a new definition, either in the form of an
 * instruction or a phi-node.  In either case:
 *
 *   The new "name" is already in place in a destination field (designated
 *   by dst_pos for the instruction case) of the defining operation.  Both
 *   the old name and new name may need to be recorded in internal counters
 *   and tables.
 */
void
SsaCore::record_def(Opnd old_name, Operation operation, int dst_pos)
{
    maybe_inflate();

    int old_id = enroll_old_opnd(old_name);
    if (old_id >= (signed)_loc_count)
    {
	_loc_count = old_id + 1;
	resize_old_names(_loc_count);
    }
    ssa->replace_old_name(old_id, old_name);

    Opnd new_name = get_dst(operation, dst_pos);
    int new_id = enroll_new_opnd(new_name);
    claim(new_id >= 0, "Definee should be an acceptable SSA name");

    if (new_id >= (signed)def_count)
    {
	def_count = new_id + 1;
	resize_new_names(def_count);
	def_table.resize(def_count, Operation());
	resize_old_ids(def_count);
	if (get_build_def_use_chains())
	    def_use_chains.resize(def_count, List<Operation>());
    }
    def_table[new_id] = operation;
    ssa->replace_new_name(new_id, new_name);

    set_old_id(new_id, old_id);
}

// FIXME: Why does the following print all of the sources of phi-node, when each
// represents just one of those?

void
SsaCore::print_def_use_chains(FILE *fp)
{
    maybe_inflate();

    unsigned i;

    fprintf(fp, "\n\n PRINTING DEF-USE CHAINS\n\n");
    for (i = 0; i < def_count; ++i)
    {
        List<Operation> &chain = def_use_chains[i];

        fprintf(fp, "*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*\n");
        fprintf(fp, "LOC NAME: %d\n", i);

	for (UseHandle h = chain.begin(); h != chain.end(); ++h)
        {
	    Operation use = *h;

            fprintf(fp, "----------\n");
            fprintf(fp, "\tIs_Phi_Node: ");
            if (use.is_phi_handle())
            {
                int j;
                PhiNode *phi = *use.get_phi_handle();

                fprintf(fp, "true\n");
                fprintf(fp, "\tPhi Node Sources(old_name):\n\t\t");
                for (j = 0; j < srcs_size(phi); ++j)
                {
                    unsigned src_id = lookup_new_opnd(get_src(phi, j));

                    fprintf(fp, "%u(%u)   ", src_id,
			    ((bool)(src_id >= 0) ? get_old_id(src_id) : -1));
                }
            }
            else
            {
                fprintf(fp, "false\n");
                fprintf(fp, "\tOpcode = %d\n",
			get_opcode(*use.get_instr_handle()));
            }
        }
        fprintf(fp, "*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*\n");
    }
    fprintf(fp, "\n\n***DONE*** PRINTING DEF-USE CHAINS\n\n");
} // print_def_use_chains

int
SsaCore::enroll_old_opnd(Opnd opnd)
{
    int opnd_id = -1;
    old_opnd_catalog->enroll(opnd, &opnd_id);
    if (opnd_id >= 0)
    {
	claim((unsigned)opnd_id < ssa->get_old_name_count());
	ssa->replace_old_name(opnd_id, opnd);
    }
    return opnd_id;
}

int
SsaCore::lookup_old_opnd(Opnd opnd) const
{
    int opnd_id = -1;
    old_opnd_catalog->lookup(opnd, &opnd_id);
    return opnd_id;
}

int
SsaCore::enroll_new_opnd(Opnd opnd)
{
    int opnd_id = -1;
    new_opnd_catalog->enroll(opnd, &opnd_id);
    if (opnd_id >= 0)
    {
	claim((unsigned)opnd_id < ssa->get_new_name_count());
	ssa->replace_new_name(opnd_id, opnd);
    }
    return opnd_id;
}

int
SsaCore::lookup_new_opnd(Opnd opnd) const
{
    int opnd_id = -1;
    new_opnd_catalog->lookup(opnd, &opnd_id);
    return opnd_id;
}

void
SsaCore::record_liveness_info(NatSet **sets, bool live_out_info)
{
    unsigned i, j;
    LivenessInfo *temp = new LivenessInfo[block_count + 1];
    for (int k = 0; (unsigned)k < block_count + 1; ++k)
    {
        temp[k].size = 0;
        temp[k].names = NULL;
    }

    // Does this need to change to a block iterator?
    for (i = 1; i <= block_count; ++i)
    {
        if (sets[i])
        {
            unsigned size = sets[i]->size();

            temp[i].names = new unsigned[size];
            NatSetIter set_iterator = sets[i]->iter();
            for (/* */; set_iterator.is_valid(); set_iterator.next())
	    {
                j = set_iterator.current();
                temp[i].names[temp[i].size++] = j;
	    }
        }
    }

    if (live_out_info)
        live_out = temp;
    else
        live_in = temp;

} // record_liveness_info

/*
 * Generate new names for phi nodes.
 */
void
SsaCore::rename_locs(CfgNode *block, NameStackEntry **name_stacks)
{
    int pushed_list = -1;

    pushed->remove_all();

    const List<PhiNode*> &block_phi_nodes = get_phi_nodes(block);
    for (PhiHandle ph = block_phi_nodes.begin();
	 ph != block_phi_nodes.end(); ++ph)
    {
	PhiNode *phi_node = *ph;

	// The dst field of phi_node is temporarily holding the old name.
	// Make up an SSA name and replace the dst field.

	Opnd old_name = get_dst(phi_node);
	Opnd new_name = opnd_reg(get_type(old_name));
	set_dst(phi_node, new_name);

	unsigned old_name_id = lookup_old_opnd(old_name);
	unsigned new_name_id = enroll_new_opnd(new_name);
	claim((old_name_id < _loc_count) && (new_name_id < def_count));

	set_old_id(new_name_id, old_name_id);
	push_name(&name_stacks[old_name_id], pushed, &pushed_list,
		  old_name_id, new_name);
	pushed->insert(old_name_id);
	def_table[new_name_id] = Operation(ph);
    }

    if (get_keep_live_in_info() & (block != get_entry_node(get_cfg()) &&
				   block != get_exit_node(get_cfg())))
        rewrite_liveness_info(&live_in[get_number(block)], name_stacks);

    InstrHandle ih = instrs_start(block);
    for (int j = size(block); j > 0; --j)
    {
	InstrHandle handle = ih++;
	Instr *instr = *handle;
	int opcode = get_opcode(instr);

	ReplaceUsedLocs replace_used_locs(this, name_stacks, opcode, block);
	map_opnds(instr, replace_used_locs);

	// Can only fold a copy if its dst (still an "old" name) is a
	// registered SSA candidate and its src is already an SSA name.

	Opnd src, dst;
	int src_id, dst_id;

	if (get_fold_copies() && is_move(instr) &&
	    0 <= (src_id = lookup_new_opnd(src = get_src(instr, 0))) &&
	    0 <= (dst_id = lookup_old_opnd(dst = get_dst(instr, 0))))
	{
	    push_name(&name_stacks[dst_id], pushed, &pushed_list, dst_id, src);
	    delete remove(block, handle);
	    continue;
	}
	// We're not deleting this instruction, so (optionally) enter its
	// use occurrences in def_use_chains and replace its defined
	// locations by their SSA names.

	if (get_build_def_use_chains())
	{
	    RecordUses record_uses(this);
	    map_opnds(*handle, record_uses);
	    record_uses.commit(handle);
	}
	RenameDefinedLocs
	    rename_defined_locs(this, handle, name_stacks, &pushed_list);

	if (!has_note(instr, k_proc_entry))
	{
	    map_dst_opnds(instr, rename_defined_locs);
	}
	else
	{
	    map_formal_defs(get_unit(), rename_defined_locs);
	    int count = get_formal_param_count(get_unit());
	    resize_formal_value_ids(count);
	    for (int i = 0; i < count; ++i)
	    {
		Opnd formal = opnd_var(get_formal_param(get_unit(), i));
		int id = lookup_old_opnd(formal);
		if (id >= 0)
		    id = lookup_new_opnd(name_stacks[id]->new_name);
		ssa->replace_formal_value_id(i, id);
	    }
	}
    }

    // Fill in the phi nodes of block's successors.  A block can appear
    // more than once in block's successor list, but must only be processed
    // once.

    static BitVector done;
    done.set_to_zero();

    CfgNodeHandle sh = succs_start(block);
    for (int k = succs_size(block); k > 0; --k, ++sh)
    {
	CfgNode *succ_block = *sh;
	unsigned succ_block_num = get_number(succ_block);
	if (done.get_bit(succ_block_num))
	    continue;
	done.set_bit(succ_block_num, true);

	unsigned phi_srcs_index = phi_srcs_indices[succ_block_num]++;
	const List<PhiNode*> &succ_phi_nodes = get_phi_nodes(succ_block);

	for (PhiHandle ph = succ_phi_nodes.begin();
	     ph != succ_phi_nodes.end(); ++ph)
	{
	    PhiNode *phi_node = *ph;

	    // The dst field of phi_node is probably an original (non-SSA)
	    // name, but may already have been replaced by the
	    // corresponding SSA name.

	    int old_name_id = lookup_old_opnd(get_dst(phi_node));
	    if (old_name_id < 0)
	    {
		int new_name_id = lookup_new_opnd(get_dst(phi_node));
		claim(new_name_id >= 0);
		old_name_id = get_old_id(new_name_id);
		claim(old_name_id >= 0);
	    }

	    NameStackEntry *top_of_stack = name_stacks[old_name_id];

	    if (top_of_stack)
	    {
		Opnd new_name = top_of_stack->new_name;	// avoids derefs

		set_src(phi_node, phi_srcs_index, new_name);
		if (get_build_def_use_chains())
		{
		    unsigned new_name_id = lookup_new_opnd(new_name);
		    claim(new_name_id >= 0);

		    def_use_chains[new_name_id].push_back(Operation(ph));
		}
	    }
	}

	if (!get_phi_nodes(succ_block).empty())
	{
	    PhiSrcMapEntry *new_node = new PhiSrcMapEntry;

	    new_node->index = phi_srcs_index;
	    new_node->succ_block = succ_block;
	    new_node->next = phi_src_map[get_number(block)];
	    phi_src_map[get_number(block)] = new_node;
	}
	edge_maps[succ_block_num][phi_srcs_index] = block;
    }

    for (DominanceChild *child = dominator_children[get_number(block)];
	 child != NULL;
	 child = child->next)
	rename_locs(get_node(get_cfg(), child->block_number), name_stacks);

    while (pushed_list >= 0)
    {
	int next_node = name_stacks[pushed_list]->next_pushed;

	NameStackEntry *temp_ptr = name_stacks[pushed_list];
	name_stacks[pushed_list] = name_stacks[pushed_list]->next;
	temp_ptr->next = NULL;
	delete temp_ptr;
	pushed_list = next_node;
    }
} // rename_locs

void
SsaCore::rewrite_liveness_info(LivenessInfo *set, NameStackEntry **name_stacks)
{
    unsigned i, size = set->size;

    set->size = 0;
    for (i = 0; i < size; i++)
    {
        claim(name_stacks[set->names[i]]);
	set->names[set->size++] =
	    lookup_new_opnd(name_stacks[set->names[i]]->new_name);
    }
} // rewrite_liveness_info

void
SsaCore::push_name(NameStackEntry **stack,
		   NatSet *pushed, int *node_list_pointer,
		   unsigned old_name, Opnd new_name)
{
    if (pushed->contains(old_name))
        (*stack)->new_name = new_name;
    else
    {
	NameStackEntry *new_node = new NameStackEntry;

        new_node->new_name = new_name;
        new_node->next_pushed = *node_list_pointer;
        *node_list_pointer = old_name;
        new_node->next = *stack;
        *stack = new_node;
        pushed->insert(old_name);
    }
} // push_name

int
SsaCore::find_root(unsigned value_id, unsigned *loc_ids)
{
    if (loc_ids[value_id] != value_id)
        loc_ids[value_id] =
	    find_root(loc_ids[value_id], loc_ids);
    return loc_ids[value_id];
} // find_root

/*
 * Detect a "useless" phi-node: one whose sources (ignoring nulls) are all
 * the same.  (Recall that a null source corresponds to an incoming path
 * along which the underlying location is uninitialized.)  If the phi-node
 * qualifies as useless, return the ID of the sole (non-null) source.
 * Otherwise, return -1.
 *
 * Note that BHS implement a more aggressive definition of "useless", under
 * which v2 <- PHI(v1, v2) could be folded away, with v1 substituted for
 * uses of v2.  This appears to lead to erroneous treatment of loops like
 * the following:
 *
 *     int v, i;
 *
 *     for (i = 0; i < n; ++i)
 *         if (i == 0)
 *             v = i;
 *         else
 *             print(v == i);
 *
 * The BHS treatment of "useless" phi-nodes seems to lead to the conclusion
 * that the argument to print() is always true.
 */
int
SsaCore::phi_src_compare(PhiNode *phi_node, unsigned *loc_ids)
{
    int replacement_id = -1;
#ifdef BHS_USELESS_PHI_NODES
    int phi_node_id = lookup_new_opnd(get_dst(phi_node));
#endif

    for (int i = 0; i < srcs_size(phi_node); ++i)
    {
        Opnd phi_src = get_src(phi_node, i);
        int phi_src_id = lookup_new_opnd(phi_src);

	if (phi_src_id >= 0)
	{
	    phi_src_id = find_root(phi_src_id, loc_ids);
#ifdef BHS_USELESS_PHI_NODES
	    if (phi_src_id != phi_node_id)
#endif
	    {
		if (replacement_id == -1)
		    replacement_id = phi_src_id;
		else if (replacement_id != phi_src_id)
		    return -1;
	    }
	}
    }
    claim(replacement_id >= 0);
    return replacement_id;
} // phi_src_compare

/*
 * Return true unless the CFG has a critical back edge.  A back edge is one
 * whose head dominates its tail.  A critical edge is one whose tail has
 * multiple successors and whose head has multiple predecessors.  We know
 * that the head block of a back edge has other predecessors, so we only
 * check the tail block's successor count once we find a back edge.  Note
 * that we must not count twice if a tail block has two edges to the same
 * successor.
 */
bool
SsaCore::cfg_edges_split()
{
    CfgNodeListRpo rpo(get_cfg());
    for (CfgNodeHandle h = rpo.start(); h != rpo.end(); ++h)
    {
	CfgNode *block = *h;
	bool back_edge_found = false;
	int succ_count = 0;
	static BitVector done;
	done.set_to_zero();

        CfgNodeHandle sh = succs_start(block);
        for (int k = succs_size(block); k > 0; --k, ++sh)
        {
	    CfgNode *succ = *sh;
	    int succ_number = get_number(succ);
	    if (done.get_bit(succ_number))
		continue;
	    done.set_bit(succ_number, true);
	    succ_count++;

	    // Rice says: "This only detects back edges for natural loops.
	    // We should switch to Tarjan's method."
	    if (dominator_analysis->dominates(succ, block))
		back_edge_found = true;

	    if (back_edge_found && succ_count > 1)
		return false;
        }
    }
    return true;
} // cfg_edges_split

/*
 * Recursive helper of replace_phi_nodes.  Described in BHS section
 * "Inserting the copies".
 */
void
SsaCore::insert_copies(CfgNode *block, CopyData *copy_stats)
{
    int pushed_list = -1;

    pushed->remove_all();
    dst_list->remove_all();

    // <<Walk through the instructions in the block, replacing uses with
    // new names>>.
    // Start with the uses occurring in the phi-nodes.

    const List<PhiNode*> &block_phi_nodes = get_phi_nodes(block);
    for (PhiHandle h = block_phi_nodes.begin();
	 h != block_phi_nodes.end(); ++h)
    {
	PhiNode *phi_node = *h;
	claim(srcs_size(phi_node) == preds_size(block));

	for (int i = 0; i < srcs_size(phi_node); ++i)
	{
	    Opnd phi_src = get_src(phi_node, i);
	    int src_id = lookup_new_opnd(phi_src);
	    if (src_id >= 0 && copy_stats[src_id].new_name)
		set_src(phi_node, i, copy_stats[src_id].new_name->new_name);
	}
    }
    // Now visit each phi node again.  If its SSA name is live out of this
    // block, push that name onto its own name stack to avoid damaging a
    // copy-to-temporary that has already been inserted during the
    // processing of another block.

    for (PhiHandle h = block_phi_nodes.begin();
	 h != block_phi_nodes.end(); ++h)
    {
	Opnd name = get_dst(*h);
	int name_id = lookup_new_opnd(name);

	if (private_live_out &&
	    private_live_out[get_number(block)]->contains(name_id))
#ifndef DONT_PUSH_LIVE_NAME
	    push_name(&(copy_stats[name_id].new_name),
		      pushed, &pushed_list, name_id, name);
#else
	    claim(copy_stats[name_id].new_name == NULL,
		  "Expected empty SSA name stack");
#endif
    }
    // Now replace uses with new names in the block's instructions.

    InstrHandle handle = instrs_start(block);
    for (int j = instrs_size(block); j > 0; --j, ++handle)
    {
	ReplaceSourceNames opnd_function(this, copy_stats);
	map_opnds(*handle, opnd_function);
    }

    // <<Insert copies into [[block]] from all of its successors>>
    //   <<Phi-node replacement pass 1: initialize the data structures>>

    PhiSrcMapEntry *next = phi_src_map[get_number(block)];
    while (next)
    {
	unsigned index = next->index;
	CfgNode *succ_block = next->succ_block;

	const List<PhiNode*> &succ_block_phi_nodes = get_phi_nodes(succ_block);
	for (PhiHandle h = succ_block_phi_nodes.begin();
	     h != succ_block_phi_nodes.end(); ++h)
	{
	    PhiNode *phi_node = *h;
	    Opnd src_name = get_src(phi_node, index);
	    Opnd dst_name = get_dst(phi_node);
	    int src_id = lookup_new_opnd(src_name);
	    int dst_id = lookup_new_opnd(dst_name);

	    if (src_id >= 0 && copy_stats[src_id].new_name) {
		src_name = copy_stats[src_id].new_name->new_name;
		src_id = lookup_new_opnd(src_name);
	    }
	    if (src_id >= 0 && dst_id != src_id)
	    {
		claim(dst_id >= 0);

		// <<Add the statistics for this copy into the [[copy_stats]]
		// array>>
		copy_stats[dst_id].src = src_name;
		copy_stats[dst_id].is_live_out =
		    (private_live_out)
			? private_live_out[get_number(block)]->
		    	    contains(dst_id)
			: false;
		copy_stats[dst_id].src_name_to_use = dst_name;
		copy_stats[src_id].src_name_to_use = src_name;
		copy_stats[src_id].used_by_count++;
		dst_list->insert(dst_id);
	    }
	}
	next = next->next;
    }

    // <<Phi-node replacement pass 2: set up the worklist for inserting
    // copies for phi nodes>>

    for (NatSetIter dst_iter = dst_list->iter();
	 dst_iter.is_valid(); dst_iter.next())
    {
	unsigned dst = dst_iter.current();
	if (copy_stats[dst].used_by_count == 0)
	    worklist->insert(dst);
    }

    // <<Phi-node replacement pass 3: iterate over the worklist,
    // inserting copies>>

    unsigned dst_list_size;
    do {
	while (worklist->size() > 0)
	{
	    // <<Choose a copy off of the worklist, insert it, and remove
	    // it from [[destination_list]]>>

	    unsigned dst_id = worklist->iter().current();
	    Opnd dst_name = get_new_name(dst_id);
	    Opnd src_name = copy_stats[dst_id].src;
	    int src_id = lookup_new_opnd(src_name);

	    worklist->remove(dst_id);
	    if (copy_stats[dst_id].is_live_out
		&& is_null(copy_stats[dst_id].temp_name))
	    {
		copy_stats[dst_id].is_live_out = false;

		// <<Insert a copy to a temporary to store the old value>>
		// Caution: we obscure the enclosing bindings of variables
		// {src,dst}_{name,id}.  The ones here are for the copy-to-
		// temporary instruction.

		Opnd src_name = dst_name;
		unsigned src_id = dst_id;
		Opnd dst_name = opnd_reg(get_type(src_name));
		int dst_id = enroll_new_opnd(dst_name);

		copy_stats[src_id].used_by_count = 0;

		// <<Insert a copy for the temp>>
		// Insert this copy "at the phi node", i.e., at the start
		// of the block.

		int opcode = opcode_move(get_type(dst_name));
		Opnd src_name_to_use = copy_stats[src_id].src_name_to_use;
		Instr *new_instr =
		    new_instr_alm(dst_name, opcode, src_name_to_use);

		if_debug(1)
		    set_comment(new_instr,
				"Copy to temp at phi node to save old value");

		// <<Insert [[new_instruction]] into [[block]]>>
		CfgNode *block = get_def_block(src_id);
		InstrHandle new_handle = prepend(block, new_instr);
		def_table[dst_id] = Operation(new_handle);
		set_old_id(dst_id, get_old_id(src_id));

		copy_stats[src_id].temp_name = dst_name;
		copy_stats[src_id].src_name_to_use = dst_name;
		push_name(&(copy_stats[src_id].new_name),
			  pushed, &pushed_list, src_id, dst_name);
	    }
	    Instr *new_instr =
		new_instr_alm(dst_name,
			      opcode_move(get_type(dst_name)),
			      copy_stats[src_id].src_name_to_use);

	    if_debug(1)
	    {
		Opnd old_name = get_old_name(get_old_id(dst_id));
		char buf[BUFSIZ];
		if (is_reg(old_name))
		    sprintf(buf, "$vr%d", get_reg(old_name));
		else
		    sprintf(buf, "`%s'", get_name(get_var(old_name)).chars());
		String comment = String("Copy to phi-defined name for ") + buf;
		set_comment(new_instr, comment);
	    }

	    // <<Insert [[new_instruction]] into [[block]]>>
	    // Put it at the end of the block, but before a CTI if there is one.

	    insert_before(block, get_cti_handle(block), new_instr);

	    copy_stats[src_id].used_by_count = 0;
	    if (dst_list->contains(src_id) &&
		copy_stats[src_id].is_live_out)
		push_name(&(copy_stats[src_id].new_name),
			  pushed, &pushed_list, src_id, dst_name);
	    copy_stats[src_id].is_live_out = false;
	    copy_stats[src_id].src_name_to_use = dst_name;

	    if (dst_list->contains(src_id))
		worklist->insert(src_id);
	    dst_list->remove(dst_id);
	}

	dst_list_size = dst_list->size();
	if (dst_list_size)
	{
	    // <<Insert a copy to a temporary to break the cycle>>
	    unsigned src_id = dst_list->iter().current();
	    Opnd src_name = get_new_name(src_id);
	    Opnd dst_name;
	    unsigned dst_id;

	    if (is_null(copy_stats[src_id].temp_name))
	    {
		dst_name = opnd_reg(get_type(src_name));
		dst_id = enroll_new_opnd(dst_name);
		copy_stats[src_id].temp_name = dst_name;

		// <<Insert a copy for the temp>>
		Instr *new_instr =
		    new_instr_alm(dst_name,
				  opcode_move(get_type(dst_name)),
				  copy_stats[src_id].src_name_to_use);

		if_debug(1)
		    set_comment(new_instr,
				"Copy to temp at block end to break cycle");

		// <<Insert the copy into [[block]]>>.
		// A cycle-breaking copy should go at the end of [[block]].

		CfgNode *block = get_def_block(src_id);
		InstrHandle end = get_cti_handle(block);
		InstrHandle new_handle = insert_before(block, end, new_instr);

		set_old_id(dst_id, get_old_id(src_id));
		def_table[dst_id] = Operation(new_handle);
	    }
	    else
	    {
		dst_name = copy_stats[src_id].temp_name;
		dst_id = lookup_new_opnd(dst_name);
	    }

	    // Source's value will be obtained from the temp location from
	    // now on, so mark the source dead and zero its count of uses.

	    copy_stats[src_id].used_by_count = 0;
	    copy_stats[src_id].is_live_out = false;
	    copy_stats[src_id].src_name_to_use = dst_name;
	    push_name(&(copy_stats[src_id].new_name),
		      pushed, &pushed_list, src_id, dst_name);
	    worklist->insert(src_id);
	}
    } while (dst_list_size > 0);

    // <<Recur over all of the block's children in the dominator tree>>

    for (DominanceChild *child = dominator_children[get_number(block)];
	 child != NULL;
	 child = child->next)
	insert_copies(get_node(get_cfg(), child->block_number), copy_stats);

    // <<Pop any names added during this run>>

    while (pushed_list >= 0)
    {
        int next_node = copy_stats[pushed_list].new_name->next_pushed;

        copy_stats[pushed_list].new_name =
	    copy_stats[pushed_list].new_name->next;
        pushed_list = next_node;
    }
} // insert_copies


void
SsaCore::build_dominator_tree()
{
    dominator_children = new DominanceChild*[block_count+1];

    for (unsigned i = 0; i < block_count + 1; ++i)
	dominator_children[i] = NULL;

    for (int i = 0; i < size(get_cfg()); i++)
    {
        CfgNode *block = get_node(get_cfg(), i);
        int block_number = get_number(block);
        CfgNode *immediate_dominator =
	    dominator_analysis->immed_dom(block_number);

        if (immediate_dominator != NULL)
	{
            // Node has a parent
            int dominator_number = get_number(immediate_dominator);

            DominanceChild *temp_ptr = new DominanceChild(block_number);
            if (dominator_children[dominator_number] == NULL)
	    {
                dominator_children[dominator_number] = temp_ptr;
                temp_ptr->next = NULL;
	    }
            else
	    {
                temp_ptr->next = dominator_children[dominator_number];
                dominator_children[dominator_number] = temp_ptr;
	    }
	}
    }
}

void
SsaCore::analyze_liveness()
{
    Vector<NatSetSparse> killed(block_count + 1);

    CfgNodeListRpo rpo(get_cfg());
    for (CfgNodeHandle h = rpo.start(); h != rpo.end(); ++h)
    {
	CfgNode *block = *h;
	unsigned block_num = get_number(block);

	NatSet *cur_live_in;
	NatSet *cur_live_out;

	private_live_in[block_num] = new NatSetSparse;
	cur_live_in = private_live_in[block_num];

	if (is_ssa_cfg || get_keep_live_out_info())
	{
	    private_live_out[block_num] = new NatSetSparse;
	    cur_live_out = private_live_out[block_num];
	}

	if (block != get_exit_node(get_cfg()))
	{
	    NatSet *cur_killed = &killed[block_num];

	    if (is_ssa_cfg)
	    {
		const List<PhiNode*> &block_phi_nodes = get_phi_nodes(block);
		for (PhiHandle h = block_phi_nodes.begin();
		     h != block_phi_nodes.end(); ++h)
		{
		    PhiNode *phi_node = *h;
		    int value_id = lookup_new_opnd(get_dst(phi_node));
		    claim(value_id >= 0);
		    cur_killed->insert(value_id);
		}
	    }

	    InstrHandle ih = instrs_start(block);
	    int block_size = instrs_size(block);
	    for (int j = 0; j < block_size; ++j, ++ih)
	    {
		Instr *instr = *ih;
		AddToLiveIn add_to_live_in(this, cur_killed, cur_live_in);
		map_opnds(instr, add_to_live_in);

		AddToCurKilled add_to_cur_killed(this, cur_killed);
		map_dst_opnds(instr, add_to_cur_killed);
	    }
	}
    }
    if (is_ssa_cfg)
    {
	phi_node_uses = new NatSet*[block_count + 1];

	for (CfgNodeHandle h = rpo.start(); h != rpo.end(); ++h)
	{
	    CfgNode *block = *h;

	    unsigned block_num = get_number(block);
	    phi_node_uses[block_num] = new NatSetSparse;

	    for (PhiSrcMapEntry *pair = phi_src_map[block_num];
		 pair; pair = pair->next)
	    {
		unsigned phi_src_index = pair->index;
		CfgNode *succ = pair->succ_block;

		const List<PhiNode*> &succ_phi_nodes = get_phi_nodes(succ);
		for (PhiHandle h = succ_phi_nodes.begin();
		     h != succ_phi_nodes.end(); ++h)
		{
		    Opnd src = get_src(*h, phi_src_index);
		    int src_id = lookup_new_opnd(src);
		    if (src_id >= 0)
			phi_node_uses[block_num]->insert(src_id);
		}
	    }
	}
    }

    bool changed;
    NatSetSparse temp;

    do {
	CfgNode *block;

	changed = false;
	CfgNodeListRpo rpo(get_cfg());
	for (CfgNodeHandle h = rpo.start(); h != rpo.end(); ++h)
	{
	    block = *h;

	    if (block != get_exit_node(get_cfg()))
	    {
		unsigned block_num = get_number(block);
		NatSet *current_live_in = private_live_in[block_num];
		NatSet *current_live_out =
		    (is_ssa_cfg || get_keep_live_out_info())
		    ? private_live_out[block_num]
		    : NULL;

		CfgNode *successor;
		bool first_successor = true;

		for (CfgNodeHandle sh = succs_start(block);
		     sh != succs_end(block); ++sh)
		{
		    successor = *sh;
		    if (first_successor)
		    {
			// Originally copied pointers - trying this
			temp = *private_live_in[get_number(successor)];
			first_successor = false;
		    }
		    else
			temp += *(private_live_in[get_number(successor)]);
		}

		if (is_ssa_cfg)
		    temp += *(phi_node_uses[get_number(block)]);

		if ((is_ssa_cfg || get_keep_live_out_info()) &&
		    (*current_live_out != temp))
		    *current_live_out = temp;

		NatSetSparse killed_complement = killed[block_num];
		killed_complement.complement();
		temp *= killed_complement;
		temp += *current_live_in;

		if (*current_live_in != temp)
		{
		    changed = true;
		    *current_live_in = temp;
		}
	    }
	}
    } while (changed);

    if (is_ssa_cfg)
	delete phi_node_uses;

    if (get_keep_live_in_info())
	record_liveness_info(private_live_in, false);
    if (get_keep_live_out_info())
	record_liveness_info(private_live_out, true);
}

void
SsaCore::set_comment(Instr *instr, IdString comment)
{
    ListNote<IdString> note;
    note.append(comment);
    set_note(instr, k_comment, note);
}

/*
 * Fill in an SsaCore object from the file-resident representation of the
 * SsaCfg, and deflate the latter's hoof-generated components.
 */
void
SsaCore::inflate()
{
    claim(is_deflated, "inflate: SSA CFG is already in inflated form");

    old_opnd_catalog = new RegSymCatalog(false, is_ssa_candidate);
    new_opnd_catalog = new RegSymCatalog(false, is_ssa_candidate);

    for (unsigned i = 0; i < ssa->get_old_name_count(); ++i)
    {
	enroll_old_opnd(ssa->get_old_name(i));
    }
    for (unsigned i = 0; i < ssa->get_new_name_count(); ++i)
    {
	enroll_new_opnd(ssa->get_new_name(i));
    }

    block_count = size(get_cfg());
    _loc_count = old_opnd_catalog->size();
    def_count  = new_opnd_catalog->size();

    def_table.resize(def_count, Operation());

    dominator_analysis = new DominanceInfo(get_cfg());
    dominator_analysis->find_dominators();
    build_dominator_tree();

    edge_maps = new CfgNode**[block_count+1];

    CfgNodeListRpo rpo(get_cfg());
    for (CfgNodeHandle h = rpo.start(); h != rpo.end(); ++h)
    {
	CfgNode *block = *h;
	if (block != get_entry_node(get_cfg()))
	{
	    unsigned pred_count = preds_size(block);
	    edge_maps[get_number(block)] = new CfgNode*[pred_count];
	}
    }

    phi_src_map = new PhiSrcMapEntry*[block_count + 1];
    phi_srcs_indices = new unsigned[block_count + 1];
    for (unsigned i = 0; i <= block_count; ++i)
    {
	phi_src_map[i] = NULL;
	phi_srcs_indices[i] = 0;
    }

    rebuild_2ndary_maps(get_entry_node(get_cfg()));

    delete [] phi_srcs_indices;

    if (get_keep_live_in_info() || get_keep_live_out_info())
	analyze_liveness();

    is_deflated = false;
}

/*
 * For the time being, the public methods of SsaCore must make that sure if
 * the SSA object is in deflated (file-resident) for, it gets reinflated
 * before being used.
 */
void
SsaCore::maybe_inflate()
{
    if (is_deflated)
	inflate();
}

/*
 * Helper for inflating from file.
 *
 * Recursive walk over the dominator tree, rebuilding def_table,
 * phi_src_map, edge_maps, and (optionally) def_use_chains.
 */
void
SsaCore::rebuild_2ndary_maps(CfgNode *block)
{
    const List<PhiNode*> &block_phis = get_phi_nodes(block);
    for (PhiHandle ph = block_phis.begin(); ph != block_phis.end(); ++ph)
    {
	unsigned new_name_id = lookup_new_opnd(get_dst(*ph));
	claim((new_name_id >= 0) && (new_name_id < def_count));
	def_table[new_name_id] = Operation(ph);
	if (get_build_def_use_chains())
	{
	    RecordUses record_uses(this);
	    map_opnds(*ph, record_uses);
	    record_uses.commit(ph);
	}
    }

    InstrHandle ih = instrs_start(block);
    for (int j = size(block); j > 0; --j, ++ih)
    {
	Instr *instr = *ih;

	RecordDefs record_defs(this, ih);
	if (has_note(instr, k_proc_entry))
	    map_formal_defs(get_unit(), record_defs);
	else
	    map_dst_opnds(instr,  record_defs);

	if (get_build_def_use_chains())
	{
	    RecordUses record_uses(this);
	    map_opnds(instr, record_uses);
	    record_uses.commit(ih);
	}
    }

    // A block can appear more than once in block's successor list, but
    // must only be processed once.

    static BitVector done;
    done.set_to_zero();

    CfgNodeHandle sh = succs_start(block);
    for (int k = succs_size(block); k > 0; --k, ++sh)
    {
	CfgNode *succ_block = *sh;
	unsigned succ_block_number = get_number(succ_block);
	if (done.get_bit(succ_block_number))
	    continue;
	done.set_bit(succ_block_number, true);

	unsigned phi_srcs_index = phi_srcs_indices[succ_block_number]++;
	if (!get_phi_nodes(succ_block).empty())
	{
	    PhiSrcMapEntry *new_node = new PhiSrcMapEntry;

	    new_node->index = phi_srcs_index;
	    new_node->succ_block = succ_block;
	    new_node->next = phi_src_map[get_number(block)];
	    phi_src_map[get_number(block)] = new_node;
	}
	edge_maps[succ_block_number][phi_srcs_index] = block;
    }

    for (DominanceChild *child = dominator_children[get_number(block)];
	 child != NULL;
	 child = child->next)
	rebuild_2ndary_maps(get_node(get_cfg(), child->block_number));
}

void
SsaCore::deflate()
{
    ssa->core.set_underlying_ptr(NULL);
    is_deflated = true;
}

OptUnit*
SsaCore::get_unit() const
{
    return ssa->get_unit();
}

void
SsaCore::set_unit(OptUnit *unit)
{
    ssa->set_unit(unit);
}

Cfg*
SsaCore::get_cfg() const
{
    return ssa->get_cfg();
}

void
SsaCore::set_cfg(Cfg *cfg)
{
    ssa->set_cfg(cfg);
}

bool
SsaCore::get_build_minimal_form() const
{
    return ssa->get_build_minimal_form();
}

void
SsaCore::set_build_minimal_form(bool build_minimal_form)
{
    ssa->set_build_minimal_form(build_minimal_form);
}

bool
SsaCore::get_build_semi_pruned_form() const
{
    return ssa->get_build_semi_pruned_form();
}

void
SsaCore::set_build_semi_pruned_form(bool build_semi_pruned_form)
{
    ssa->set_build_semi_pruned_form(build_semi_pruned_form);
}

bool
SsaCore::get_build_pruned_form() const
{
    return ssa->get_build_pruned_form();
}

void
SsaCore::set_build_pruned_form(bool build_pruned_form)
{
    ssa->set_build_pruned_form(build_pruned_form);
}

bool
SsaCore::get_build_def_use_chains() const
{
    return ssa->get_build_def_use_chains();
}

void
SsaCore::set_build_def_use_chains(bool build_def_use_chains)
{
    ssa->set_build_def_use_chains(build_def_use_chains);
}

bool
SsaCore::get_fold_copies() const
{
    return ssa->get_fold_copies();
}

void
SsaCore::set_fold_copies(bool fold_copies)
{
    ssa->set_fold_copies(fold_copies);
}

bool
SsaCore::get_omit_useless_phi_nodes() const
{
    return ssa->get_omit_useless_phi_nodes();
}

void
SsaCore::set_omit_useless_phi_nodes(bool omit_useless_phi_nodes)
{
    ssa->set_omit_useless_phi_nodes(omit_useless_phi_nodes);
}

bool
SsaCore::get_report_undefined_locs() const
{
    return ssa->get_report_undefined_locs();
}

void
SsaCore::set_report_undefined_locs(bool report_undefined_locs)
{
    ssa->set_report_undefined_locs(report_undefined_locs);
}

bool
SsaCore::get_keep_live_in_info() const
{
    return ssa->get_keep_live_in_info();
}

void
SsaCore::set_keep_live_in_info(bool keep_live_in_info)
{
    ssa->set_keep_live_in_info(keep_live_in_info);
}

bool
SsaCore::get_keep_live_out_info() const
{
    return ssa->get_keep_live_out_info();
}

void
SsaCore::set_keep_live_out_info(bool keep_live_out_info)
{
    ssa->set_keep_live_out_info(keep_live_out_info);
}

Opnd
SsaCore::get_old_name(int old_id) const
{
    return ssa->get_old_name(old_id);
}

Opnd
SsaCore::get_new_name(int new_id) const
{
    return ssa->get_new_name(new_id);
}

int
SsaCore::get_old_id(int new_id) const
{
    return ssa->get_new_to_old(new_id);
}

void
SsaCore::set_old_id(int new_id, int old_id)
{
    ssa->replace_new_to_old(new_id, old_id);
}

int
SsaCore::get_formal_value_id(int pos) const
{
    return ssa->get_formal_value_id(pos);
}

void
SsaCore::set_formal_value_id(int pos, int value_id)
{
    ssa->replace_formal_value_id(pos, value_id);
}

void
SsaCore::resize_old_names(int size)
{
    ssa->old_names().clear();
    while (size-- > 0)
	ssa->append_old_name(NULL);
}

void
SsaCore::resize_new_names(int size)
{
    ssa->new_names().clear();
    while (size-- > 0)
	ssa->append_new_name(NULL);
}

void
SsaCore::resize_old_ids(int size)
{
    ssa->new_to_old().clear();
    while (size-- > 0)
	ssa->append_new_to_old(-1);
}

void
SsaCore::resize_formal_value_ids(int size)
{
    ssa->formal_value_ids().clear();
    while (size-- > 0)
	ssa->append_formal_value_id(-1);
}
