/* file "alpha/opcodes.h" */

/*
    Copyright (c) 2000 The President and Fellows of Harvard College

    All rights reserved.

    This software is provided under the terms described in
    the "machine/copyright.h" include file.
*/

#ifndef ALPHA_OPCODES_H
#define ALPHA_OPCODES_H

#include <machine/copyright.h>

#ifdef USE_PRAGMA_INTERFACE
#pragma interface "alpha/opcodes.h"
#endif

/*
 * Define identifiers for the complete set of Alpha assembly opcodes,
 * pseudo-ops, opcode extensions, and code-generator/scheduler pseudo-ops.  
 *
 * To add new opcodes, add a new enum whose identifier values begin beyond
 * the end of the current enum (specified by LAST_ALPHA_OPCODE), then
 * redefine LAST_ALPHA_OPCODE.  Also, enroll new data into the opcode-
 * indexed data tables.
 */
namespace alpha {

enum {
    // opcode_null = 0,		defined in machine/opcodes.h
    // opcode_label,		defined in machine/opcodes.h

    // Pseudo-opcode (InstrDot) instructions
    AENT = 2,	       // alternative entry point
    ALIAS,	       // two regs alias (at least alittle)
    ALIGN,	       // align location counter
    ASCII,	       // assemble strings into succ. locs
    ASCIIZ,	       // assemble strings and add null
    BGNB,	       // begin language block
    BYTE,	       // assemble exprs into succ. bytes
    COMM,	       // global common symbol
    DATA,	       // subsequent data to data section
    D_FLOATING,	       // init 64-bit VAX D_floating nums
    DOUBLE,	       // initializes 64-bit FP numbers
    EDATA,	       // exception handling data
    EFLAG,	       // exception related flags
    END,	       // end of procedure
    ENDB,	       // end of language block
    ENDR,	       // end of repeat
    ENT,	       // beginning of procedure
    ERR,	       // error in front end
    EXTENDED,	       // synonym for .x_floating
    EXTERN,	       // global undefined symbol
    F_FLOATING,	       // init 32-bit VAX F_floating nums
    FILE,	       // source file name
    FLOAT,	       // synonym for .s_floating
    FMASK,	       // FP registers saved
    FNOP,	       // FP nop
    FRAME,	       // describes the stack frame
    G_FLOATING,	       // init 64-bit VAX G_floating nums
    GJSRLIVE,	       // set live-reg masks before call
    GJSRSAVED,	       // set saved-reg masks before call
    GLOBL,	       // makes a name external
    GPREL32,	       // truncates signed disp to 32-bits
    GRETLIVE,	       // set live-reg masks before return
    DOTLAB,	       // associates label with current loc
    LCOMM,	       // makes name's data type bss
    LIVEREG,	       // regs live before jump
    LOC,	       // specifies source and line number
    LONG,	       // truncates values to 32 bits
    MASK,	       // GP registers saved
    NOALIAS,	       // two registers do not alias
    NOP,	       // nop
    OPTION,	       // options in effect during compile
    PROLOGUE,	       // end of proc prologue
    QUAD,	       // trancates values to 64 bits
    RDATA,	       // subsequent data to rdata section
    REPEAT,	       // begin repeat directive
    SAVE_RA,	       // reg containing return address
    SDATA,	       // subsequent data to sdata section
    SET,	       // set assembler options
    S_FLOATING,	       // init 32-bit IEEE FP numbers
    SPACE,	       // fill with 0's
    STRUCT,	       // layout a structure using labels
    TEXT,	       // subsequent code to text section
    T_FLOATING,	       // initializes 64-bit IEEE FP numbers
    UGEN,	       // source generated by code generator
    UNOP,	       // universal nop
    VERSTAMP,	       // major and minor version numbers
    VREG,	       // register variable description
    WEAKEXT,	       // weak symbol during linking
    WORD,	       // truncates values to 16 bits
    X_FLOATING,	       // init 128-bit IEEE FP numbers
    
    // Load immediate (InstrAlm) instructions
    LDIL,	       // load immediate longword
    LDIQ,	       // load immediate quadword

    // Load (InstrAlm) instructions
    LDA,	       // load address
    LDAH,	       // load adr high, b+o only
    LDGP,	       // load global ptr, b+o only
    LDB,	       // load byte
    LDBU,	       // load byte unsigned
    LDW,	       // load word signed
    LDWU,	       // load word unsigned
    LDL,	       // load sign-ext longword (32b)
    // LDLU does not exist in Alpha because it is not needed
    LDL_L,	       // load sign-ext longword locked
    LDQ,	       // load quadword (64 bits)
    LDQ_L,	       // load quadword locked
    LDQ_U,	       // load quadword unaligned
    ULDW,	       // unaligned load word
    ULDWU,	       // unaligned load word unsigned
    ULDL,	       // unaligned load longword
    ULDQ,	       // unaligned load quadword

    // Store (InstrAlm) instructions
    STB,	       // store byte
    STW,	       // store word (16 bits)
    STL,	       // store longword (32 bits)
    STL_C,	       // store longword cond'l
    STQ,	       // store quadword (64 bits)
    STQ_C,	       // store quadword cond'l
    STQ_U,	       // store quadword unaligned
    USTW,	       // unaligned store word
    USTL,	       // unaligned store longword
    USTQ,	       // unaligned store quadword

    // General computational (InstrAlm) instructions
    ABSL,	       // absolute value
    ABSQ,	       // absolute value
    ADDL,	       // add longword (no overflow)
    ADDLV,	       // add longword (overflow)
    ADDQ,	       // add quadword (no overflow)
    ADDQV,	       // add quadword (overflow)
    AND,	       // and
    ANDNOT,	       // logical product with complement
    BIC,	       // logical product with complement
    BIS,	       // logical sum (or)
    CLR,	       // clear
    CMOVEQ,	       // move if equal to zero
    CMOVNE,	       // move if not equal to zero
    CMOVLT,	       // move if < zero
    CMOVLE,	       // move if <= zero
    CMOVGT,	       // move if > zero
    CMOVGE,	       // move if >= zero
    CMOVLBC,	       // move if low bit clear
    CMOVLBS,	       // move if low bit set
    CMPEQ,	       // compare signed quadword equal
    CMPLT,	       // compare signed quadword <
    CMPLE,	       // compare signed quadword <=
    CMPULT,	       // compare unsigned quadword <
    CMPULE,	       // compare unsigned quadword <=
    DIVL,	       // divide longword
    DIVLU,	       // divide longword unsigned
    DIVQ,	       // divide quadword
    DIVQU,	       // divide quadword unsigned
    EQV,	       // logical equivalence (xornot)
    MOV,	       // move
    MULL,	       // multiply longword (overflow)
    MULLV,	       // multiply longword (overflow)
    MULQ,	       // multiply quadword (no overflow)
    MULQV,	       // multiply quadword (overflow)
    NEGL,	       // negate longword (no overflow)
    NEGLV,	       // negate longword (overflow)
    NEGQ,	       // negate quadword (no overflow)
    NEGQV,	       // negate quadword (overflow)
    NOT,	       // not
    OR,		       // or
    ORNOT,	       // logical sum with complement
    REML,	       // longword remainder
    REMLU,	       // longword remainder unsigned
    REMQ,	       // quadword remainder
    REMQU,	       // quadword remainder unsigned
    S4ADDL,	       // scaled longword add by 4
    S4ADDQ,	       // scaled quadword add by 4
    S8ADDL,	       // scaled longword add by 8
    S8ADDQ,	       // scaled quadword add by 8
    S4SUBL,	       // scaled longword subtract by 4
    S4SUBQ,	       // scaled quadword subtract by 4
    S8SUBL,	       // scaled longword subtract by 8
    S8SUBQ,	       // scaled quadword subtract by 8
    SETXL,	       // sign-extend longword
    SLL,	       // shift left logical
    SRA,	       // shift right arithmetic
    SRL,	       // shift right logical
    SUBL,	       // subtract longword (no overflow)
    SUBLV,	       // subtract longword (overflow)
    SUBQ,	       // subtract quadword (no overflow)
    SUBQV,	       // subtract quadword (overflow)
    UMULH,	       // unsigned quadword multiply high
    XOR,	       // exclusive or (logical difference)
    XORNOT,	       // logical equivalence (xornot)

    // Byte-manipulation (InstrAlm) instructions
    CMPBGE,	       // compare byte
    EXTBL,	       // extract byte low
    EXTWL,	       // extract word low
    EXTLL,	       // extract longword low
    EXTQL,	       // extract quadword low
    EXTWH,	       // extract word high
    EXTLH,	       // extract longword high
    EXTQH,	       // extract quadword high
    INSBL,	       // insert byte low
    INSWL,	       // insert word low
    INSLL,	       // insert longword low
    INSQL,	       // insert quadword low
    INSWH,	       // insert word high
    INSLH,	       // insert longword high
    INSQH,	       // insert quadword high
    MSKBL,	       // mask byte low
    MSKWL,	       // mask word low
    MSKLL,	       // mask longword low
    MSKQL,	       // mask quadword low
    MSKWH,	       // mask word high
    MSKLH,	       // mask longword high
    MSKQH,	       // mask quadword high
    ZAP,	       // zero bytes
    ZAPNOT,	       // zero bytes not

    // Branch (InstrCti) instructions
    BR,		       // branch
    BEQ,	       // branch on equal
    BEQ_N,	       // br on equal [predict not taken]
    BEQ_T,	       // branch on equal [predict taken]
    BGE,	       // branch >=
    BGE_N,	       // branch >= [predict not taken]
    BGE_T,	       // branch >= [predict taken]
    BGT,	       // branch >
    BGT_N,	       // branch > [predict not taken]
    BGT_T,	       // branch > [predict taken]
    BLBC,	       // branch if low bit is clear
    BLBC_N,	       // br if low bit clear [predicted]
    BLBC_T,	       // br if low bit clear [predicted]
    BLBS,	       // branch if low bit is set
    BLBS_N,	       // branch if low bit set [predicted]
    BLBS_T,	       // branch if low bit set [predicted]
    BLE,	       // branch <=
    BLE_N,	       // branch <= [predicted]
    BLE_T,	       // branch <= [predicted]
    BLT,	       // branch <
    BLT_N,	       // branch < [predicted]
    BLT_T,	       // branch < [predicted]
    BNE,	       // branch !=
    BNE_N,	       // branch != [predicted]
    BNE_T,	       // branch != [predicted]
    BSR,	       // branch to subroutine

    // Jump (InstrCti) instructions
    JMP,	       // jump
    JSR,	       // jump to subroutine
    JSR_COROUTINE,     // jump to subroutine return
    RET,	       // return from subroutine

    // Special (InstrAlm or InstrCti) instructions
    CALL_PAL,	       // call privileged arch library
    FETCH,	       // prefetch data
    FETCH_M,	       // prefetch data, modify intent
    RPCC,	       // read process cycle counter
    TRAPB,	       // trap barrier
    EXCB,	       // exception barrier
    MB,		       // memory barrier
    WMB,	       // write memory barrier

    // Floating point load (InstrAlm) instructions
    LDF,	       // load F_floating
    LDG,	       // load G_floating (D_floating)
    LDS,	       // load S_floating
    LDT,	       // load T_floating

    // Floating point load immediate (InstrAlm) instructions
    LDIF,	       // load immediate F_floating
    LDID,	       // load immediate D_floating
    LDIG,	       // load immediate G_floating
    LDIS,	       // load immediate S_floating
    LDIT,	       // load immediate T_floating

    // Floating point store (InstrAlm) instructions
    STF,	       // store F_floating
    STG,	       // store G_floating (D_floating)
    STS,	       // store S_floating
    STT,	       // store T_floating

    // Floating point computational (InstrAlm) instructions
    ADDF,	       // FP add F_floating
    ADDG,	       // FP add G_floating
    ADDS,	       // FP add S_floating
    ADDT,	       // FP add T_floating
    FCMOVEQ,	       // FP move if equal to zero
    FCMOVNE,	       // FP move if not equal to zero
    FCMOVLT,	       // FP move if < zero
    FCMOVLE,	       // FP move if <= zero
    FCMOVGT,	       // FP move if > zero
    FCMOVGE,	       // FP move if >= zero
    CPYS,	       // FP copy sign
    CPYSN,	       // FP copy sign negate
    CPYSE,	       // FP copy sign and exponent
    CVTQL,	       // FP convert quadword to longword
    CVTLQ,	       // FP convert longword to quadword
    CVTGQ,	       // FP convert G_floating to quadword
    CVTTQ,	       // FP convert T_floating to quadword
    CVTQF,	       // FP convert quadword to F_floating
    CVTQG,	       // FP convert quadword to G_floating
    CVTQS,	       // FP convert quadword to S_floating
    CVTQT,	       // FP convert quadword to T_floating
    CVTDG,	       // FP convert D_ to G_floating
    CVTGD,	       // FP convert G_ to D_floating
    CVTGF,	       // FP convert G_ to F_floating
    CVTTS,	       // FP convert T_ to S_floating
    CVTST,	       // FP convert S_ to T_floating
    DIVF,	       // FP divide F_floating
    DIVG,	       // FP divide G_floating
    DIVS,	       // FP divide S_floating
    DIVT,	       // FP divide T_floating
    FABS,	       // FP absolute value
    FCLR,	       // FP clear
    FMOV,	       // FP move
    MULF,	       // FP multiply F_floating
    MULG,	       // FP multiply G_floating
    MULS,	       // FP multiply S_floating
    MULT,	       // FP multiply T_floating
    FNEG,	       // FP negate
    NEGF,	       // FP negate F_floating
    NEGG,	       // FP negate G_floating
    NEGS,	       // FP negate S_floating
    NEGT,	       // FP negate T_floating
    SUBF,	       // FP subtract F_floating
    SUBG,	       // FP subtract G_floating
    SUBS,	       // FP subtract S_floating
    SUBT,	       // FP subtract T_floating

    // Floating point relational (InstrAlm) instructions
    CMPGEQ,	       // FP compare G_floating equal
    CMPGLT,	       // FP compare G_floating <
    CMPGLE,	       // FP compare G_floating <=
    CMPTEQ,	       // FP compare T_floating equal
    CMPTLT,	       // FP compare T_floating <
    CMPTLE,	       // FP compare T_floating <=
    CMPTUN,	       // FP compare T_floating unordered

    // Floating point control (InstrCti) instructions
    FBEQ,	       // FP branch equal to zero
    FBNE,	       // FP branch not equal to zero
    FBLT,	       // FP branch < zero
    FBLE,	       // FP branch <= zero
    FBGT,	       // FP branch > zero
    FBGE,	       // FP branch >= zero

    // Special floating point (InstrAlm) instructions
    MF_FPCR,	       // move from FP control register
    MT_FPCR	       // move to FP control register
};

} // namespace alpha

#define LAST_ALPHA_OPCODE alpha::MT_FPCR

extern Vector<char*> alpha_opcode_names;

// following used only in alpha/init.cc
void init_alpha_opcode_names();

char *opcode_name_alpha(int opcode);


// Defined opcode extenders.

namespace alpha {
enum {
    // VAX/IEEE rounding mode qualifiers
    ROUND_NORMAL,		// normal rounding mode controlled by FPCR
    ROUND_CHOPPED,		// chopped, i.e. truncate
    ROUND_P_INF,		// round toward plus infinity
    ROUND_M_INF,		// round toward minus infinity

    // VAX/IEEE trap modes
    TRAP_NONE,			// imprecise, underflow disabled, (and, for
				// IEEE, inexact disabled)
    TRAP_U,			// imprecise, underflow enabled, (and, for
				// IEEE, inexact disabled)
    TRAP_S,			// software and underflow disabled (not valid
				// option for IEEE FP)
    TRAP_SU,			// software, underflow enabled, (and, for
				// IEEE, inexact disabled)
    TRAP_SUI,			// software, underflow enabled, and inexact
				// enabled (not valid option for VAX)

    // VAX/IEEE convert-to-integer trap modes
    ITRAP_NONE,			// imprecise, int overflow disabled, (and,
				// for IEEE, inexact disabled)
    ITRAP_V,			// imprecise, int overflow enabled, (and,
				// for IEEE, inexact disabled)
    ITRAP_S,			// software, int overflow disabled, (not
				// valid option for IEEE)
    ITRAP_SV,			// software, int overflow enabled, (and,
				// for IEEE, inexact disabled)
    ITRAP_SVI			// software, int overflow ensabled, and inexact
				// enabled (not valid option for VAX)
};

} // namespace alpha

#define LAST_ALPHA_OPCODE_EXT alpha::ITRAP_SVI

extern Vector<char*> alpha_opcode_ext_names;

// following used only in alpha/init.cc
void init_alpha_opcode_ext_names();


extern Vector<int> alpha_invert_table;

// following used only in alpha/init.cc
void init_alpha_invert_table();


bool target_implements_alpha(int opcode);

int opcode_line_alpha();
int opcode_ubr_alpha();
int opcode_move_alpha(TypeId);
int opcode_load_alpha(TypeId);
int opcode_store_alpha(TypeId);

int opcode_cbr_inverse_alpha(int opcode);

#endif /* ALPHA_OPCODES_H */
