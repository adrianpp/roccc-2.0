<!-- this file was generated automatically by noweave; better not edit it-->
<html><head><title>The Machine-SUIF Machine Library</title></head><body>
<p>
<!-- Give the l2h (LaTeX to HTML) filter some hints-->





<!-- Adjust dimensions before setting \pagestyle: it looks at-->
<!-- some of them-->










<p>
<!-- Replace some noweb.sty definitions to improve page breaks-->


           <!-- Omit \clearpage for new source file-->
<p>
<!-- Was =\@highpenalty (>9999 disallows-->
<!-- ... _any_ break in code)-->
<!-- Use \nwcodepenalty ...--><!-- ... instead of \@highpenalty-->
    <!-- Use \goodbreak ...-->
               <!-- ... instead of \filbreak-->
<p>

<h1><a name=toc1>The Machine-SUIF Machine Library</a></h1>
<address><em>Release version 2.02.07.15</em> <br><br>Glenn Holloway and Michael D. Smith <br>{holloway,smith}@eecs.harvard.edu <br>Division of Engineering and Applied Sciences <br>Harvard University</address>
<p>

<p>

<!--title goes here-->

<p>
<h2><a name=toc2>Abstract</a></h2><blockquote>
The Machine SUIF system is an extension of Stanford SUIF version 2 that
supports construction of compiler back ends.  The <code>machine</code> library is
the core of Machine SUIF.  It enables you to create machine
descriptions, to construct and manipulate machine-level intermediate
forms during back-end optimization, and to emit object code.
<p>
While the library itself is machine independent, it is the basis for
producing other libraries that are machine specific.  These
machine-specific libraries supply the parameters that make
machine-independent optimization passes sensitive to the peculiarities
of target machines.
<p>
The optimization programming interface (OPI) used for creating Machine-SUIF
passes and libraries is described elsewhere <b>[cite&nbsp;<a href="#NWcite-bibext">bibext</a>, <a href="#NWcite-bibopiusr">bibopiusr</a>]</b>.
This document fills in details of the OPI as implemented in Machine SUIF.
It also discusses aspects of the implementation that will help you use and
extend the system.
<p>
</blockquote>

<hr><p>
<tableofcontents>
<ul compact>
<li><a href="#toc2">Abstract</a></li>
<li><a href="#toc3">Introduction</a></li>
<li><a href="#toc4">Overview</a></li>
  <ul compact>
  <li><a href="#toc5">Connection to SUIF</a></li>
  <li><a href="#toc6">Intermediate Representation</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc7">Optimization units.</a></li>
      <li><a href="#toc8">Instruction lists.</a></li>
      <li><a href="#toc9">Instructions.</a></li>
      <li><a href="#toc10">Operands.</a></li>
      <li><a href="#toc11">Annotations.</a></li>
      </ul>
    </ul>
  <li><a href="#toc12">Description of Target Machines</a></li>
  <li><a href="#toc13">Frameworks for Key Back-End Passes</a></li>
  <li><a href="#toc14">Bases for Extension</a></li>
  </ul>
<li><a href="#toc15">Machine Instructions</a></li>
  <ul compact>
  <li><a href="#toc16">Instruction constituents</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc17">Opcodes.</a></li>
      <li><a href="#toc18">Operands.</a></li>
      <li><a href="#toc19">Other constituents.</a></li>
      </ul>
    </ul>
  <li><a href="#toc20">Creators for Instr</a></li>
  <li><a href="#toc21">Predicates for Instr</a></li>
  <li><a href="#toc22">Accessors and mutators for Instr</a></li>
  <li><a href="#toc23">Print Function for Instr</a></li>
  <li><a href="#toc24">Machine-instruction lists</a></li>
  <li><a href="#toc25">Header file instr.h</a></li>
  </ul>
<li><a href="#toc26">Machine Operands</a></li>
  <ul compact>
  <li><a href="#toc27">Opnd interface</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc28">Common functions on operands.</a></li>
      <li><a href="#toc29">Null operands.</a></li>
      <li><a href="#toc30">Variable-symbol operands.</a></li>
      <li><a href="#toc31">Register operands.</a></li>
      <li><a href="#toc32">Immediate operands.</a></li>
      <li><a href="#toc33">Address operands.</a></li>
      <li><a href="#toc34">Address symbols.</a></li>
      <li><a href="#toc35">Address expressions.</a></li>
      <li><a href="#toc36">Programming with address expressions.</a></li>
      <li><a href="#toc37">Specific address-expression kinds.</a></li>
      <li><a href="#toc38">The address-symbol+ displacementkind.</a></li>
      <li><a href="#toc39">The index-register+ address-symbol+ displacementkind.</a></li>
      <li><a href="#toc40">The base+ displacementkind.</a></li>
      <li><a href="#toc41">The base+ indexkind.</a></li>
      <li><a href="#toc42">The base+ index+ displacementkind.</a></li>
      <li><a href="#toc43">The index&times;scale+ displacementkind.</a></li>
      <li><a href="#toc44">The base+ index&times;scale+ displacementkind.</a></li>
      </ul>
    </ul>
  <li><a href="#toc45">Class OpndCatalog</a></li>
  <li><a href="#toc46">Opnd implementation</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc47">Current optimization unit.</a></li>
      <li><a href="#toc48">Partial implementation of OpndCatalog.</a></li>
      <li><a href="#toc49">Assess storage consumption by operand objects.</a></li>
      </ul>
    </ul>
  <li><a href="#toc50">Header file opnd.h</a></li>
  </ul>
<li><a href="#toc51">Types</a></li>
  <ul compact>
    <ul compact>
      <ul compact>
      <li><a href="#toc52">Target-independent type objects.</a></li>
      <li><a href="#toc53">Target-dependent type object.</a></li>
      </ul>
    </ul>
  <li><a href="#toc54">Header file for module types.h</a></li>
  </ul>
<li><a href="#toc55">Machine opcodes</a></li>
  <ul compact>
  <li><a href="#toc56">Header file for module opcodes.h</a></li>
  </ul>
<li><a href="#toc57">Register Descriptions</a></li>
  <ul compact>
  <li><a href="#toc58">Enumerating hardware registers</a></li>
  <li><a href="#toc59">Enumerating register classes</a></li>
  <li><a href="#toc60">Supporting register allocation</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc61">Classification.</a></li>
      <li><a href="#toc62">Selection.</a></li>
      <li><a href="#toc63">Spilling.</a></li>
      </ul>
    </ul>
  <li><a href="#toc64">Upgrading from the earlier register-description interface</a></li>
  <li><a href="#toc65">Header file for module reg_info.h</a></li>
  </ul>
<li><a href="#toc66">Assembly-Language Printing</a></li>
  <ul compact>
  <li><a href="#toc67">Class Printer</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc68">Interface.</a></li>
      <li><a href="#toc69">Specialization.</a></li>
      <li><a href="#toc70">The Printer object for the current target.</a></li>
      </ul>
    </ul>
  <li><a href="#toc71">Header file for module Printer.h</a></li>
  </ul>
<li><a href="#toc72">C-Language Printing</a></li>
  <ul compact>
  <li><a href="#toc73">Class CPrinter</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc74">Interface.</a></li>
      <li><a href="#toc75">Specialization.</a></li>
      <li><a href="#toc76">The CPrinter object for the current target.</a></li>
      </ul>
    </ul>
  <li><a href="#toc77">Header file for module CPrinter.h</a></li>
  </ul>
<li><a href="#toc78">Machine code finalization</a></li>
  <ul compact>
  <li><a href="#toc79">Class CodeFin</a></li>
    <ul compact>
    <li><a href="#toc80">OPI for code finalization</a></li>
    <li><a href="#toc81">Generating a target-specific CodeFin object</a></li>
    <li><a href="#toc82">Class StackFrameInfoNote</a></li>
    <li><a href="#toc83">Specializing CodeFin for a target</a></li>
    </ul>
  <li><a href="#toc84">Header file for module code_fin.h</a></li>
  </ul>
<li><a href="#toc85">Sets of Natural Numbers</a></li>
  <ul compact>
  <li><a href="#toc86">Class NatSet</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc87">Extender's view of NatSet.</a></li>
      </ul>
    </ul>
  <li><a href="#toc88">Class NatSetDense</a></li>
  <li><a href="#toc89">Class NatSetSparse.</a></li>
  <li><a href="#toc90">Class NatSetCopy.</a></li>
  <li><a href="#toc91">Header file nat_set.h</a></li>
  </ul>
<li><a href="#toc92">Annotations</a></li>
  <ul compact>
    <ul compact>
      <ul compact>
      <li><a href="#toc93">Type NoteKey.</a></li>
      </ul>
    </ul>
  <li><a href="#toc94">Class Note</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc95">Public methods.</a></li>
      <li><a href="#toc96">Friends of Note.</a></li>
      <li><a href="#toc97">Protected methods.</a></li>
      <li><a href="#toc98">Atomic notes.</a></li>
      <li><a href="#toc99">Tuple notes.</a></li>
      <li><a href="#toc100">Attaching, detaching, and testing for notes.</a></li>
      </ul>
    </ul>
  <li><a href="#toc101">Specialized Note Classes</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc102">Single-valued notes.</a></li>
      <li><a href="#toc103">List-carrying notes.</a></li>
      <li><a href="#toc104">Custom notes for source-code location.</a></li>
      <li><a href="#toc105">Custom note for multiway branches.</a></li>
      <li><a href="#toc106">Custom note for attaching a natural-number set.</a></li>
      </ul>
    </ul>
  <li><a href="#toc107">header file opnd.h</a></li>
  </ul>
<li><a href="#toc108">Problems</a></li>
  <ul compact>
  <li><a href="#toc109">Progress diagnostics and warning messages</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc110">Function debug.</a></li>
      <li><a href="#toc111">Function warn.</a></li>
      <li><a href="#toc112">Macros if_debug.</a></li>
      </ul>
    </ul>
  <li><a href="#toc113">Assertions</a></li>
  <li><a href="#toc114">Header file problems.h</a></li>
  </ul>
<li><a href="#toc115">Utilities</a></li>
  <ul compact>
  <li><a href="#toc116">Operand scanning and replacement</a></li>
  <li><a href="#toc117">Annotation help</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc118">Formal parameters assigned to registers.</a></li>
      </ul>
    <li><a href="#toc119">Annotation transfer</a></li>
    <li><a href="#toc120">Annotation suppression during printing</a></li>
    </ul>
  <li><a href="#toc121">Symbol, symbol-table, and type utilities</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc122">Symbol predicates.</a></li>
      <li><a href="#toc123">Symbol finders.</a></li>
      <li><a href="#toc124">Symbol creators.</a></li>
      <li><a href="#toc125">Accessing and changing symbol properties.</a></li>
      <li><a href="#toc126">Formal parameter helpers.</a></li>
      <li><a href="#toc127">Symbol-table accessors.</a></li>
      <li><a href="#toc128">Symbol-table predicates.</a></li>
      <li><a href="#toc129">Taxonomy of types.</a></li>
      <li><a href="#toc130">Predicates on TypeId's.</a></li>
      <li><a href="#toc131">Properties of typed values.</a></li>
      <li><a href="#toc132">Creating a C procedure type.</a></li>
      </ul>
    </ul>
  <li><a href="#toc133">Cloning</a></li>
  <li><a href="#toc134">A string utility</a></li>
  <li><a href="#toc135">A hashing utility</a></li>
  <li><a href="#toc136">Printing utilities</a></li>
  <li><a href="#toc137">Sequence utilities</a></li>
  <li><a href="#toc138">Miscellany</a></li>
  <li><a href="#toc139">Header file util.h</a></li>
  </ul>
<li><a href="#toc140">Contexts</a></li>
  <ul compact>
  <li><a href="#toc141">Establishing context</a></li>
  <li><a href="#toc142">Class Context</a></li>
  <li><a href="#toc143">Class MachineContext</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc144">Target-characterization methods.</a></li>
      <li><a href="#toc145">Protected fields.</a></li>
      </ul>
    </ul>
  <li><a href="#toc146">Header file contexts.h</a></li>
  </ul>
<li><a href="#toc147">Substrate Encapsulation</a></li>
  <ul compact>
  <li><a href="#toc148">OPI Types</a></li>
  <li><a href="#toc149">Class Integer</a></li>
  <li><a href="#toc150">Class IdString</a></li>
  <li><a href="#toc151">Living with C++ Container Classes</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc152">SUIF's STL substitutes.</a></li>
      <li><a href="#toc153">Iterator arithmetic.</a></li>
      </ul>
    </ul>
  <li><a href="#toc154">C++ and Base SUIF Header Files</a></li>
  <li><a href="#toc155">Accessing SUIF Value Descriptors</a></li>
  <li><a href="#toc156">Miscellany</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc157">Current compilation environment.</a></li>
      <li><a href="#toc158">Extracting the name of a named object.</a></li>
      <li><a href="#toc159">SUIF object-class identification.</a></li>
      <li><a href="#toc160">An IR-class forward reference.</a></li>
      <li><a href="#toc161">Command-line option helpers.</a></li>
      </ul>
    </ul>
  <li><a href="#toc162">Header file substrate.h</a></li>
  </ul>
<li><a href="#toc163">Library initialization</a></li>
<li><a href="#toc164">Header file for the machine library</a></li>
<li><a href="#toc165">Connection to the Base SUIF Pass Mechanism</a></li>
<li><a href="#toc166">Hoof Specification of Machine-SUIF IR Classes</a></li>
  <ul compact>
  <li><a href="#toc167">Class Instr</a></li>
  <li><a href="#toc168">Class IrOpnd</a></li>
  <li><a href="#toc169">Class AnyBody</a></li>
  <li><a href="#toc170">Class InstrList</a></li>
  <li><a href="#toc171">Overall hoof specification for module machine</a></li>
  </ul>
<li><a href="#toc172">Copyright</a></li>
<li><a href="#toc173">Acknowledgments</a></li>
<li><a href="#toc174">References</a></li>
</ul>
</tableofcontents>
<p>
<!-- Start a new chunk to cause noweb to put source filename in heading-->



<hr>
<h2><a name=toc3>Introduction</a></h2>
<p>
The Machine SUIF system is an extension of Stanford SUIF version 2 that
supports construction of compiler back ends.  This document is part of a
set of documents explaining how to use and how to extend Machine SUIF.  It
is aimed at three kinds of readers:
<ul>
<li>Those interested in writing machine-level optimizations
based on existing target machine descriptions.
<li>Those also interested in adding new target machine descriptions (or
extending existing ones).
<li>Those interested in understanding enough about Machine SUIF's
implementation to enable them to modify it.
</ul>
<p>
We assume that you have read <em>An Introduction to Machine SUIF
and Its Portable Libraries for Analysis and Optimization</em> and <em>A User's
Guide to the Optimization Programming Interface</em>.  As explained in
those documents, Machine SUIF implements an interface for optimization
writers, the OPI, that can be used not only for static compilation, an in
Machine SUIF, but also in other settings, such as run-time code
optimization.  Since the OPI has a wider scope than Machine SUIF, it has
been documented separately.
<p>
This document begins the description of how the OPI is implemented as an
extension of SUIF version 2.
 <b>[</b>You will need to be familiar with the basic concepts of SUIF 2,
also referred to here as base SUIF.  See the
<a href="http://suif.stanford.edu/suif/suif2/">SUIF 2 home page</a>
for information on that system.<b>]</b> 
It also describes the mechanisms that allow extension of the system in
several directions.  The OPI itself can be extended by the addition of new
intermediate representations.  New target-architecture families can be
added to the system, and existing ones can be augmented, either to reflect
new implementations by vendors or to accommodate architectural experiments.
<p>
The core of the Machine SUIF implementation is the <code>machine</code> library,
which is the subject of this document.  It implements the most basic IR
classes in the OPI and it also establishes extension machinery.  Other
Machine-SUIF libraries, such as the control-flow graph (<code>cfg</code>) library,
continue the OPI implementation and they illustrate how Machine SUIF allows
the OPI to be extended by users.  The documents describing those libraries
should be helpful both to users and extenders of the system.
<p>
The <code>machine</code> library, the <code>cfg</code> library, and others that develop the
OPI implementation are machine-independent: they are designed to apply to
all kinds of target machines.  A different series of libraries supply the
machine descriptions necessary to carry out machine-level optimization.  We
say that the OPI is <em>parameterized</em> over the features of target
machines.  The machine-specific libraries supply the parameter bindings.
<p>

<h2><a name=toc4>Overview</a></h2>
<a name="sec:overview"><b>[*]</b></a>
<p>
The main sections of this document correspond to implementation modules.
The interfaces they display are exactly the source code that is extracted
and used to build the system.
<p>
As hinted above, the <code>machine</code> library plays several diferent roles.
<p>
<ul>
<li>It builds the layer between Machine SUIF and the underlying SUIF
substrate, recasting many SUIF facilities into the form used by the
OPI.
<li>It implements the data structures for instruction-lists,
instructions, operands, and annotations, including the functions
that create, inspect, and manipulate these key pieces if the IR.
<li>It defines data structures for describing target-machine
characteristics, such as register files.
<li>It provides the machine-independent frameworks for several kinds of
machine-specific passes, such as those for finalizing optimized code
and emitting it as object code in text or binary form.
<li>It provides the basis for extending Machine SUIF in several
directions: extension of the OPI itself, addition of new target
machines and/or new features for existing targets, and the addition
of new kinds of machine description.
</ul>
<p>
We touch on each of these roles in the following subsections.
<p>

<h3><a name=toc5>Connection to SUIF</a></h3>
<p>
We rely on the SUIF substrate to provide:
<p>
<ul>
<li>Types, symbols, symbol tables, descriptions of the inital values of
variables and the signatures of procedures being compiled.
<li>A system for generating IR classes that provides support for cloning, for
intermediate-file I/O and symbolic printing of IR objects with and
minimum of coding on the part of the class developer.
<li>A scheme for building passes that can either be applied in series
to a whole intermediate file at a time or can be pipelined so that
a procedure being compiled undergoes several passes at at time.
</ul>
<p>
Connection to the SUIF substrate is mostly quite simple.  The OPI uses a
naming convention similar to that used in SUIF.  Its names tend to be
shorter than SUIF's, so some classes are renamed via <code>typedef</code>s.  For
example, SUIF's <code>VariableSymbol</code> becomes <code>VarSym</code>.  The OPI uses a
different style for annotating IR objects than base SUIF, so the
<code>machine</code> library encapsulates SUIF annotations as OPI <em>notes</em>.
<p>
A more pervasive style difference is that base SUIF makes little use of
global variables and expresses all functionality through class methods,
while the OPI makes use of both global variables and overloaded global
functions.  Part of the <code>machine</code> library's substrate-interface role is
simply to convert calls on class methods into calls on plain functions.
<p>
In Machine SUIF, when IR objects are created by OPI functions, they
sometimes need to be connected to other objects in ways that are not
apparent at the OPI level.  The chief example is the Machine-SUIF operand,
of type <code>Opnd</code>, which will be discussed in the next subsection.
<p>

<h3><a name=toc6>Intermediate Representation</a></h3>
<p>
The <code>machine</code> library implements the core of the OPI's IR classes: those
for instruction-lists (<code>InstrList</code>), instructions (<code>Instr</code>), operands
(<code>Opnd</code>), and annotations (<code>Note</code>).  It also implements
functions and classes that create, inspect, and manipulate IR objects.
<p>

<h5><a name=toc7>Optimization units.</a></h5>
<p>
The OPI tries not to hard-wire the decision of what program units shall be
optimized.  While it's traditional to deal with one source procedure at a
time, the OPI doesn't lock users into that model.  Nevertheless, in Machine
SUIF, the OPI data type <code>OptUnit</code> is exactly the SUIF
<code>ProcedureDefinition</code> (which we also nickname <code>ProcDef</code>).
<p>

<h5><a name=toc8>Instruction lists.</a></h5>
<p>
The Machine-SUIF class <code>InstrList</code> is used to represent a sequence of
machine instructions, including label ``instructions'' that serve as the
targets of control-transfer instructions (CTI).  Thus a single
<code>InstrList</code> object can represent all of the control behavior of a
machine-level program.
<p>
<code>InstrList</code> is implemented as a subclass of <code>AnyBody</code>, which is itself
a subclass of SUIF's <code>ExecutionObject</code>.  Since the the <code>body</code> field of
a SUIF procedure definition has type <code>ExecutionObject*</code>, an <code>InstrList</code>
can be used as the body of a SUIF procedure representation.  This is one of
the key points of connection between base SUIF and Machine SUIF.
<p>

<h5><a name=toc9>Instructions.</a></h5>
<p>
The OPI defines one instruction class, <code>Instr</code>, which it describes in
four categories, two real (executable) and two ``pseudo''.  Mirroring that
breakdown, the Machine SUIF class hierarchy defines four instruction
classes: <code>InstrAlm</code> (arithmetic, logical and memory), <code>InstrCti</code>
(control-transfer), <code>InstrLabel</code> (label-defining), and <code>InstrDot</code>
(pseudo-op).  An OPI user needs to understand the categories, but shouldn't
need to mention the implementation classes that correspond to them.
<p>
Instances of class <code>Instr</code> must correspond one-to-one with real machine
instructions, but must be manipulated by machine-independent tools.  It
seems pointless to try to reflect the myriad formats of real machine
instructions in the Machine-SUIF representation of instructions.  For a
small gain in space efficiency, we would add considerable complexity and
would make it harder to tranform instructions in place, e.g., by altering
opcodes and shifting operands.
<p>

<h5><a name=toc10>Operands.</a></h5>
<p>
The OPI defines one operand class, <code>Opnd</code>, which it breaks downs into
several categories.  One of these, the address expressions, is further
broken down into subcategories.  As with <code>Instr</code>, the implementation of
<code>Opnd</code> uses a class hierarchy that closely parallels the OPI
characterization.
<p>
But <code>Opnd</code> presents a special problem in the Machine SUIF implementation
because the OPI describes it not as a heap-allocated object handled through
pointers, but as a scalar value.  The reason is that in a run-time
optimization setting, operands can and should have a very lightweight
implementation, requiring no storage management.  It would be a mistake to
require them to be treated as pointers in that setting simply to make the
Machine-SUIF implementation a bit more uniform.
<p>
For this reason, the OPI leaves open the question of whether instances
of non-pointer IR data types such as <code>Opnd</code> behave like references
or like independent values.  An implementation is free to use
reference semantics, and in fact, Machine SUIF does so.  For
algorithms that aren't meant to be reusable in an on-line setting,
that's all you need to know.  For maximum portability of your
OPI-based programs, however, you should explicitly clone mutable operands to
prevent accidental side effects.  (See the description of <code>clone</code> in
Section&nbsp;<a href="#sec:opnd-interface">[-&gt;]</a>.)  In practice, this is seldom needed,
since the most frequently-used kinds of operands are immutable.
<p>
Under the hood, a Machine-SUIF operand is really a pointer to a SUIF
object.  Machine SUIF hides the allocation and deallocation of these
objects.  The user interface to operands is through functions and interface
classes defined by the OPI, not through the methods of the implementation
objects.
<p>

<h5><a name=toc11>Annotations.</a></h5>
<p>
The situation is similar for Machine-SUIF annotations.  Class <code>Note</code>
needs to be amenable to a variety of lightweight implementations.  Like
<code>Opnd</code>, it is used as a scalar, not an explicit pointer.  But as with
<code>Opnd</code>, Machine SUIF employs a hidden pointer to a base SUIF annotation
object, and it reflects reference sementics.  And again, a <code>clone</code>
function allows you to avoid accidental mutation.
<p>

<h3><a name=toc12>Description of Target Machines</a></h3>
<p>
The <code>machine</code> library defines the classes for machine-description data
structures that are instantiated by target-specific libraries.  A typical
example of these is the <code>RegInfo</code> class (Section&nbsp;<a href="#sec-reg-desc">[-&gt;]</a>).  A
<code>RegInfo</code> object describes the register architecture of a family of
target machines, including the number and kinds of register files, the
widths of their registers and the number in each bank, and so on.  Machine
descriptions of this kind are an important part of the binding that a
machine-specific library establishes when it is loaded.
Machine-independent optimization code queries these machine descriptions in
order to cater to machine characteristics without hard-wiring in.
<p>

<h3><a name=toc13>Frameworks for Key Back-End Passes</a></h3>
<p>
Most back ends constructed in Machine-SUIF start with passes for lowering
and code generation and end with a finalization pass and a pass for
emitting object code.  Lowering is machine-independent; it translates from
the base SUIF intermediate form to Machine SUIF, using the SUIFvm idealized
machine as the target.  The other three kinds of passes need to be
specialized for the target machine, but for each kind, the pattern is much
the same from target to target.  The <code>machine</code> library provides base
classes that are used as frameworks for such passes.  For a specific
target, the corresponding library derives from these base classes and fills
in the target-specific particulars.
<p>
For example, a typical finalization pass does such things as allocating the
stack frame for each compiled procedure, it replaces symbolic stack
references by effective-address expressions with specific frame offsets, it
generates register-saving and restoring prologue and epilogue code, and so
on.  The <code>machine</code> library defines a <code>CodeFin</code> class that provides the
framework for finalization passes.  To produce an actual finalization pass
for the Alpha target, say, the Alpha library derives a subclass of
<code>CodeFin</code> and specializes the methods representing the different
finalization steps.
<p>
In addition to <code>CodeFin</code>, the <code>machine</code> library currently has such
frameworks for emitting object code in two forms: assembly code
(<code>Printer</code>) and C code (<code>CPrinter</code>).  Eventually, there will be another
one for binary object modules.
<p>
The framework for code generation is called <code>CodeGen</code>.  Its input is in
the form of SUIFvm code, and for that reason it's defined in the <code>suifvm</code>
library, not the <code>machine</code> library.
<p>

<h3><a name=toc14>Bases for Extension</a></h3>
<a name="sec:extension-bases"><b>[*]</b></a>
<p>
The fact that the OPI relies heavily on global variables and functions is
conducive to extensibility of the system.  A problem arises, of course, if
binding the OPI to a particular target machine is done simply by setting
some global variables that are shared by the code for a pass and all the
libraries that it links in.  The issue is that occasionally passes may need
to deal with more than one machine binding at a time.  A binary translator,
for example, needs the descriptions of both its source and target machines
at the same time.  If it needs flow graphs for both kinds of machines at
the same time, then it wouldn't do for the CFG library to rely only on
global variables when accessing machine characteristics.  Elements of such
a library need to be explicitly parameterized so that they can be used for
more than one target within the same application.
<p>
To solve this problem, the <code>machine</code> library provides a class called
<code>Context</code> (Section&nbsp;<a href="#sec:Contexts">[-&gt;]</a>).  Its main purpose is to gather
in one place the target-specific bindings needed for a particular
compilation context.  For example, the function that takes a machine
instruction and returns <code>true</code> if it reads memory is actually stored in a
<code>Context</code>.  That's because it is target-specific; it's definition must
come from a target-specific library.  Likewise, the <code>RegInfo</code> record that
describes that target's register architecture is stored in a <code>Context</code>.
<p>
On the other hand, nearly every kind of pass other than a binary
translator is concerned with only one target machine at a time.  To
accommodate that very common case, the system includes a distinguished
global context, and you access its contents through simple global
functions.  Most pass writers can therefore ignore the context mechanism
records and use these global functions.
<p>
In addition to making optimization code simpler to write, this scheme is
best for porting passes into the dynamic optimization world as well.  In
<a name="NWD2">that setting, a context record would be an unnecessary encumbrance, since</a>
the target is well known.
<p>
Libraries may of course extend the set of target-specific features of the
OPI. For example, the library that supports instruction scheduling needs
more detailed hardware descriptions than are defined in the <code>machine</code>
library.  The <em>Extender's Guide</em> describes how contexts help.  This
document explains the implementation.
<p>
<hr><h2><a name=toc15>Machine Instructions</a></h2>
<a name="sec:machine-instructions"><b>[*]</b></a>
<p>
The central classes in the representation of machine-level code are those
for instruction lists (<code>InstrList</code>), instructions (<code>Instr</code>), and
operands (<code>Opnd</code>).  This section and the next introduce these classes and
the OPI functions that relate to them.
<p>
<h3><a name=toc16>Instruction constituents</a></h3>
<p>
Every machine instruction is an instance of <code>Instr</code>.  Each has
an opcode and most have operands, representing their sources
(``arguments'') and destinations (``results'').
<p>
<h5><a name=toc17>Opcodes.</a></h5>
<p>
An opcode is a non-negative integer.  With two exceptions, the opcode of a
machine instruction is meaningful only when interpreted with respect to an
architecture family.  (The exceptions are <code>opcode_null</code> and
<code>opcode_label</code>, which are the opcodes of any null instruction or label
instruction, respectively.)  The particular numbers used as opcodes are not
dictated by ISAs; they are arbitrarily assigned small integers, useful for
accessing instruction properties by table lookup.  The same integer that
represents <code>mov</code> in an <i>x</i>86 instruction may be used for <code>addq</code> in an
Alpha instruction.  The architecture-specific libraries assign identifiers
to opcodes; for example, <code>MOV</code> stands for <code>mov</code> in the <i>x</i>86 library
and <code>ADDQ</code> stands for <code>addq</code> in the Alpha library.  (See
Section&nbsp;<a href="#sec:machine-opcodes">[-&gt;]</a> for more discussion of opcodes.)
<p>
The <code>get_opcode</code> function returns an instruction's opcode, which is
always set when the instruction is created.
<p>
<h5><a name=toc18>Operands.</a></h5>
<p>
In general, an instruction may have source operands and
destination operands; together, these are its <em>direct</em> operands.
However, an operand that represents an effective address calculation may
itself contain operands; so an instruction can also involve indirect
operands.
<p>
Machine SUIF imposes the constraints that locations read by an
instruction must be explicit in its operands (though possibly
indirectly), and that locations written by an instruction must be
explicit destination operands.  We distinguish the <em>input</em> operands
of an instruction, which are all the values read during the
instruction's execution, from the <em>source</em> operands of the
instruction, which simply identify its direct arguments.
<p>
As an example, consider an <i>x</i>86 instruction that adds the contents of the
<code>%eax</code> register to the memory location specified by the effective address
(EA) expression <code>40(%esp)</code>.  Even though <i>x</i>86 has a two-address ISA, the
Machine-SUIF representation of this instruction has two source operands, an
address-expression operand <code>40(%esp)</code> and a register operand <code>%eax</code>,
and one destination operand, an address-expression operand <code>40(%esp)</code>.
 <b>[</b>It actually has two destination operands.  The second is a
register operand corresponding to the <i>x</i>86 condition-code register.<b>]</b> 
<a name="NWD3">But this add instruction has five inputs: the three register operands (the</a>
direct source operand <code>%eax</code> and the two occurrences of <code>%esp</code> in the
address expressions) and two immediate operands (also in the address
expressions).
<p>
The library provides facilities for enumerating and possibly changing all
the input operands of an instruction.  We begin with functions that access
and alter the direct operands of an instruction.
<p>
<pre><a name="NW1RYwlD-NYywb-1" href="#NWD3"><dfn>&lt;<code>Instr</code> operand accessors and mutators&gt;=</dfn></a> <b>(<a href="#NWDC">U-&gt;</a>)</b>

Opnd        get_src(Instr*, int pos);
Opnd        get_src(Instr*, OpndHandle);
void        set_src(Instr*, int pos, Opnd src);
void        set_src(Instr*, OpndHandle, Opnd src);
void        prepend_src(Instr*, Opnd src);
void        append_src(Instr*, Opnd src);
void        insert_before_src(Instr*, int pos, Opnd src);
void        insert_before_src(Instr*, OpndHandle, Opnd src);
void        insert_after_src(Instr*, int pos, Opnd src);
void        insert_after_src(Instr*, OpndHandle, Opnd src);
Opnd        remove_src(Instr*, int pos);
Opnd        remove_src(Instr*, OpndHandle);
int         srcs_size(Instr* instr);
OpndHandle  srcs_start(Instr*);
OpndHandle  srcs_last(Instr*);
OpndHandle  srcs_end(Instr*);

Opnd        get_dst(Instr*);
Opnd        get_dst(Instr*, int pos);
Opnd        get_dst(Instr*, OpndHandle);
void        set_dst(Instr*, Opnd dst);
void        set_dst(Instr*, int pos, Opnd dst);
void        set_dst(Instr*, OpndHandle, Opnd dst);
void        prepend_dst(Instr*, Opnd dst);
void        append_dst(Instr*, Opnd dst);
void        insert_before_dst(Instr*, int pos, Opnd dst);
void        insert_before_dst(Instr*, OpndHandle, Opnd dst);
void        insert_after_dst(Instr*, int pos, Opnd dst);
void        insert_after_dst(Instr*, OpndHandle, Opnd dst);
Opnd        remove_dst(Instr*, int pos);
Opnd        remove_dst(Instr*, OpndHandle);
int         dsts_size(Instr*);
OpndHandle  dsts_start(Instr*);
OpndHandle  dsts_last(Instr*);
OpndHandle  dsts_end(Instr*);
</pre><p>

In the capsule summaries of the above functions, <code>place</code> represents
a sequence position, which is either a zero-based integer or an
<code>OpndHandle</code>:
<p>
<blockquote>
<code>get_src(instr, place)</code> returns the source of <code>instr</code> at <code>place</code>. <br><code>set_src(instr, place, src)</code> makes <code>src</code> the source of <code>instr</code> at
<code>place</code>. <br><code>prepend_src(instr, src)</code> inserts <code>src</code> at the beginning of
<code>instr</code>'s sources. <br><code>append_src(instr, src)</code> inserts <code>src</code> at the end of <code>instr</code>'s
sources. <br><code>insert_before_src(instr, place, src)</code> inserts <code>src</code> before <code>place</code> in
<code>instr</code>'s sources. <br><code>insert_after_src(instr, place, src)</code> inserts <code>src</code> after <code>place</code> in
<code>instr</code>'s sources. <br><code>remove_src(instr, place)</code> removes and returns the operand at
<code>place</code> in <code>instr</code>'s sources. <br><code>srcs_size(instr)</code> returns the number of source operands of <code>instr</code>.<br><code>srcs_start(instr)</code> returns a handle on the first source of <code>instr</code>. <br><code>srcs_last(instr)</code> returns a handle on the last source operand of
<code>instr</code>. <br><code>srcs_end(instr)</code> returns the sentinel handle for <code>instr</code>'s sources. <br>
<code>get_dst(instr, pos)</code> returns the destination of <code>instr</code> at
position <code>pos</code>.  (<code>pos</code> defaults to 0 if omitted.) <br><code>set_dst(instr, pos, dst)</code> replaces the destination of
<code>instr</code> at position <code>pos</code> by <code>dst</code>. (<code>pos</code> defaults to 0
if omitted.)<br><code>prepend_dst(instr, dst)</code> inserts <code>dst</code> at the beginning of
<code>instr</code>'s destinations. <br><code>append_dst(instr, dst)</code> inserts <code>dst</code> at the end of <code>instr</code>'s
destinations. <br><code>insert_before_dst(instr, place, dst)</code> inserts <code>dst</code> before <code>place</code> in
<code>instr</code>'s destinations. <br><code>insert_after_dst(instr, place, dst)</code> inserts <code>dst</code> after <code>place</code> in
<code>instr</code>'s destinations. <br><code>remove_dst(instr, place)</code> removes and returns the operand at
<code>place</code> in <code>instr</code>'s destinations. <br><code>dsts_size(instr)</code> returns the number of destination operands of
<code>instr</code>. <br><code>dsts_start(instr)</code> returns a handle on the first destination of
<code>instr</code>. <br><code>dsts_end(instr)</code> returns the sentinel place for <code>instr</code>'s
destinations.
</blockquote>
<p>
The <code>srcs_size</code> and <code>dsts_size</code> functions simply return the size of
the underlying operand sequences.  They do not necessarily represent
the semantics of the instruction's opcode.  If <code>set_src</code> or
<code>set_dst</code> is called with an index greater than or equal to the
current sequence size, the sequence is extended automatically.
<p>
Functions <code>get_dst</code> and <code>set_dst</code> each have variants in
which the operand number can be omitted because the case of
single-destination instructions is so common.
<p>
The indirect operands of an instruction can be accessed or changed by
first fetching a direct address operand and then operating on that,
using methods to be described in Section&nbsp;<a href="#sec:machine-operands">[-&gt;]</a>.
<p>
<h5><a name=toc19>Other constituents.</a></h5>
<p>
Some instructions have constituents that are neither sources nor
destinations.  These are managed by functions in the OPI that operate on
instructions.  Control-transfer instructions usually have target labels,
for example; they are not operands, but separate attributes.  These target
symbols are accessed and modified by the OPI functions <code>get_target</code> and
<code>set_target</code> (Section&nbsp;<a href="#sec:machine-instr-accessors-mutators">[-&gt;]</a>).  A
code label is represented by a special instruction that marks its position
in the instruction sequence.  It has no operands.  Its constituent label is
accessed and modified by the OPI functions <code>get_label</code> and <code>set_label</code>.
<p>

<h3><a name=toc20>Creators for <code>Instr</code></a></h3>
<a name="sec:machine-instr-creators"><b>[*]</b></a>
<p>
We refer to functions in the OPI that create new instances of objects as
``creation functions'', or simply <em>creators</em>.  A machine instruction
creator takes an opcode and possibly some operands, and it produces a
machine instruction.
<p>
We divide instructions into broad categories and provide creators for each.
Here's a summary of the breakdown and the mnemonics used for the
categories.
<p>
<ul>
<li>Active instructions (real machine operations)
<ul>
<li>(<code>alm</code>) Arithmetic, logical, and memory instructions
<ul>
<li>(<code>alu</code>) Arithmetic and logical
<li>(<code>mem</code>) Load and store
</ul>
<li>(<code>cti</code>) Control-transfer instructions
</ul>
<li>Inactive instructions
<ul>
<li>(<code>label</code>) Label instructions
<li>(<code>dot</code>) Assembler pseudo-operations <b>[</b>
Many assemblers use a leading period (``<code>.</code>'') to
identify non-code directives.<b>]</b> 
</ul>
</ul>
<p>
The purpose of defining categories is two-fold.  It allows us to provide
creators that are convenient to use because their argument types and
numbers are appropriate for the kind of instruction being created.  It also
allows for an implementation in which different categories may have
different representations.
<p>
Not every real machine instruction falls neatly into one of the above
categories, of course.  The control-transfer instructions (<code>cti</code>) are
the instructions that modify the program counter non-trivially.  They
include conditional and unconditional branches and function calls.  Each
contains a symbol that represents the transfer target.
<p>
The instruction categories aren't exclusive.  On some machines, a
control-transfer instruction might perform arithmetic, so it might have
side effects other than modifying the program counter.  Furthermore, a
program transformation may change an instruction from a pure ALU
operation to one that both computes a value and stores it in memory.
When creating an instruction, you pick the category that most closely
matches the need.  If an instruction needs more operands than the
provided creation function accepts, you add them separately.  The only
<a name="NWD4">constraints to be aware of are pretty obvious: an active instruction can</a>
never acquire a label, an instruction that needs a transfer target
(i.e., a <code>target</code> symbol) must be created as a control-transfer
instruction, and so on.
<p>
Here's are the prototypes of the instruction creators provided in the
<code>machine</code> library.  Their names include the category mnemonics listed
above.  Each returns a result of type <code>Instr*</code>.
<p>
<pre><a name="NW1RYwlD-uyylh-1" href="#NWD4"><dfn>&lt;<code>Instr</code> creation functions&gt;=</dfn></a> <b>(<a href="#NWDC">U-&gt;</a>)</b>
Instr* new_instr_alm(int opcode);
Instr* new_instr_alm(int opcode, Opnd src);
Instr* new_instr_alm(int opcode, Opnd src1, Opnd src2);
Instr* new_instr_alm(Opnd dst, int opcode);
Instr* new_instr_alm(Opnd dst, int opcode, Opnd src);
Instr* new_instr_alm(Opnd dst, int opcode, Opnd src1, Opnd src2);

Instr* new_instr_cti(int opcode, Sym *target);
Instr* new_instr_cti(int opcode, Sym *target, Opnd src);
Instr* new_instr_cti(int opcode, Sym *target, Opnd src1, Opnd src2);
Instr* new_instr_cti(Opnd dst, int opcode, Sym *target);
Instr* new_instr_cti(Opnd dst, int opcode, Sym *target, Opnd src);
Instr* new_instr_cti(Opnd dst, int opcode, Sym *target,
                     Opnd src1, Opnd src2);

Instr* new_instr_label(LabelSym *label);

Instr* new_instr_dot(int opcode);
Instr* new_instr_dot(int opcode, Opnd src);
Instr* new_instr_dot(int opcode, Opnd src1, Opnd src2);
</pre><p>

Note that the opcode always separates the destination from the sources, if
any.  The only difference between two overloadings with the same name is
that they allow different numbers of operands to be put in the created
instruction.  Of course, the number can always be adjusted later.  To
obtain an instruction with more than one destination or more than two
sources, you must use one of the above creators and then add operands to
the instruction that it returns.
<p>
Recall our example of an <i>x</i>86 add instruction.  Suppose <code>value</code> is the
operand representing register <code>%eax</code> (which holds the value to be added
in) and <code>addr</code> is the address operand standing for <code>40(%esp)</code>.
Suppose that <code>body</code> is an <code>InstrList*</code> that we are extending as we
generate code, created perhaps as follows:
<p>
<pre>
    InstrList *body = new_instr_list();
</pre>

Then the add instruction might be created and appended like this:
 <b>[</b>Still ignoring the setting of the condition-code register.<b>]</b> 
<p>
<pre>
    append(body, new_instr_alm(addr, ADD, addr, value));
</pre>

(Here <code>ADD</code> is the <i>x</i>86 opcode for addition.)
<p>
On a load/store machine like the Alpha, the same operation might take three
instructions and an extra register.  Let <code>tmp</code> be the operand
representing a scratch register.  Then the sequence to accomplish the same
add might be:
<p>
<pre>
    append(body, new_instr_alm(tmp,  LDQ,  addr));
    append(body, new_instr_alm(tmp,  ADDQ, tmp, value));
    append(body, new_instr_alm(addr, STQ,  tmp));
</pre>



<h3><a name=toc21>Predicates for <code>Instr</code></a></h3>
<a name="sec:machine-instr-predicates"><b>[*]</b></a>
<p>
The OPI provides Boolean functions to use when your analysis or
<a name="NWD5">optimization pass is trying to detect a particular kind of instruction</a>
(e.g., a move instruction).  Some of these have target-independent
semantics.
<p>
Others make use of the prevailing target context to inspect the instruction
passed to them in a machine-specific way.  As an OPI user, you don't have
to know which is which.  As an extender, you may, and this is covered in
Section&nbsp;<a href="#sec:Contexts">[-&gt;]</a>.
<p>
<pre><a name="NW1RYwlD-198B9i-1" href="#NWD5"><dfn>&lt;<code>Instr</code> predicates&gt;=</dfn></a> <b>(<a href="#NWDC">U-&gt;</a>)</b>
bool is_null(Instr*);
bool is_label(Instr*);
bool is_dot(Instr*);
bool is_mbr(Instr*);
bool is_indirect(Instr*);
bool is_cti(Instr*);
bool reads_memory(Instr*);
bool writes_memory(Instr*);
bool is_builtin(Instr*);

bool is_ldc(Instr*);
bool is_move(Instr*);
bool is_cmove(Instr*);
bool is_predicated(Instr*);
bool is_line(Instr*);
bool is_ubr(Instr*);
bool is_cbr(Instr*);
bool is_call(Instr*);
bool is_return(Instr*);
bool is_binary_exp(Instr*);
bool is_unary_exp(Instr*);
bool is_commutative(Instr*);
bool is_two_opnd(Instr*);
bool is_param_init(Instr*);
</pre><p>

Their capsule summaries:
<p>
<blockquote>
<code>is_null(instr)</code> returns true if <code>instr</code> is a null instruction. <br><code>is_label(instr)</code> returns true if <code>instr</code> is a label
instruction. <br><code>is_dot(instr)</code> returns true if <code>instr</code> is a pseudo-op
instruction. <br><code>is_mbr(instr)</code> returns true if <code>instr</code> is a multi-way branch
instruction. <br><code>is_indirect(instr)</code> returns true if <code>instr</code> is an indirect-jump
instruction. <br><code>is_cti(instr)</code> returns true if <code>instr</code> is a control-transfer
instruction. <br>
<code>reads_memory(instr)</code> returns true if <code>instr</code> reads memory. <br><code>writes_memory(instr)</code> returns true if <code>instr</code> writes
memory. <br>
<code>is_builtin(instr)</code> returns true if <code>instr</code> requires special
implementation on each target platform. <br>
<code>is_ldc(instr)</code> returns true if <code>instr</code> is a load-constant
instruction. <br><code>is_move(instr)</code> returns true if <code>instr</code> is a register-move
instruction. <br><code>is_cmove(instr)</code> returns true if <code>instr</code> is a conditional move
instruction. <br><code>is_predicated(instr)</code> returns true if <code>instr</code> is a predicated
instruction. <br><code>is_line(instr)</code> returns true if <code>instr</code> is a source-code location
instruction. <br>
<code>is_ubr(instr)</code> returns true if <code>instr</code> is an unconditional branch
instruction. <br><code>is_cbr(instr)</code> returns true if <code>instr</code> is a conditional branch
instruction. <br><code>is_call(instr)</code> returns true if <code>instr</code> is a call
instruction. <br><code>is_return(instr)</code> returns true if <code>instr</code> is a return
instruction. <br><code>is_binary_exp(instr)</code> returns true if <code>instr</code> is a side-effect-free
binary expression. <br><code>is_unary_exp(instr)</code> returns true if <code>instr</code> is a side-effect-free
unary expression. <br><code>is_commutative(instr)</code> returns true if <code>instr</code> has two source operands
that can be exchanged without changing its meaning. <br><code>is_two_opnd(instr)</code> returns true if <code>instr</code> is required to be in
<em>two-operand</em> (or ``two-address'') form, i.e., if its first
source operand must equal its (first) destination operand. <br><code>is_param_init(instr)</code> returns true if <code>instr</code> transfers a procedure
argument from its register or stack transmission location to the
parameter variable.
</blockquote>
<p>
A note about <code>is_cbr</code> above: a ``conditional branch'' instruction is
one that has two targets, one of which is an implicit fall-through
target.  The latter characteristic distinguishes it from a multiway
branch that happens to have two targets.  An instruction may satisfy
<code>is_cbr</code> even if its branch condition is statically known or if its
fall-through target is the same as its taken target.
<p>
A typical instruction satisfying <code>is_builtin</code> is one representing an
action like <code>va_start</code> in C, which is often implemented by macro
expansion.
<p>
A predicated instruction (for purposes of <code>is_predicated</code>) is one that
executes only if a predicate operand evaluates to true at run time.  (An
instruction whose predicate is statically known to be true will not satisfy
the <code>is_predicated</code> test.)
<p>
The two-operand constraint is typical of arithmetic instructions on CISC
machines like <i>x</i>86.  While the physical instruction uses one operand field
to express both a source and a destination, Machine SUIF uses distinct
source and destination operand fields, but requires the operands they hold
be equal.
<p>

<h3><a name=toc22><a name="NWD6">Accessors and mutators for </a><code>Instr</code></a></h3>
<a name="sec:machine-instr-accessors-mutators"><b>[*]</b></a>
<p>
In addition to the functions of <code>Instr</code> for accessing and
modifying operands, the OPI provides functions for getting and
setting the fields of particular kinds of instructions:
<p>
<pre><a name="NW1RYwlD-326XED-1" href="#NWD6"><dfn>&lt;<code>Instr</code> field accessors&gt;=</dfn></a> <b>(<a href="#NWDC">U-&gt;</a>)</b>
int get_opcode(Instr *instr);
void set_opcode(Instr *instr, int opcode);

Sym* get_target(Instr *instr);
void set_target(Instr *instr, Sym *target);

LabelSym* get_label(Instr *instr);
void set_label(Instr *instr, LabelSym *label);
</pre><p>

Their summaries:
<p>
<blockquote>
<code>get_opcode(instr)</code> returns the opcode of <code>instr</code>.   <br><code>set_opcode(instr, opcode)</code> replaces the opcode of <code>instr</code> with
<code>opcode</code>.                                                      <br><code>get_target(instr)</code> returns the target of a <code>CTI</code> instruction.       <br><code>set_target(instr, target)</code> replaces the target of <code>instr</code> with
<code>target</code>.                                                      <br><code>get_label(instr)</code> returns the label of a label instruction.           <br><code>set_label(instr, label)</code> replaces the label of <code>instr</code> with
<code>label</code>.
</blockquote>
<p>

<h3><a name=toc23><a name="NWD7">Print Function for </a><code>Instr</code></a></h3>
<a name="sec:machine-instr-print"><b>[*]</b></a>
<p>
Printing of instructions in a form acceptable to an assembler is naturally a
target-specific task.  It's the subject of Section&nbsp;<a href="#sec:printer">[-&gt;]</a>.
Here's a function that uses the target-specific mechanism to print a single
instruction, perhaps for debugging purposes.
<p>
<pre><a name="NW1RYwlD-MUjio-1" href="#NWD7"><dfn>&lt;<code>Instr</code> print function&gt;=</dfn></a> <b>(<a href="#NWDC">U-&gt;</a>)</b>
void fprint(FILE*, Instr*);
</pre><p>


<h3><a name=toc24><a name="NWD8">Machine-instruction lists</a></a></h3>
<a name="sec:instr-list"><b>[*]</b></a>
<p>
<code>InstrList</code> represents a simple sequence of instructions, so most of the
functions related to class <code>InstrList</code> are sequence manipulators.
<p>
<pre><a name="NW1RYwlD-oMH1N-1" href="#NWD8"><dfn>&lt;<code>InstrList</code> functions&gt;=</dfn></a> <b>(<a href="#NWDC">U-&gt;</a>)</b>
InstrList* new_instr_list();
InstrList* to_instr_list(AnyBody*);
int instrs_size(InstrList *list);
InstrHandle instrs_start(InstrList *list);
InstrHandle instrs_last(InstrList *list);
InstrHandle instrs_end(InstrList *list);
void prepend(InstrList *list, Instr *instr);
void append(InstrList *list, Instr *instr);
void replace(InstrList *list, InstrHandle handle, Instr *instr);
void insert_before(InstrList *list, InstrHandle handle, Instr *instr);
void insert_after(InstrList *list, InstrHandle handle, Instr *instr);
Instr* remove(InstrList *list, InstrHandle handle);
</pre><p>

Their summaries:
<p>
<blockquote>
<code>new_instr_list()</code> returns a new <code>InstrList*</code> containing no
instructions. <br><code>to_instr_list(body)</code> returns a new <code>InstrList*</code> after moving the
contents of <code>body</code> into that new list, leaving <code>body</code> empty. <br><code>instrs_size(list)</code> returns the number of elements in <code>list</code>. <br><code>instrs_begin(list)</code> returns a handle on the first element of <code>list</code>. <br><code>instrs_end(list)</code> returns the sentinel handle for <code>list</code>. <br><code>prepend(list, instr)</code> inserts <code>instr</code> at the beginning of <code>list</code>. <br><code>append(list, instr)</code> inserts <code>instr</code> at the end of <code>list</code>. <br><code>replace(list, instr, handle)</code> replaces the element at <code>handle</code> in
<code><a name="NWD9">list</a></code> by <code>instr</code>. <br><code>insert_before(list, handle, instr)</code> inserts <code>instr</code> before <code>handle</code> in
<code>list</code>. <br><code>insert_after(list, handle, instr)</code> inserts <code>instr</code> after <code>handle</code> in
<code>list</code>. <br><code>remove(list, handle)</code> removes and returns the instruction at
<code>handle</code> in <code>list</code>.
</blockquote>
<p>
Type <code>InstrHandle</code> is an abbreviation for a C++ sequence ``iterator''.
So it behaves like a pointer into a list of instructions.
<p>
<pre><a name="NW1RYwlD-4Yuy66-1" href="#NWD9"><dfn>&lt;<code>InstrHandle</code> definition&gt;=</dfn></a> <b>(<a href="#NWDC">U-&gt;</a>)</b>
typedef list&lt;Instr*&gt;::iterator InstrHandle;
</pre><p>

Function <code>to_instr_list</code> serves to produce a ``go-between''
representation for the bodies of optimization units.  To convert the body
of an optimization unit, the generic type for which is <code>AnyBody*</code>, to a
specific form that you need (such as <code>Cfg*</code>), you can apply
<code><a name="NWDA">to_instr_list</a></code> and then build your specific form from the resulting
linear list.
<p>
The <code>instrs_</code> functions are so named because the sequence of instruction
pointers in an <code>InstrList</code> is called <code>instrs</code>.  These functions are
frequently used; since an <code>InstrList</code> contains only one sequence, we
can provide shorter names for these handle-related functions without
ambiguity.
<p>
<pre><a name="NW1RYwlD-2l4twc-1" href="#NWDA"><dfn>&lt;<code>InstrList</code> function nicknames&gt;=</dfn></a> <b>(<a href="#NWDC">U-&gt;</a>)</b>
inline int
size(InstrList *instr_list)
{
    return instrs_size(instr_list);
}

inline InstrHandle
start(InstrList *instr_list)
{
    return instrs_start(instr_list);
}

inline InstrHandle
last(InstrList *instr_list)
{
    return instrs_last(instr_list);
}

inline InstrHandle
end(InstrList *instr_list)
{
    return instrs_end(instr_list);
}
</pre><p>

<a name="NWDB">To print the instructions of an </a><code>InstrList</code> using the conventions of the
prevailing target:
<p>
<pre><a name="NW1RYwlD-Gy83T-1" href="#NWDB"><dfn>&lt;<code>InstrList</code> print function&gt;=</dfn></a> <b>(<a href="#NWDC">U-&gt;</a>)</b>
void fprint(FILE*, InstrList*);
</pre><p>


<h3><a name=toc25><a name="NWDC">Header file </a><code>instr.h</code></a></h3>
<p>
The header file for instructions and instruction lists has the following
outline:
<p>
<pre><a name="NW1RYwlD-2Cn12A-1" href="#NWDC"><dfn>&lt;machine/instr.h&gt;=</dfn></a>
/* file &quot;machine/instr.h&quot; */

<a name="NW1RYwlD-2Cn12A-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_INSTR_H
#define MACHINE_INSTR_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/instr.h&quot;
#endif

#include &lt;machine/substrate.h&gt;
#include &lt;machine/opnd.h&gt;
#include &lt;machine/machine_ir.h&gt;

<a name="NW1RYwlD-2Cn12A-1-u2" href="#NWD3"><i>&lt;<code>Instr</code> operand accessors and mutators&gt;</i></a>

<a name="NW1RYwlD-2Cn12A-1-u3" href="#NWD9"><i>&lt;<code>InstrHandle</code> definition&gt;</i></a>

<a name="NW1RYwlD-2Cn12A-1-u4" href="#NWD4"><i>&lt;<code>Instr</code> creation functions&gt;</i></a>

<a name="NW1RYwlD-2Cn12A-1-u5" href="#NWD6"><i>&lt;<code>Instr</code> field accessors&gt;</i></a>

<a name="NW1RYwlD-2Cn12A-1-u6" href="#NWD5"><i>&lt;<code>Instr</code> predicates&gt;</i></a>

<a name="NW1RYwlD-2Cn12A-1-u7" href="#NWD7"><i>&lt;<code>Instr</code> print function&gt;</i></a>

<a name="NW1RYwlD-2Cn12A-1-u8" href="#NWD8"><i>&lt;<code>InstrList</code> functions&gt;</i></a>

<a name="NW1RYwlD-2Cn12A-1-u9" href="#NWDA"><i>&lt;<code>InstrList</code> function nicknames&gt;</i></a>

<a name="NW1RYwlD-2Cn12A-1-u10" href="#NWDB"><i>&lt;<code>InstrList</code> print function&gt;</i></a>

#endif /* MACHINE_INSTR_H */
</pre><p>
<h2><a name=toc26>Machine Operands</a></h2>
<a name="sec:machine-operands"><b>[*]</b></a>

<!-- Some definitions for describing address expressions.-->

                                              
                                              
                                                        
                                                       
                                                       
                                                
<p>
<!-- And for the HTML audience:-->









<h3><a name=toc27><code>Opnd</code> interface</a></h3>
<a name="sec:opnd-interface"><b>[*]</b></a>
<p>
An instruction operand in Machine SUIF is an instance of class <code>Opnd</code>.
Whereas you always deal with instructions using a pointer (of type
<code>Instr*</code>), an operand is treated as a non-pointer value.  Thus operand
creation functions are not called <code>new_...</code>; their names all have the
prefix <code>opnd_</code>.  They return an <code>Opnd</code>, not an <code>Opnd*</code>, and you don't
need to worry about <code>delete</code>-ing operands when you're finished with them.
<p>
That's not to say that operands cannot have reference behavior.  As
mentioned earlier, class <code>Opnd</code> encapsulates a pointer to a SUIF object.
If you insert a mutable operand into multiple instructions without cloning
it, then a side effect on one occurrence will affect the others.  You must
avoid this if you want to reuse OPI code in settings other than Machine
SUIF.
<p>
<h5><a name=toc28>Common functions on operands.</a></h5>
<p>
There are several kinds of operands, and most of the operand-related
functions have to do with one particular kind or another.  Before going
<a name="NWDD">through the kinds, we describe some functions that can be applied to any</a>
operand.
<p>
To ask what kind of operand is represented by a particular <code>Opnd</code> value
(e.g., register operand versus address-symbol operand), you use the
<code>get_kind</code> function, which returns an integer indicator.  As we go
through the operand kinds in the rest of this section, we'll give the
symbolic names for the various operand-kind indicators.
<p>
<pre><a name="NW4F8FIv-4Ujwws-1" href="#NWDD"><dfn>&lt;<code>Opnd</code> common functions&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b> <b>[D<a href="#NWDE">-&gt;</a>]</b>
int get_kind(Opnd);
</pre><p>

<a name="NWDE">There are also predicates for testing whether an operand is of a particular</a>
kind.  Although they are applicable to any operand, we'll also list these
predicates as we go through the kinds.
<p>
Every operand has a type, i.e., a <code>TypeId</code> that gives the type of the
value that the operand represents.  You use the <code>get_type</code> function to
obtain this type.
<p>
<pre><a name="NW4F8FIv-4Ujwws-2" href="#NWDD"><dfn>&lt;<code>Opnd</code> common functions&gt;+=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b> <b>[<a href="#NWDD">&lt;-</a>D<a href="#NWDF">-&gt;</a>]</b>
TypeId get_type(Opnd);
</pre><p>

<a name="NWDF">The other function that all operands have in common is a replication</a>
utility.
<p>
<pre><a name="NW4F8FIv-4Ujwws-3" href="#NWDD"><dfn>&lt;<code>Opnd</code> common functions&gt;+=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b> <b>[<a href="#NWDE">&lt;-</a>D<a href="#NWDG">-&gt;</a>]</b>
Opnd clone(Opnd);
</pre><p>

<code>clone</code> returns its argument unchanged unless it is of a kind that has
mutable fields.  (Currently, only the address-expression operands have that
property.)  In this case, it returns a copy of the argument operand, one
whose fields can be changed without affecting the original.
<p>
<a name="NWDG">Two operands are equal under operator </a><code>==</code> only if their kind
and type attributes are equal and they satisfy additional conditions.
These conditions are spelled out below.  The disequality operator (<code>!=</code>)
just inverts the equality result.
<p>
Because you sometimes need to map from operands to other types of values,
we define a function that extracts a hash code from an operand.
<p>
<pre><a name="NW4F8FIv-4Ujwws-4" href="#NWDD"><dfn>&lt;<code>Opnd</code> common functions&gt;+=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b> <b>[<a href="#NWDF">&lt;-</a>D<a href="#NWDH">-&gt;</a>]</b>
size_t hash(Opnd);
</pre><p>

<a name="NWDH">For debugging purposes, there is a function for printing operands in a</a>
machine-independent manner.  This is not the way operands are printed in
machine-specific assembly output, of course.  See Section&nbsp;<a href="#sec:printer">[-&gt;]</a>
to understand more about of how that works.
<p>
<pre><a name="NW4F8FIv-4Ujwws-5" href="#NWDD"><dfn>&lt;<code>Opnd</code> common functions&gt;+=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b> <b>[<a href="#NWDG">&lt;-</a>D]</b>
void fprint(FILE*, Opnd);
</pre><p>


Now let's go through the different kinds of operands and the functions that
<a name="NWDI">relate to each kind.</a>
<p>

<h5><a name=toc29>Null operands.</a></h5>
<p>
These are simply placeholders.  They always have <code>void</code> type.  Any null
operand is equal to another one.  There are two OPI functions for null
operands:
<p>
<pre><a name="NW4F8FIv-3j34VS-1" href="#NWDI"><dfn>&lt;null-operand functions&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
Opnd opnd_null();
bool is_null(Opnd);
</pre><p>

Synopses:
<p>
<blockquote>
<code>opnd_null()</code>          returns a null operand. <br><code>is_null(opnd)</code>        returns <code>true</code> if <code>opnd</code> is null.
</blockquote>
<p>
In addition, the default constructor for class <code>Opnd</code> is publicly
accessible and yields a null operand.
<p>
The kind identifier for a null operand is <code>opnd::NONE</code>.
<p>

<h5><a name=toc30><a name="NWDJ">Variable-symbol operands.</a></a></h5>
<p>
These are occurrences of source-language variables or compiler-generated
temporary variables.  (Not to be confused with virtual registers, which do
not involve a symbol.)
<p>
The OPI has the following functions for variable-symbol operands:
<p>
<pre><a name="NW4F8FIv-1f5jHL-1" href="#NWDJ"><dfn>&lt;variable-symbol-operand functions&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
Opnd opnd_var(VarSym* var);
bool is_var(Opnd);
VarSym* get_var(Opnd);
</pre><p>

Synopses:
<p>
<blockquote>
<code>opnd_var(var)</code> returns a variable-symbol operand referring to <code>var</code>. <br><code>is_var(opnd)</code> returns <code>true</code> if <code>opnd</code> is a variable-symbol
operand. <br><code>get_var(opnd)</code> returns the variable symbol embedded in <code>opnd</code>.
</blockquote>
<p>
The kind identifier for a variable-symbol operand is <code>opnd::VAR</code>.
Two variable-symbol operands are equal if and only if their embedded symbols
are equal.  Since the type of this kind of operand is taken from the type
of the embedded variable-symbol, this definition of equality implicitly
requires equal types.
<p>

<h5><a name=toc31>Register operands.</a></h5>
<p>
<a name="NWDK">These represent machine registers, both the real architectural registers of</a>
the target machine and any virtual registers (sometimes called
pseudo-registers) created by the compiler prior to register allocation.
Each contains a non-negative register number and an explicit type.  The
real hardware registers have numbers that can be interpreted via the
register description of the target machine (see Section&nbsp;<a href="#sec-reg-desc">[-&gt;]</a>).
<p>
The OPI provides the following functions for register operands:
<p>
<pre><a name="NW4F8FIv-2I5fi2-1" href="#NWDK"><dfn>&lt;register-operand functions&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
Opnd opnd_reg(int reg, TypeId, bool is_virtual = false);
Opnd opnd_reg(TypeId);
bool is_reg(Opnd);
bool is_hard_reg(Opnd);
bool is_virtual_reg(Opnd);
int get_reg(Opnd);
</pre><p>

Synopses:
<p>
<blockquote>
<code>opnd_reg(reg, type, is_virtual)</code> returns an operand for register <code>reg</code>. <br><code>opnd_reg(type)</code>       returns a new virtual register operand. <br><code>is_reg(opnd)</code>         returns <code>true</code> if <code>opnd</code> is a register. <br><code>is_hard_reg(opnd)</code>    returns <code>true</code> if <code>opnd</code> is a hardware register. <br><code>is_virtual_reg(opnd)</code> returns <code>true</code> if <code>opnd</code> is a virtual register. <br><code>get_reg(opnd)</code>        returns the register number of <code>opnd</code>.
</blockquote>
<p>
The usual way to create a virtual-register operand is simply to provide its
type; in this case, an unused virtual number is allocated and incorporated
in the new operand.  To create a hard-register operand, you supply the
register number and the type.  Occasionally, you need to create a
virtual-register operand with a specific number.  In that case, you provide
the number, the type, and the Boolean <code>true</code> when calling <code>opnd_reg</code>.
<p>
The kind identifier for hardware-register operands is <code>opnd::REG_HARD</code>.
The kind identifier for virtual-register operands is <code>opnd::REG_VIRTUAL</code>.
Two register operands are equal if and only if they are of the same kind,
and their <code>reg</code> and <code>type</code> attributes are are pairwise equal.
<p>

<h5><a name=toc32>Immediate operands.</a></h5>
<p>
There are two kinds of immediate operands: one holds integers and the
other strings.  Integer immediates can represent either signed or
unsigned integer immediate values of any magnitude.  The accompanying
<a name="NWDL">type gives the intended precision.  For floating-point immediate</a>
operands, we use strings describing the numeric value, again paired with
a type.  We also use untyped immediate string operands, though they
don't appear in operate instructions.  They allow the pseudo-instruction
(<code>dot</code>) class, which sometimes requires string literals, to use the
same operand interface as the other instruction classes.
<p>
The OPI functions for immediate operands are as follows:
<p>
<pre><a name="NW4F8FIv-3REVj5-1" href="#NWDL"><dfn>&lt;immediate-operand functions&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
Opnd opnd_immed(int, TypeId);
Opnd opnd_immed(Integer, TypeId);
Opnd opnd_immed(IdString, TypeId);
Opnd opnd_immed(IdString);

bool is_immed(Opnd);
bool is_immed_integer(Opnd);
bool is_immed_string(Opnd);

int get_immed_int(Opnd);
Integer get_immed_integer(Opnd);
IdString get_immed_string(Opnd);
</pre><p>

<blockquote>
<code>opnd_immed(integer, type)</code> returns an integer immediate operand with type
<code>type</code>. <br><code>opnd_immed(string, type)</code> returns a floating immediate operand with
type <code>type</code>. <br><code>opnd_immed(string)</code> returns a string immediate operand,  with no type. <br><code>is_immed(opnd)</code> returns <code>true</code> if <code>opnd</code> is an immediate. <br><code>is_immed_integer(opnd)</code>
returns <code>true</code> if <code>opnd</code> is an integer immediate. <br><code>is_immed_string(opnd)</code>
returns <code>true</code> if <code>opnd</code> is a string immediate. <br><code>get_immed_int(opnd)</code>
returns the value of an integer immediate operand as a
C <code>int</code>, or raises an exception if that's impossible. <br><code>get_immed_integer(opnd)</code>
returns the value of an integer immediate operand.<br><code>get_immed_string(opnd)</code>
returns the value of a string immediate operand.
</blockquote>
<p>
Note that, when operand <code>opnd</code> satisfies <code>is_immed_string(opnd)</code>, you
can tell whether it's numeric or not by checking its type:
<code>get_type(opnd)</code> returns <code>0</code> if <code>opnd</code> represents a
simple string literal.  (In practice, the nature of the immediate operand
is nearly always apparent from the context.)
<p>
The kind identifier for an integer-immediate operand is
<code>opnd::IMMED_INTEGER</code>; that for a string-immediate operand is
<code>opnd::IMMED_STRING</code>.  Two immediate operands are equal if and only
if they are of the same kind and their <code>type</code> and <code>value</code> attributes
are pairwise equal.
<p>


<h5><a name=toc33>Address operands.</a></h5>
<p>
The remaining kinds of builtin operands are address symbols and address
expressions, which together we call <em>address operands</em>.  An address
operand represents the effective-address (EA) calculation performed during
a machine instruction to generate a memory address.  The type of an address
operand is always a pointer type.  Such an operand is created with the
pointer-to-<code>void</code> type appropriate for the compilation target.  (This is
the same <code>TypeId</code> that results from evaluating <code>type_ptr</code>.  See
Section&nbsp;<a href="#sec:types">[-&gt;]</a>.)
<p>
<a name="NWDM">It is often useful to be able to determine the </a><em>referent</em> type of an
address operand, i.e., the type of the value obtained by dereferencing the
address that the operand represents.  Obviously, this information could be
incorporated in the address-operand type if the OPI required precise
pointer-type constructors.  But that would entail a good deal of pointer
type composition and decomposition at optimization time.  So instead,
address operands carry an additional type attribute called <code>deref_type</code>.
You access and update it it using:
<p>
<pre><a name="NW4F8FIv-1fTGSr-1" href="#NWDM"><dfn>&lt;address-operand functions&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b> <b>[D<a href="#NWDN">-&gt;</a>]</b>
TypeId get_deref_type(Opnd);
void set_deref_type(Opnd, TypeId);
</pre><p>

<a name="NWDN">If non-null, this attribute gives the type of the dereferenced value.</a>
(We explain below when and why the referent type attribute may be null.)
<p>
There is a predicate satisfied only by an address operand:
<p>
<pre><a name="NW4F8FIv-1fTGSr-2" href="#NWDM"><dfn>&lt;address-operand functions&gt;+=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b> <b>[<a href="#NWDM">&lt;-</a>D]</b>
bool is_addr(Opnd);
</pre><p>


<h5><a name=toc34><a name="NWDO">Address symbols.</a></a></h5>
<p>
The simplest kind of address operand is the address symbol, which
represents the address of a variable symbol or a code label symbol.
<p>
The OPI functions for address symbols are:
<p>
<pre><a name="NW4F8FIv-20vooE-1" href="#NWDO"><dfn>&lt;address-symbol-operand functions&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
Opnd opnd_addr_sym(Sym* sym);
bool is_addr_sym(Opnd);
Sym* get_sym(Opnd addr_sym);
</pre><p>

Synopses:
<p>
<blockquote>
<code>opnd_addr_sym(sym)</code> returns an address symbol based on <code>sym</code>. <br><code>is_addr_sym(opnd)</code> returns <code>true</code> if <code>opnd</code> is an address symbol. <br><code>get_sym(opnd)</code> returns the symbol underlying <code>opnd</code>.
</blockquote>
<p>
The kind identifier for an address-symbol operand is <code>opnd::ADDR_SYM</code>.
Two address-symbol operands are equal if and only if they have equal
<code>sym</code> values.  
The <code>deref_type</code> of an address symbol is always derived from the
underlying symbol.  If it's a variable or procedure symbol, then the
<code>deref_type</code> is the type of the variable or procedure.  If it's a label
symbol, then <code>get_deref_type</code> returns <code>NULL</code>.
<p>
Recall our earlier example of an <i>x</i>86 add-to-memory instruction, with
<code>addr</code> representing the address of the memory location that is
incremented by <code>value</code>.  If the memory location is that of variable
<code>foo</code>, then operand <code>addr</code> would be an address symbol constructed from
the <code>VarSym*</code> for <code>foo</code> (which we might call <code>var_foo</code>).  The code
might look like this:
<p>
<pre>
    Opnd addr = opnd_addr_sym(var_foo);

    append(body, new_instr_alm(addr, ADD, addr, value));
</pre>


<h5><a name=toc35>Address expressions.</a></h5>
<p>
There are several varieties of address expression, corresponding to the
addressing modes used in hardware.  We use address operands to represent
whole EA calculations.  Like address symbols, all address expression
operands are created with a type attribute equal to <code>type_ptr</code>.
<p>
The unique characteristics of address expressions are that they embed other
operands and they are mutable: you can replace the operands that make up an
address expression.  For example, a ``base-plus-displacement'' operand
represents the address that results at run time from adding a fixed
displacement to the contents of a base register.  Earlier, for instance, we
used the example of an <i>x</i>86 stack cell located at <code>$esp + 40</code>.  The
corresponding address-expression operand would contain the register operand
for <code>$esp</code> as its base part and an immediate operand for the number
<code>40</code> as its displacement part.
<p>
A typical program transformation that could change the constituent operands
of an address expression is register allocation.  A base-plus-displacement
operand with a virtual register as its base would be modified when the
virtual register is allocated to a physical one.
<p>
Because address expressions are mutable, you should be aware that the
implementation allows the mutable parts to be shared between occurrences.
Machine SUIF doesn't force you to maintain separate copies, since this
would often be semantically pointless.  In our earlier example of the <i>x</i>86
add-to-memory instruction that updates stack location <code>40(%esp)</code>, we
didn't bother to clone the address expression before using it a second
time:
<pre>
    append(body, new_instr_alm(addr, ADD, addr, value));
</pre>
Neither its base register <code>%esp</code> nor its displacement <code>40</code> will be
affected by a register allocator, and in any case, the hardware sees <code>addr</code>
as a single operand, not as two separate once.  Be warned, though, that
Machine SUIF doesn't guarantee to preserve sharing patterns that you may
establish in this way.  For example, when an instruction
is <em>cloned</em>, i.e., replicated, its address expressions are replicated
individually.
<p>
To produce the variable of type <code>Opnd</code> called <code>addr</code> in the above
example, we might write:
<p>
<pre>
    Opnd esp  = opnd_reg(REG_esp, type_ptr);
    Opnd i40  = opnd_immed(40, type_s32);
    Opnd addr = BaseDispOpnd(esp, i40, type_s32);
</pre>

Here <code>REG_esp</code> is an integer variable previously set to the register
number for <code>%esp</code> (see Section&nbsp;<a href="#sec-reg-desc">[-&gt;]</a>).  It is incorporated
into a register operand <code>esp</code> with the generic pointer type that is
appropriate for the current target; the OPI calls this <code>type_ptr</code>.
Next, the displacement operand <code>i40</code> is created and given a signed 32-bit
integral type.  Finally, the address expression <code>addr</code> is constructed
from these base and displacement suboperands.  The third argument to the
constructor <code>BaseDispOpnd</code> is the <code>deref_type</code>, i.e., the type of the
value in the address that <code>addr</code> refers to.
<p>
Sometimes an address expression is used purely for address computation; the
referent type is unknown and unneeded.  For those cases, the OPI allows you
to omit it, which leaves it <code>NULL</code>.  For example, in Alpha code, a stack
frame is allocated by subtracting a constant from the stack-pointer
register.  This is usually expressed using a load-address instruction:
<p>
<pre>
    Opnd sp = opnd_reg(REG_sp, type_ptr);   // stack pointer reg ($sp)
    Opnd sz = opnd_immed(-80,  type_s32);   // -(frame size)

    <a name="NWDP">append(body, new_instr_alm(sp, LDA, BaseDispOpnd(sp, sz)));</a>
</pre>

where <code>LDA</code> is the Alpha load-address opcode.
<p>
Machine SUIF includes these functions for testing and creating address
expressions:
<p>
<pre><a name="NW4F8FIv-4OlbOy-1" href="#NWDP"><dfn>&lt;address-expression-operand functions&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
bool is_addr_exp(Opnd);
Opnd opnd_addr_exp(int kind);
Opnd opnd_addr_exp(int kind, TypeId deref_type);
</pre><p>

<blockquote>
<code>is_addr_exp(opnd)</code> returns <code>true</code> when <code>opnd</code> is an
address expression. <br><code>opnd_addr_exp(kind, deref_type)</code> returns an address expression operand
of kind <code>kind</code> referring to a value of type <code>deref_type</code>.
</blockquote>
<p>
The <code>kind</code> argument to <code>opnd_addr_exp</code> must be one associated with a
specific address-expression kind, e.g., one of those in
Table&nbsp;<a href="#tab:addr-exp-kinds">[-&gt;]</a>.  There is no way to create a ``generic''
address expression.
<p>
The <code>deref_type</code> argument to <code>opnd_addr_exp</code> may be omitted, in which
case the resulting operand's referent type is unspecified (and it equals
<a name="NWDQ">zero when tested).</a>
<p>
<h5><a name=toc36>Programming with address expressions.</a></h5>
<p>
The function <code>opnd_addr_exp</code> described above is <em>not</em> part of the
OPI.  It's meant for extenders of the system.  In optimization passes or
libraries, you should use class <code>AddrExpOpnd</code> and its subclasses as the
interface to address expressions.
<p>
<pre><a name="NW4F8FIv-1J3s6K-1" href="#NWDQ"><dfn>&lt;class <code>AddrExpOpnd</code>&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
class AddrExpOpnd : public Opnd {
  public:
    AddrExpOpnd() { }
    AddrExpOpnd(const Opnd&amp;);
    AddrExpOpnd(Opnd&amp;);
    AddrExpOpnd(int kind, TypeId deref_type = 0)
        : Opnd(opnd_addr_exp(kind, deref_type)) { }

    TypeId get_deref_type() const;

    int srcs_size() const;
    OpndHandle srcs_start()const ;
    OpndHandle srcs_end() const;
    Opnd get_src(int pos) const;
    Opnd get_src(OpndHandle handle) const;
    void set_src(int pos, Opnd src);
    void set_src(OpndHandle handle, Opnd src);
};
</pre><p>

Here
<p>
<blockquote>
<code>AddrExpOpnd(kind, deref_type)</code> produces a new address expression with
the given kind and referent type. (The latter is optional.) <br><code>srcs_size()</code> returns the size of the address expression's <code>srcs</code>
sequence. <br><code>srcs_start()</code> gives a handle on the first element of <code>srcs</code>, if any. <br><code>srcs_end()</code> gives the end-sentinel of <code>srcs</code>. <br><code>get_src(p)</code> returns the source of the address expression at position
<code>p</code>, which may be a zero-based integer or a handle. <br><code>set_src(p, src)</code> substitutes  <code>src</code> for the source of the address
expression at position <code>p</code> (which may be a zero-based integer
or a handle).
</blockquote>
<p>
Both <code>get_src</code> and <code>set_src</code> extend the <code>srcs</code> sequence if necessary.
<p>
Just as an instruction contains a sequence of direct source operands that
we call its <code>srcs</code> field, every address expression has a <code>srcs</code>
sequence, and the same functions for scanning, accessing, and changing the
elements of the sequence apply.  For each kind of address expression, there
is a subclass of Opnd that allows referring to source operands by more
descriptive field names, such as <code>base</code> or <code>disp</code>, but these fields are
just elements of the overall source sequence.
<p>
Although address expressions describe how to compute the <em>value</em> of an
effective address, they don't encode side effects that might be associated
with a particular addressing mode, such as post-increment.
<p>
For two address expression operands to be equal under the <code>==</code> operator,
they must be of the same kind and have the same <code>deref_type</code>, and their
source operands must be equal in number and pairwise equal under <code>==</code>.
<p>

<h5><a name=toc37>Specific address-expression kinds.</a></h5>
<p>
The <code>AddrExpOpnd</code> interface is convenient for operations that are
indifferent to the specific kind of an address expression.  A register
allocator, for instance, may make substitutions among the components of an
address expression without needing to know the particular kind.  For other
purposes, though, a specific interface is needed for each kind of address
expression that the target machine supports.
<p>


<!-- Some definitions for describing address expressions.-->

                                              
                                              
                                                        
                                                       
                                                       
                                                
<p>
<!-- And for the HTML audience:-->








The specific kinds of address expression that the OPI defines are summarized in
Table&nbsp;<a href="#tab:addr-exp-kinds">[-&gt;]</a>, which matches each kind indicator with the
corresponding form of address expression.
<p>

<hr>

<blockquote><i><table><!-- alignment is l@{\hspace{3em}}l@{\hspace{2em}}lcccc--><!-- 7 columns--><tr><td align=left valign=top><code>opnd::SYM_DISP</code>              </td><td align=left valign=top></td><td align=left valign=top></td><td align=center><i>address-symbol</i></td><td align=center>+ </td><td align=center><i>displacement</i></td><td align=center></td></tr>
<tr><td align=left valign=top><code>opnd::INDEX_SYM_DISP</code>        </td><td align=left valign=top><i>index-register</i></td><td align=left valign=top>+ </td><td align=center><i>address-symbol</i></td><td align=center>+ </td><td align=center><i>displacement</i></td><td align=center></td></tr>
<tr><td align=left valign=top><code>opnd::BASE_DISP</code>             </td><td align=left valign=top><i>base</i></td><td align=left valign=top></td><td align=center></td><td align=center>+ </td><td align=center><i>displacement</i></td><td align=center></td></tr>
<tr><td align=left valign=top><code>opnd::BASE_INDEX</code>            </td><td align=left valign=top><i>base</i></td><td align=left valign=top>+ </td><td align=center><i>index</i></td><td align=center></td><td align=center></td><td align=center></td></tr>
<tr><td align=left valign=top><code>opnd::BASE_INDEX_DISP</code>       </td><td align=left valign=top><i>base</i></td><td align=left valign=top>+ </td><td align=center><i>index</i></td><td align=center>+ </td><td align=center><i>displacement</i></td><td align=center></td></tr>
<tr><td align=left valign=top><code>opnd::INDEX_SCALE_DISP</code>      </td><td align=left valign=top></td><td align=left valign=top></td><td align=center><i>index</i>&times;<i>scale</i></td><td align=center>+ </td><td align=center><i>displacement</i></td><td align=center></td></tr>
<tr><td align=left valign=top><code>opnd::BASE_INDEX_SCALE_DISP</code> </td><td align=left valign=top><i>base</i></td><td align=left valign=top>+ </td><td align=center><i>index</i>&times;<i>scale</i></td><td align=center>+ </td><td align=center><i>displacement</i></td><td align=center></td></tr></table>
</i></blockquote><br>
where
<p>
<blockquote>
<table><!-- alignment is lp{.5\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><i><i>index-register</i></i>            </td><td align=left valign=top>is a register operand                  </td></tr>
<tr><td align=left valign=top><i><i>address-symbol</i></i>            </td><td align=left valign=top>is an address-symbol operand           </td></tr>
<tr><td align=left valign=top><i><i>base</i></i> and <i><i>index</i></i> </td><td align=left valign=top>are either register or variable-symbol
operands; the latter stand for
variables to be assigned to registers  </td></tr>
<tr><td align=left valign=top><i><i>scale</i></i>                     </td><td align=left valign=top>is an immediate operand containing an
unsigned integer (typically a small
power of 2)                            </td></tr>
<tr><td align=left valign=top><i><i>displacement</i></i>              </td><td align=left valign=top>is an immediate operand containing a
signed integer
</td></tr></table>
</blockquote>
<b>Address expression categories.</b>
<a name="tab:addr-exp-kinds"><b>[*]</b></a>
------<hr>

Each of these address-expression kinds has an explicit name for each element of
its <code>srcs</code> sequence, so that it can be fetched and replaced using
mnemonically-named methods.  Here are the field names:
<p>
<table><!-- alignment is l@{\hspace*{2em}}p{.5\linewidth}--><!-- 2 columns--><tr><td align=left valign=top><code>addr_sym</code>    </td><td align=left valign=top>an address symbol                             </td></tr>
<tr><td align=left valign=top><code>disp</code>        </td><td align=left valign=top>an integer immediate                          </td></tr>
<tr><td align=left valign=top><code>index</code>       </td><td align=left valign=top>a register operand                            </td></tr>
<tr><td align=left valign=top><code>base</code>        </td><td align=left valign=top>a register or variable-symbol operand         </td></tr>
<tr><td align=left valign=top><code>scale</code>       </td><td align=left valign=top>an integer immediate
</td></tr></table>
<p>

For each kind of address expression, we now describe the subclass of
<code>Opnd</code> that gives access to the applicable fields through its
methods. For each of these kinds, there is an operand-kind identifier, a
creation function (prefix <code>opnd_</code>) and a predicate (prefix <code>is_</code>).
<p>

<h5><a name=toc38><a name="NWDR">The </a><i><i>address-symbol</i>+ <i>displacement</i></i>kind.</a></h5>
<p>
This address form represents a fixed displacement (<code>disp</code>) from the
memory address of a symbol (<code>addr_sym</code>).  Its <code>Opnd</code> subclass is
<code>SymDispOpnd</code>.  Its kind identifier is <code>opnd::SYM_DISP</code>.
<p>
Class <code>SymDispOpnd</code> gives the methods for composing, inspecting and
changing symbol-plus-displacement operands:
<p>
<pre><a name="NW4F8FIv-3eqdPQ-1" href="#NWDR"><dfn>&lt;class <code>SymDispOpnd</code>&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
class SymDispOpnd : public AddrExpOpnd {
  public:
    SymDispOpnd(Opnd addr_sym, Opnd disp, TypeId deref_type = 0);
    SymDispOpnd(const Opnd&amp;);
    SymDispOpnd(Opnd&amp;);

    Opnd get_addr_sym() const;
    void set_addr_sym(Opnd);
    Opnd get_disp() const;
    void set_disp(Opnd);
};

bool is_sym_disp(Opnd);
</pre><p>


<h5><a name=toc39><a name="NWDS">The </a><i><i>index-register</i>+ <i>address-symbol</i>+ <i>displacement</i></i>kind.</a></h5>
<p>
This address form combines the run-time value of an index register with
a fixed displacement and the memory address of a symbol.  Its kind identifier is
<code>opnd::INDEX_SYM_DISP</code>.
<p>
Class <code>IndexSymDispOpnd</code> gives the methods for composing, inspecting and
changing index-plus-symbol-plus-displacement operands:
<p>
<pre><a name="NW4F8FIv-1Ym0Sh-1" href="#NWDS"><dfn>&lt;class <code>IndexSymDispOpnd</code>&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
class IndexSymDispOpnd : public AddrExpOpnd {
  public:
    IndexSymDispOpnd(Opnd index, Opnd addr_sym, Opnd disp,
                     TypeId deref_type = 0);
    IndexSymDispOpnd(const Opnd&amp;);
    IndexSymDispOpnd(Opnd&amp;);

    Opnd get_index() const;
    void set_index(Opnd);
    Opnd get_addr_sym() const;
    void set_addr_sym(Opnd);
    Opnd get_disp() const;
    void set_disp(Opnd);
};

bool is_index_sym_disp(Opnd);
</pre><p>


<h5><a name=toc40>The <i><i>base</i>+ <i>displacement</i></i>kind.</a></h5>
<p>
<a name="NWDT">This address form combines the value of a base register with a fixed</a>
displacement.  Its <code>Opnd</code> subclass is <code>BaseDispOpnd</code>.  Its kind
identifier is <code>opnd::BASE_DISP</code>.  The base operand may either be a
register operand or a variable symbol that represents a register candidate.
<p>
Class <code>BaseDispOpnd</code> gives the methods for composing, inspecting and
changing base-plus-displacement operands:
<p>
<pre><a name="NW4F8FIv-SyK7s-1" href="#NWDT"><dfn>&lt;class <code>BaseDispOpnd</code>&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
class BaseDispOpnd : public AddrExpOpnd {
  public:
    BaseDispOpnd(Opnd base, Opnd disp, TypeId deref_type = 0);
    BaseDispOpnd(const Opnd&amp;);
    BaseDispOpnd(Opnd&amp;);

    Opnd get_base() const;
    void set_base(Opnd);
    Opnd get_disp() const;
    void set_disp(Opnd);
};

bool is_base_disp(Opnd);
</pre><p>

<h5><a name=toc41><a name="NWDU">The </a><i><i>base</i>+ <i>index</i></i>kind.</a></h5>
<p>
This address form combines the values two registers, base and index.  Its
<code>Opnd</code> subclass is <code>BaseIndexOpnd</code>. Its kind identifier is
<code>opnd::BASE_INDEX</code>.
<p>
Class <code>BaseIndexOpnd</code> gives the methods for composing, inspecting and
changing base-plus-index operands:
<p>
<pre><a name="NW4F8FIv-1QQqT4-1" href="#NWDU"><dfn>&lt;class <code>BaseIndexOpnd</code>&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
class BaseIndexOpnd : public AddrExpOpnd {
  public:
    BaseIndexOpnd(Opnd base, Opnd index, TypeId deref_type = 0);
    BaseIndexOpnd(const Opnd&amp;);
    BaseIndexOpnd(Opnd&amp;);

    Opnd get_base() const;
    void set_base(Opnd);
    Opnd get_index() const;
    void set_index(Opnd);
};

bool is_base_index(Opnd);
</pre><p>


<h5><a name=toc42><a name="NWDV">The </a><i><i>base</i>+ <i>index</i>+ <i>displacement</i></i>kind.</a></h5>
<p>
This address form combines two registers (base and index) with a fixed
displacement.  Its <code>Opnd</code> subclass is <code>BaseIndexDispOpnd</code>.  Its kind
identifier is <code>opnd::BASE_INDEX_DISP</code>.
<p>
Class <code>BaseIndexDispOpnd</code> gives the methods for composing, inspecting and
changing base-plus-index-plus-displacement operands:
<p>
<pre><a name="NW4F8FIv-1uDjjd-1" href="#NWDV"><dfn>&lt;class <code>BaseIndexDispOpnd</code>&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
class BaseIndexDispOpnd : public AddrExpOpnd {
  public:
    BaseIndexDispOpnd(Opnd base, Opnd index, Opnd disp, TypeId deref_type = 0);
    BaseIndexDispOpnd(const Opnd&amp;);
    BaseIndexDispOpnd(Opnd&amp;);

    Opnd get_base() const;
    void set_base(Opnd);
    Opnd get_index() const;
    void set_index(Opnd);
    Opnd get_disp() const;
    void set_disp(Opnd);
};

bool is_base_index_disp(Opnd);
</pre><p>


<h5><a name=toc43><a name="NWDW">The </a><i><i>index</i>&times;<i>scale</i>+ <i>displacement</i></i>kind.</a></h5>
<p>
This address form multiplies an index register's value by a fixed scale
factor and adds a fixed displacement.  Its <code>Opnd</code> subclass is
<code>IndexScaleDispOpnd</code>.  Its kind identifier is <code>opnd::INDEX_SCALE_DISP</code>.
<p>
<pre><a name="NW4F8FIv-C1wfE-1" href="#NWDW"><dfn>&lt;class <code>IndexScaleDispOpnd</code>&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
class IndexScaleDispOpnd : public AddrExpOpnd {
  public:
    IndexScaleDispOpnd(Opnd index, Opnd scale, Opnd disp,
                       TypeId deref_type = 0);
    IndexScaleDispOpnd(const Opnd&amp;);
    IndexScaleDispOpnd(Opnd&amp;);

    Opnd get_index() const;
    void set_index(Opnd);
    Opnd get_scale() const;
    void set_scale(Opnd);
    Opnd get_disp() const;
    void set_disp(Opnd);
};

bool is_index_scale_disp(Opnd);
</pre><p>


<h5><a name=toc44><a name="NWDX">The </a><i><i>base</i>+ <i>index</i>&times;<i>scale</i>+ <i>displacement</i></i>kind.</a></h5>
<p>
This address form combines the value of a base register with the result of
scaling an index register and adding a fixed displacement.  Its <code>Opnd</code>
subclass is <code>BaseIndexScaleDispOpnd</code>.  Its kind identifier is
<code>opnd::BASE_INDEX_SCALE_DISP</code>.
<p>
<pre><a name="NW4F8FIv-oQhZt-1" href="#NWDX"><dfn>&lt;class <code>BaseIndexScaleDispOpnd</code>&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
class BaseIndexScaleDispOpnd : public AddrExpOpnd {
  public:
    BaseIndexScaleDispOpnd(Opnd base, Opnd index, Opnd scale, Opnd disp,
                           TypeId deref_type = 0);
    BaseIndexScaleDispOpnd(const Opnd&amp;);
    BaseIndexScaleDispOpnd(Opnd&amp;);

    Opnd get_base() const;
    void set_base(Opnd);
    Opnd get_index() const;
    void set_index(Opnd);
    Opnd get_scale() const;
    void set_scale(Opnd);
    Opnd get_disp() const;
    void set_disp(Opnd);
};

bool is_base_index_scale_disp(Opnd);
</pre><p>


<h3><a name=toc45>Class <code>OpndCatalog</code></a></h3>
<a name="sec:OpndCatalog"><b>[*]</b></a>
<p>
It is often useful in program analysis and optimization to map operands to
a dense range of natural numbers.  Class <code>OpndCatalog</code> is an abstract
interface for such a map.  For different problems, it is realized by
different concrete subclasses.  In bit-vector data-flow problems, the
numbers assigned to operands are often called <em>slots</em>, meaning
positions in the bit vectors.  Here we'll call them <em>indices</em>.
<p>
<a name="NWDY">Every </a><code>OpndCatalog</code> maps operands to integer indices, but not every one
has to store the inverse map, which gives the operand corresponding to an
index.  The decision whether to record the inverse map is made when the
catalog object is constructed.  One benefit of keeping the inverses is that
they allow the catalog's contents to be printed.  So even when a particular
optimization algorithm doesn't need the inverse map, its implementation may
save it anyway during debugging, in order to activate the catalog's
<code>print</code> method.
<p>
<pre><a name="NW4F8FIv-3yWECu-1" href="#NWDY"><dfn>&lt;class <code>OpndCatalog</code>&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
class OpndCatalog {
  public:
    virtual ~OpndCatalog();

    virtual int size() const = 0;
            int num_slots() const { return size(); }    // deprecated

    virtual bool enroll(Opnd, int *index = NULL) = 0;
    virtual bool lookup(Opnd, int *index = NULL) const = 0;

    virtual void print(FILE* = stdout) const;
    virtual Opnd inverse(int index) const;

<a name="NW4F8FIv-3yWECu-1-u1" href="#NWDc"><i>&lt;<code>OpndCatalog</code> protected parts&gt;</i></a>
};
</pre><p>

Here's what the above methods do.
<p>
<table><!-- alignment is l@{\hspace*{2em}}p{.7\linewidth}--><!-- 2 columns--><tr><td align=left valign=top><code>size()</code>              </td><td align=left valign=top>Returns the total number of indices allocated so
far for all enrolled operands. </td></tr>
<tr><td align=left valign=top><code>num_slots()</code>         </td><td align=left valign=top>A deprecated synonym for <code>size()</code>. </td></tr>
<tr><td align=left valign=top><tt>enroll(<i>o</i>, <i>i</i>)</tt>  </td><td align=left valign=top>Tries to put operand <i>o</i> under management.  Returns
<code>true</code> exactly when <i>o</i> has not been
enrolled before and is entered successfully
(not filtered out).  In addition, the optional
index pointer <i>i</i> serves as an output
variable.  If <i>i</i> is non-null, the index
for operand <i>o</i> (if it has one) is stored
in the location that <i>i</i> points to.  This
return of <i>o</i>'s index via <i>i</i>
occurs whether <i>o</i> is newly enrolled or was in
the catalog previously. </td></tr>
<tr><td align=left valign=top><tt>lookup(<i>o</i>, <i>i</i>)</tt>  </td><td align=left valign=top>Returns <code>true</code> if operand <i>o</i> already in the
catalog.  In that case, and if the optional
index pointer <i>i</i> is non-null, the index
for <i>o</i> is stored into the location <i>i</i>
points to.  Never makes a new entry in the
catalog. </td></tr>
<tr><td align=left valign=top><code>inverse(</code><i>i</i><code>)</code>    </td><td align=left valign=top>If the catalog holds the optional inverse map of
indices to operands, <code>inverse</code> returns the operand
associated with index <i>i</i>, which must be less
than the number of operands enrolled.  Otherwise,
it returns a null operand. </td></tr>
<tr><td align=left valign=top><code>print(</code><i>s</i><code>)</code>      </td><td align=left valign=top>If the catalog records the inverse map of operands
<a name="NWDZ">enrolled, </a><code>print</code> lists each member in order of
entry on the output stream <i>s</i>, preceded by the
index assigned to it.
</td></tr></table>
<p>

<h3><a name=toc46><code>Opnd</code> implementation</a></h3>
<a name="sec:opnd-implementation"><b>[*]</b></a>
<p>
<pre><a name="NW4F8FIv-SgGw0-1" href="#NWDZ"><dfn>&lt;<code>Opnd</code> definition&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
class Opnd {
  public:
    Opnd();
    Opnd(const Opnd &amp;other) { o = other.o; }
    Opnd(IrOpnd *other_o) { o = other_o; }
    Opnd &amp; operator=(const Opnd &amp;other) { o = other.o; return *this; }
    ~Opnd() { }

    bool operator==(const Opnd &amp;other) const;
    bool operator!=(const Opnd &amp;other) const { return !(*this == other); }

    operator IrOpnd*() { return o; }
    operator bool();

  protected:
    IrOpnd *o;
};
</pre><p>

<a name="NWDa">Type </a><code>OpndHandle</code> is used for scanning the <code>srcs</code> field of an address
expression.  The implementation of this field has type
<code>suif_vector&lt;IrOpnd&gt;</code>.  Therefore, <code>OpndHandle</code> is an alias for the
iterator type associated with this sequence type.
<p>
<pre><a name="NW4F8FIv-3nA4Ky-1" href="#NWDa"><dfn>&lt;<code>OpndHandle</code> definition&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
typedef suif_vector&lt;IrOpnd*&gt;::iterator OpndHandle;
</pre><p>


<h5><a name=toc47><a name="NWDb">Current optimization unit.</a></a></h5>
To be able to record operands in the appropriate symbol table and to manage
virtual register numbers, we need to focus on the current optimization unit
when its processing starts and to defocus when it ends.
<p>
<pre><a name="NW4F8FIv-2xuQA5-1" href="#NWDb"><dfn>&lt;focus functions&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
void focus(FileBlock*);
void focus(OptUnit*);

void defocus(OptUnit*);
</pre><p>

<pre><a name="NW4F8FIv-1e7pV1-1" href="#NW4F8FIv-1e7pV1-1"><dfn>&lt;scope management&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
extern FileBlock *the_file_block;
extern ScopeTable *the_file_scope;

extern OptUnit *the_local_unit;
extern ScopeTable *the_local_scope;
</pre><p>

<pre><a name="NW4F8FIv-1BNo5Y-1" href="#NW4F8FIv-1BNo5Y-1"><dfn>&lt;virtual-register management&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
extern int the_vr_count;

int next_vr_number();
</pre><p>


<h5><a name=toc48>Partial implementation of <code>OpndCatalog</code>.</a></h5>
<p>
Since <code>OpndCatalog</code> is an interface, meant to be subclassed, it has no
public constructor.  Its protected constructor takes an option Boolean
argument <code>record</code> that, when explicitly set to <code>true</code>, causes the
catalog to remember the inverse map from indices to operands.  This map is
<a name="NWDc">represented as a pointer to a vector.  The pointer is </a><code>NULL</code> when the
inverse map is not saved.  A second optional argument is just for
efficiency when the map is recorded.  It specifies the initial capacity of
the vector (i.e., space for elements that will be appended to it later).
<p>
The protected <code>enroll_inverse</code> method is invoked by the implementation
of <code>enroll</code> when a new association is being added to the catalog.  It
takes care of recording the inverse map, if one is being kept.
<p>
<pre><a name="NW4F8FIv-2CvD7m-1" href="#NWDc"><dfn>&lt;<code>OpndCatalog</code> protected parts&gt;=</dfn></a> <b>(<a href="#NWDY">&lt;-U</a>)</b>
    protected:
      OpndCatalog(bool record = false, unsigned roll_reserve = 100);

      void enroll_inverse(unsigned index, Opnd);

    private:
      Vector&lt;Opnd&gt; *roll;
</pre><p>


<h5><a name=toc49><a name="NWDd">Assess storage consumption by operand objects.</a></a></h5>
<p>
<pre><a name="NW4F8FIv-1EGutX-1" href="#NWDd"><dfn>&lt;storage measurement&gt;=</dfn></a> <b>(<a href="#NWDe">U-&gt;</a>)</b>
void audit_opnds(FILE*, const char *heading);
</pre><p>


<h3><a name=toc50><a name="NWDe">Header file </a><code>opnd.h</code></a></h3>
<p>
The header file for operands has the following outline:
<p>
<pre><a name="NW4F8FIv-3ZFVDZ-1" href="#NWDe"><dfn>&lt;machine/opnd.h&gt;=</dfn></a>
/* file &quot;machine/opnd.h&quot; */

<a name="NW4F8FIv-3ZFVDZ-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_OPND_H
#define MACHINE_OPND_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/opnd.h&quot;
#endif

#include &lt;machine/substrate.h&gt;

class IrOpnd;

namespace opnd {

enum { NONE,
       REG_HARD,
       REG_VIRTUAL,
       VAR,
       IMMED_INTEGER,
       IMMED_STRING,
       ADDR_SYM,
       SYM_DISP,
       INDEX_SYM_DISP,
       BASE_DISP,
       BASE_INDEX,
       BASE_INDEX_DISP,
       INDEX_SCALE_DISP,
       BASE_INDEX_SCALE_DISP,
};

} // namespace opnd

#define LAST_OPND_KIND opnd::BASE_INDEX_SCALE_DISP

<a name="NW4F8FIv-3ZFVDZ-1-u2" href="#NWDa"><i>&lt;<code>OpndHandle</code> definition&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u3" href="#NWDZ"><i>&lt;<code>Opnd</code> definition&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u4" href="#NWDD"><i>&lt;<code>Opnd</code> common functions&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u5" href="#NWDI"><i>&lt;null-operand functions&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u6" href="#NWDJ"><i>&lt;variable-symbol-operand functions&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u7" href="#NWDK"><i>&lt;register-operand functions&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u8" href="#NWDL"><i>&lt;immediate-operand functions&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u9" href="#NWDM"><i>&lt;address-operand functions&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u10" href="#NWDO"><i>&lt;address-symbol-operand functions&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u11" href="#NWDP"><i>&lt;address-expression-operand functions&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u12" href="#NWDQ"><i>&lt;class <code>AddrExpOpnd</code>&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u13" href="#NWDR"><i>&lt;class <code>SymDispOpnd</code>&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u14" href="#NWDS"><i>&lt;class <code>IndexSymDispOpnd</code>&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u15" href="#NWDT"><i>&lt;class <code>BaseDispOpnd</code>&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u16" href="#NWDU"><i>&lt;class <code>BaseIndexOpnd</code>&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u17" href="#NWDV"><i>&lt;class <code>BaseIndexDispOpnd</code>&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u18" href="#NWDW"><i>&lt;class <code>IndexScaleDispOpnd</code>&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u19" href="#NWDX"><i>&lt;class <code>BaseIndexScaleDispOpnd</code>&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u20" href="#NWDb"><i>&lt;focus functions&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u21" href="#NW4F8FIv-1e7pV1-1"><i>&lt;scope management&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u22" href="#NWDd"><i>&lt;storage measurement&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u23" href="#NW4F8FIv-1BNo5Y-1"><i>&lt;virtual-register management&gt;</i></a>

<a name="NW4F8FIv-3ZFVDZ-1-u24" href="#NWDY"><i>&lt;class <code>OpndCatalog</code>&gt;</i></a>

#endif /* MACHINE_OPND_H */
</pre><p>
<h2><a name=toc51>Types</a></h2>
<a name="sec:types"><b>[*]</b></a>
<p>

The parlance of compiler infrastructure overloads a number of terms, such
as ``type'', ``variable'', and ``procedure'', which makes it difficult to
talk clearly about the implementation of a system like Machine SUIF.  When
we say ``OPI type'' or ``SUIF type'' or ``C++ type'', we are talking about
artifacts of our compiler's implementation.  But often we use ``type'' to
mean either a property of the program being compiled, or the object in the
compiler that represents that property.  As the length of the preceding
sentence indicates, we don't have nice crisp terminology for the latter
type of types, except to call them ``source types'', which isn't great.
It might work to say ``type object'' when referring to elements of the
infrastructure that represent types in the program being compiled, but the
OPI attempts to make a distinction between IR objects, which are accessed
indirectly via explicity pointers, and potentially lighter-weight things
like operands and types, which might not need to involve pointers.
<p>
The OPI uses the term <em>type identifier</em> (and the name <code>TypeId</code>) for
this lightweight type representation.
<p>



The SUIF system provides us with a rich type system.  As much as
possible, we attempt to maintain type information when converting from
a SUIF IR to the Machine-SUIF IR and when performing optimizations in
Machine SUIF.  Often, however, we are interested only in some simple
type information.  For these times, we provide several predefined
type variables for your use.
<p>
The first set of predefined type variables are those that are target
independent.  We declare these type variables in
<code><a href="#NWDf"><i>&lt;target-independent types&gt;</i></a></code>.  Each of these types is aligned.
<p>
<ul>

<li><code>type_v0</code> describes a void value of size 0 bits.
<p>
<li><code>type_s8</code>, <code>type_s16</code>, <code>type_s32</code>, and <code>type_s64</code>
describe aligned, signed integers of the specified bit sizes.
<p>
<li><code>type_u8</code>, <code>type_u16</code>, <code>type_u32</code>, and <code>type_u64</code>
describe aligned, unsigned integers of the specified bit sizes.
<p>
<li><code>type_f32</code>, <code>type_f64</code>, and <code>type_f128</code> describe
aligned, floating-point values of the specified bit sizes.
<p>
</ul>

The second set are type objects whose definitions depend upon a specific
target machine.
<p>
<ul>

<li><code>type_addr</code> is a function that returns the type ``pointer to
<code>type_v0</code>''.  The size of this type depends upon the target.  This occurs
so frequently in code, that we define the macro <code>type_ptr</code> to be
equivalent to <code>type_addr()</code>.  As mentioned earlier, this is the type that
we use as the type of an address expression.
<p>
</ul>

<h5><a name=toc52><a name="NWDf">Target-independent type objects.</a></a></h5>
<p>
The following are predefined type variables that are globally available
to any Machine-SUIF pass. These target-independent types are aligned.
They are initialized in <code>machine/init.cc</code>.
<p>
<pre><a name="NW1QkAC9-3S2KyS-1" href="#NWDf"><dfn>&lt;target-independent types&gt;=</dfn></a> <b>(<a href="#NWDh">U-&gt;</a>)</b>
extern TypeId type_v0;  // void
extern TypeId type_s8;  // signed ints
extern TypeId type_s16;
extern TypeId type_s32;
extern TypeId type_s64;
extern TypeId type_u8;  // unsigned ints 
extern TypeId type_u16;
extern TypeId type_u32;
extern TypeId type_u64;
extern TypeId type_f32; // floats
extern TypeId type_f64;
extern TypeId type_f128;
extern TypeId type_p32; // pointers
extern TypeId type_p64;

void attach_opi_predefined_types(FileSetBlock*);
void set_opi_predefined_types(FileSetBlock*);
</pre><p>

Function <code>set_opi_predefined_types</code> fills in the target-independent
types, which it obtains from the <code>generic_types</code> annotation of a
<code>file_set_block</code>.  This note is created once at the time the Machine-SUIF
representation of a file set is first created (by function
<code>attach_opi_predefined_types</code>), and it is carried along
as the file set is transformed.  Using this note is an efficient way
to avoid creating redundant types in a global symbol
table.
<p>
A pass typically calls <code>set_opi_predefined_types</code> during its
<code>do_file_set_block</code> method.
<p>

<h5><a name=toc53><a name="NWDg">Target-dependent type object.</a></a></h5>
<p>
For now Machine SUIF has one target-dependent type parameter, namely the
type of a generic pointer or address on the target machine.  You fetch it
from the target context by calling <code>type_addr()</code>.  To permit a uniform
style between the target-independent and the target-dependent types, we
define a macro, <code>type_ptr</code> that expands to <code>type_addr()</code>.  Thus in both
cases a reference looks like a simple constant.
<p>
<pre><a name="NW1QkAC9-31rv6l-1" href="#NWDg"><dfn>&lt;target-dependent type&gt;=</dfn></a> <b>(<a href="#NWDh">U-&gt;</a>)</b>
#define type_ptr type_addr()

TypeId type_addr();
</pre><p>

<h3><a name=toc54><a name="NWDh">Header file for module </a><code>types.h</code></a></h3>
<p>
The interface file has the following layout:
<p>
<pre><a name="NW1QkAC9-39paFx-1" href="#NWDh"><dfn>&lt;machine/types.h&gt;=</dfn></a>
/* file &quot;machine/types.h&quot; */

<a name="NW1QkAC9-39paFx-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_TYPES_H
#define MACHINE_TYPES_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/types.h&quot;
#endif

#include &lt;machine/substrate.h&gt;

<a name="NW1QkAC9-39paFx-1-u2" href="#NWDf"><i>&lt;target-independent types&gt;</i></a>

<a name="NW1QkAC9-39paFx-1-u3" href="#NWDg"><i>&lt;target-dependent type&gt;</i></a>

void fprint(FILE*, TypeId);

#endif /* MACHINE_TYPES_H */
</pre><p>
<h2><a name=toc55>Machine opcodes</a></h2>
<a name="sec:machine-opcodes"><b>[*]</b></a>
<p>
In general, a machine opcode value uniquely identifies a
particular operation on a particular machine.  On different machines,
a specific value will (most-likely) correspond to different
operations.  In other words, an opcode value does not encode any
target information beyond the target-relative operation.  You must
interpret the opcode value in the context of a particular target.  The
same interpretation rules apply for Machine-SUIF opcodes.  
<p>
<a name="NWDi">In Machine SUIF, an </a><code>opcode</code> is an integer.  When you define an
opcode for a machine instruction, you must use the opcode enumeration
appropriate for your current target.  Each target architecture defines
its own extensible opcode <code>enum</code> in an <code>opcodes.h</code> file.  All
targets of the same architecture family use the same opcode <code>enum</code>.
We provide an OPI function, called <code>target_implements</code>, that allows
you to determine if an opcode is supported on your current target.
<p>
<pre><a name="NWJafVk-42QGeM-1" href="#NWDi"><dfn>&lt;opcode OPI&gt;=</dfn></a> <b>(<a href="#NWDo">U-&gt;</a>)</b> <b>[D<a href="#NWDj">-&gt;</a>]</b>
bool target_implements(int opcode);
</pre><p>

<a name="NWDj">In Machine SUIF, an opcode has an associated </a><em>name</em>.  It is the string
by which the current target's assembler recognizes the opcode.  The
opcode-to-name mapping is one-to-many since an opcode's name may vary from
one vender-OS to another.  We provide an OPI function, called
<code>opcode_name</code>, that you can use to get an opcode's target-appropriate
name.
<p>
<pre><a name="NWJafVk-42QGeM-2" href="#NWDi"><dfn>&lt;opcode OPI&gt;+=</dfn></a> <b>(<a href="#NWDo">U-&gt;</a>)</b> <b>[<a href="#NWDi">&lt;-</a>D<a href="#NWDk">-&gt;</a>]</b>

char* opcode_name(int opcode);
</pre><p>

Given an opcode <code>enum</code>, if you know that you want to generate
SUIFvm instructions, you can write:
<p>
<pre>
    Instr *mi = new_instr_alm(d_opnd, MOV, s_opnd);
</pre>

Or, if you know that you want to generate an Alpha integer move
instruction, you can write:
<p>
<pre>
    Instr *mi = new_instr_alm(d_opnd, MOV, s_opnd);
</pre>

In general, having knowledge of an architecture's opcode <code>enum</code> is
sufficient to write a target-specific pass or function, but not very useful
for the development of parameterized passes.  To create an instruction that
is specific to a target without having to know the target at
pass-development time, the OPI provides some target-specific opcode
generators.
<p>
For example, <code>opcode_move</code> returns the move opcode appropriate for
your current target:
<p>
<pre>
    Instr *mi = new_instr_alm(d_opnd, opcode_move(d_type), s_opnd);
</pre>

<a name="NWDk">This generator is called a typed opcode generator because you must</a>
provide a type to get a type-appropriate opcode.  In other words,
<code>opcode_move</code> uses the <code>d_type</code> parameter to determine if it should
generate an integer or floating-point move opcode.  
<p>
The OPI calls for provides three typed opcode generators:
<p>
<pre><a name="NWJafVk-42QGeM-3" href="#NWDi"><dfn>&lt;opcode OPI&gt;+=</dfn></a> <b>(<a href="#NWDo">U-&gt;</a>)</b> <b>[<a href="#NWDj">&lt;-</a>D<a href="#NWDl">-&gt;</a>]</b>

int opcode_move(TypeId);
int opcode_load(TypeId);
int opcode_store(TypeId);
</pre><p>

where
<p>
<ul>
<li><code><a name="NWDl">opcode_move</a></code>: generates a type- and target-appropriate move opcode;
<li><code>opcode_load</code>: generates a type- and target-appropriate load opcode;
<li><code>opcode_store</code>: generates a type- and target-appropriate store opcode;
</ul>
<p>
and the following untyped opcode generators:
<p>
<pre><a name="NWJafVk-42QGeM-4" href="#NWDi"><dfn>&lt;opcode OPI&gt;+=</dfn></a> <b>(<a href="#NWDo">U-&gt;</a>)</b> <b>[<a href="#NWDk">&lt;-</a>D<a href="#NWDm">-&gt;</a>]</b>

int opcode_line();
int opcode_ubr();
</pre><p>

where
<p>
<ul>
<li><code><a name="NWDm">opcode_line</a></code>: generates a target-appropriate line pseudo-op opcode.
<li><code>opcode_ubr</code>: generates   a target-appropriate unconditional branch
opcode. 
</ul>
<p>
The OPI also provides the function <code>opcode_cbr_inverse</code> which takes a
conditional branch opcode and returns the opcode checking the opposite
condition.
<p>
<pre><a name="NWJafVk-42QGeM-5" href="#NWDi"><dfn>&lt;opcode OPI&gt;+=</dfn></a> <b>(<a href="#NWDo">U-&gt;</a>)</b> <b>[<a href="#NWDl">&lt;-</a>D<a href="#NWDn">-&gt;</a>]</b>

int opcode_cbr_inverse(int opcode);
</pre><p>

<a name="NWDn">Finally, there are two global opcodes, which are the same across all</a>
architectures:
<p>
<pre><a name="NWJafVk-42QGeM-6" href="#NWDi"><dfn>&lt;opcode OPI&gt;+=</dfn></a> <b>(<a href="#NWDo">U-&gt;</a>)</b> <b>[<a href="#NWDm">&lt;-</a>D]</b>

const int opcode_null = 0;
const int opcode_label = 1;
</pre><p>

Since these are considered part of each architecture's opcode space, the
first target-specific opcode in each opcode <code>enum</code> should start with
value 2.
<p>
<!--%  FIXME: describe handling of opcode extensions-->



<h3><a name=toc56><a name="NWDo">Header file for module </a><code>opcodes.h</code></a></h3>
<p>
The interface file has the following layout:
<p>
<pre><a name="NWJafVk-158il9-1" href="#NWDo"><dfn>&lt;machine/opcodes.h&gt;=</dfn></a>
/* file &quot;machine/opcodes.h&quot; */

<a name="NWJafVk-158il9-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_OPCODES_H
#define MACHINE_OPCODES_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/opcodes.h&quot;
#endif

#include &lt;machine/substrate.h&gt;

<a name="NWJafVk-158il9-1-u2" href="#NWDi"><i>&lt;opcode OPI&gt;</i></a>

int opcode_from_name(const char *name);

#endif /* MACHINE_OPCODES_H */
</pre><p>
<h2><a name=toc57>Register Descriptions</a></h2>
<a name="sec-reg-desc"><b>[*]</b></a>
<p>
A Machine SUIF register allocator should be coded without hard-wiring the
particulars of any target machine, but it nevertheless needs a way to
access information about the target's registers.  This section gives the
register-description interface that you must implement when developing a
target library.  Its purpose is to enumerate the hardware registers, and
for those that are subject to register allocation, to classify them
according to the different purposes they serve in the instruction-set
architecture.
<p>
A register <em>class</em> is a set of registers that are equally suitable for
playing a particular role in programs of the target machine.  For example,
the set of registers that can be operands of an integer <code>add</code> instruction
comprise a register class.  The members of a class are interchangeable:
whenever one of them is playing the role for which the class is defined
(e.g., the <code>add</code>-operand role), then it is legal to use any other member
of the class in its place.  Usually, the same register class is associated
with many related instructions, e.g., the full set of integer arithmetic
and logical instructions.  But this is not always the case.  The Motorola
68000, for instance, has a class of address registers for addressing memory
and a class of data registers for doing certain integer computations.  A
data register can't be the base register for a load instruction, and an
address register can't be the operand of a multiply instruction, so there
are disjoint classes for those distinct roles.  However, the add
instruction can operate on either an address register or a data register,
so the machine has a third register class that is the union of the other
two.
<p>
The register-description interface doesn't involve a C++ class of its own.
It is made up of functions, all of whose names begin with <code>reg_</code>.  These
correspond to virtual methods in the context interface of the <code>machine</code>
library, i.e., in class <code>MachineContext</code> (see Section&nbsp;<a href="#sec:Contexts">[-&gt;]</a>).
The target library provides implementations for those methods.
<p>
<h3><a name=toc58>Enumerating hardware registers</a></h3>
<p>
A register is identified by a non-negative integer whose particular value
is only meaningful within the target library.
<p>
<ul>
<li><code>reg_count</code> returns the number of registers in the target.  Every
register identifier must be less than this number.
<p>
<li><code>reg_name</code> returns the name of the register designated by its
argument.  The is the form that the target assembler expects to see.
<p>
<li><code>reg_width</code> returns the size in bits of the designated register.
<p>
<li><code>reg_maximal</code>, returns the maximal-width register that subsumes the
register given as its argument.
<!--%  FIXME: remove this and implement it via <code>reg_width</code> and <code>reg_aliases</code>?-->
<p>
<li><code>reg_aliases</code> returns the set of registers that overlap the
designated register in whole or in part, including the register
itself.  Register <i>x</i> is in <code>reg_aliases(</code><i>y</i><code>)</code> if and only if
writing a value into <i>y</i> can affect the value in <i>x</i>.
<p>
<li><code>reg_allocables</code> returns the set of identifiers for all
registers that are available for register allocation.  When called
with its optional argument <code>true</code>, it returns the subset that have
maximal width. 
<p>
<li><code>reg_caller_saves</code> returns the subset of allocable registers that
obey a <em>caller-saves</em> convention, i.e., that need not be preserved
by a called procedure.  With optional argument <code>true</code>,
it returns only the maximal-width caller-saves registers.
<p>
<li><code><a name="NWDp">reg_callee_saves</a></code> returns the subset of allocable registers that
obey a <em>callee-saves</em> convention, i.e., that must be restored by
a called procedure if it changes them.  With optional argument <code>true</code>,
it returns only the maximal-width callee-saves registers.
<p>
<li><code>reg_info_print</code> prints a description of the registers of the
current target.
</ul>
<p>
<pre><a name="NW4EAdeC-4YCmFx-1" href="#NWDp"><dfn>&lt;register description functions&gt;=</dfn></a> <b>(<a href="#NWDx">U-&gt;</a>)</b>
int reg_count();
const char* reg_name(int reg);
int reg_width(int reg);
int reg_maximal(int reg);
const NatSet* reg_aliases(int reg);
const NatSet* reg_allocables(bool maximals = false);
const NatSet* reg_caller_saves(bool maximals = false);
const NatSet* reg_callee_saves(bool maximals = false);

void reg_info_print(FILE*);
</pre><p>

<h3><a name=toc59><a name="NWDq">Enumerating register classes</a></a></h3>
<p>
Every register class is also identified by a non-negative integer that we
call the class <em>identifier</em>.
<p>
<pre><a name="NW4EAdeC-2jzEM0-1" href="#NWDq"><dfn>&lt;type <code>RegClassId</code>&gt;=</dfn></a> <b>(<a href="#NWDx">U-&gt;</a>)</b>
typedef int RegClassId;
</pre><p>

<a name="NWDr">The set of classes must be closed under intersection: if two classes have</a>
one or more members in common, then their intersection must also be a class
that is identified in this machine description.  The intersection function
recognizes two distinguished class-identifier values.  <code>REG_CLASS_ANY</code> is
the identity element for class intersection, and <code>REG_CLASS_NONE</code> is the
zero element.
<p>
<pre><a name="NW4EAdeC-3nvnr1-1" href="#NWDr"><dfn>&lt;distinguished class identifiers&gt;=</dfn></a> <b>(<a href="#NWDx">U-&gt;</a>)</b>
const RegClassId REG_CLASS_ANY  = -1;   // universal class
const RegClassId REG_CLASS_NONE = -2;   // empty class
</pre><p>

The following functions describe register classes and their relationships.
<p>
<ul>
<li><code>reg_class_count</code> returns the number of classes.  Every class
identifier must be less than this number.
<p>
<li><code>reg_members</code> returns a set of register numbers for the members of
<a name="NWDs">the designated register class.</a>
<p>
<li><code>reg_class_intersection</code> returns the identifier of the class that
is the intersection of its two argument classes.  If one argument is
<code>REG_CLASS_ANY</code>, it returns the other argument.  If the
intersection is empty, it returns <code>REG_CLASS_NONE</code>.
</ul>
<p>

<pre><a name="NW4EAdeC-3UC4Pz-1" href="#NWDs"><dfn>&lt;register class description functions&gt;=</dfn></a> <b>(<a href="#NWDx">U-&gt;</a>)</b>
int reg_class_count();
const NatSet* reg_members(RegClassId);
RegClassId reg_class_intersection(RegClassId, RegClassId);
</pre><p>


<h3><a name=toc60>Supporting register allocation</a></h3>
<p>
<h5><a name=toc61>Classification.</a></h5>
A register allocator needs a way to classify the register-candidate
operands of an instruction in order to decide what registers can legally be
assigned to each candidate.  That is, it wants a map from operands to
register-class identifiers that tells it what role each register operand is
<a name="NWDt">playing.  For example, the  effective-address operand of a Motorola 68000</a>
load instruction might be a register candidate.  The class map would show
that operand's class to be the address-register class.
<p>
Instead of mapping directly from operands to class identifiers, the class
map is keyed on the operand indices assigned by an operand catalog (see
Section&nbsp;<a href="#sec:OpndCatalog">[&lt;-]</a>).  So it is just a vector of class
identifiers, indexed by operand number.
<p>
<pre><a name="NW4EAdeC-vMoW7-1" href="#NWDt"><dfn>&lt;type <code>RegClassMap</code>&gt;=</dfn></a> <b>(<a href="#NWDx">U-&gt;</a>)</b>
typedef Vector&lt;RegClassId&gt; RegClassMap;
</pre><p>

A register candidate normally appears in more than one instruction, and its
class should reflect the most constrained role that it plays.  In other
words, it is the intersection of the classes ascribed to it in the various
places where it appears.  The process of classification therefore starts by
intializing every element of the class map to <code>REG_CLASS_ANY</code>, and at
each occurrence of a candidate operand, the corresponding map entry is
replaced by the intersection of its current value and the class determined
by the use of the operand.  When the classification id finished, every
map entry for a register candidate should neither be the empty class nor
<a name="NWDu">the original universal class.</a>
<p>
<ul>
<li><code>reg_classify</code> scans the operands of an instruction, using an
operand catalog to obtain an integer index for each register
candidate.  It updates a class map that gives the feasible register
classes for each operand.
</ul>
<p>
<pre><a name="NW4EAdeC-ttVTX-1" href="#NWDu"><dfn>&lt;allocator support functions&gt;=</dfn></a> <b>(<a href="#NWDx">U-&gt;</a>)</b> <b>[D<a href="#NWDv">-&gt;</a>]</b>
void reg_classify(Instr*, OpndCatalog*, RegClassMap*);
</pre><p>


<h5><a name=toc62>Selection.</a></h5>
The allocator also needs an efficient method for selecting one register
from the class of a candidate while observing some extra constraints on the
choice.  One kind of constraint is that the register must come from the
pool of caller-saves or callee-saves registers.  Another is that it cannot
already have been assigned to a conflicting candidate.  The final kind of
constraint is that the register should if possible be the same as registers
chosen previously, or perhaps, on the contrary, it should be different from
registers chosen recently.  To understand this seemingly quirky final
constraint, realize that the allocator wants to assign as few callee-saves
registers as it can get away with, since they entail some overhead.  On the
other hand, it is sometimes best to cycle through all of the caller-saves
registers before assigning any one a second time.  This helps minimize
anti-dependences that thwart instruction scheduling, for instance.
<p>
<ul>
<li><code><a name="NWDv">reg_choice</a></code> tries to select one register from a given class that
is also a member of a register pool, and that is not in a set of
excluded registers.  Its final argument is a flag <code>rotate</code> indicating
whether successive choices satisfying similar criteria should
cycle through the feasible values or should be confined to as small
a collection as possible.  Returns a negative result if there is no
register satisfying all the constraints.
</ul>
<p>
<pre><a name="NW4EAdeC-ttVTX-2" href="#NWDu"><dfn>&lt;allocator support functions&gt;+=</dfn></a> <b>(<a href="#NWDx">U-&gt;</a>)</b> <b>[<a href="#NWDu">&lt;-</a>D<a href="#NWDw">-&gt;</a>]</b>
int reg_choice(RegClassId, const NatSet *pool, const NatSet *excluded,
               bool rotate);
</pre><p>

<h5><a name=toc63>Spilling.</a></h5>
The register allocator must be able to insert <em>spillcode</em>, i.e.,
instructions that move a value from a register to a memory location
(``spilling'') or from memory to register (``filling'').  For many targets,
a single store instruction is sufficient for spilling and likewise a single
load will fill.  The freedom to insert more than one instruction might be
needed when it takes a separate instruction to sign-extend a value after
loading it.  And on some targets (such as Itanium) there are register files
(e.g., branch registers) for which the ISA provides no direct load/store
instructions.
<p>
The OPI functions <code>reg_spill</code> and <code>reg_fill</code> allow you to define
target-specific spill-code injectors.  It is usually acceptable for these
functions to introduce new virtual registers, which the allocator
recognizes as additional register candidates.  Sometimes an allocator must
call <code>reg_spill</code> or <code>reg_fill</code> after register assignments have all been
made.  In that case, it passes a flag (<code>post_reg_alloc</code>) indicating that
no new register candidates may be mentioned in the inserted code.
<p>
<ul>
<li><code>reg_spill</code> inserts a sequence of instructions after <code>marker</code>
whose effect is to store a spilled value from <code>src</code> (a register) to
<code>dst</code> (a memory address).  It returns the handle of the last
instruction inserted.  When the optional argument <code>post_reg_alloc</code>
is true, the inserted sequence is not allowed to introduce register
candidates, such as virtual registers.
<p>
<li><code>reg_fill</code> inserts a sequence of instructions before <code>marker</code>
whose effect is to load a spilled value from <code>src</code> (a memory
address) to <code>dst</code> (a register).  It returns the handle of the first
instruction inserted.  When the optional argument <code>post_reg_alloc</code>
<a name="NWDw">is true, the inserted sequence is not allowed to introduce register</a>
candidates, such as virtual registers.
</ul>
<p>
When implementing either of these functions for a particular target, you
should assume that the <code>marker</code> argument refers to an instruction that is
part of a <code>CfgNode</code> object.<b>[cite&nbsp;<a href="#NWcite-bibcfg">bibcfg</a>]</b>  You can reach that CFG node
using the <code>get_parent_node</code> function provided in the CFG library.
<p>
<pre><a name="NW4EAdeC-ttVTX-3" href="#NWDu"><dfn>&lt;allocator support functions&gt;+=</dfn></a> <b>(<a href="#NWDx">U-&gt;</a>)</b> <b>[<a href="#NWDv">&lt;-</a>D]</b>

InstrHandle reg_fill (Opnd dst, Opnd src, InstrHandle marker,
                      bool post_reg_alloc = false);
InstrHandle reg_spill(Opnd dst, Opnd src, InstrHandle marker,
                      bool post_reg_alloc = false);
</pre><p>


<h3><a name=toc64>Upgrading from the earlier register-description interface</a></h3>
<p>
Prior to version <code>2.02.07.15</code>, Machine SUIF used a different
register-description interface.  We believe the changes justify the
nuisance for authors of existing target libraries by making the interface
easier to explain and to use.
<p>
In the old scheme, you identified register classes like those described
above, but you never got to say explicitly which registers belonged to each
class.  In the new version, you simply generate sets representing the
membership of each class (<code>reg_members</code>).
<p>
In the old scheme, the alias relationships between registers had to be
expressed via ``models'' representing register resources that might or
might not correspond to architecural registers.  In the new version, you
just list for each register the other registers with which it has some
overlap  (<code>reg_aliases</code>).
<p>
The old scheme had vector-valued functions like <code>reg_names</code>.  To get the
name of a register, one called <code>reg_names</code> to get a vector and then used
the register number to lookup the name in the vector.  This arrangement was
intended to make repeated lookups more efficient, since the vector could be
saved and reused.  In the new register-description interface, we eliminated
<a name="NWDx">the extra level of indirection, replacing </a><code>reg_names</code> with the more
direct <code>reg_name</code> function.  On the rare occasions when caching is
warranted, it is easy enough to implement.
<p>

<h3><a name=toc65>Header file for module <code>reg_info.h</code></a></h3>
<p>
The interface file has the following layout:
<p>
<pre><a name="NW4EAdeC-32alUa-1" href="#NWDx"><dfn>&lt;machine/reg_info.h&gt;=</dfn></a>
/* file &quot;machine/reg_info.h&quot; */

<a name="NW4EAdeC-32alUa-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_REG_INFO_H
#define MACHINE_REG_INFO_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/reg_info.h&quot;
#endif

#include &lt;machine/substrate.h&gt;
#include &lt;machine/machine_ir.h&gt;
#include &lt;machine/nat_set.h&gt;
#include &lt;machine/opnd.h&gt;

<a name="NW4EAdeC-32alUa-1-u2" href="#NWDq"><i>&lt;type <code>RegClassId</code>&gt;</i></a>

<a name="NW4EAdeC-32alUa-1-u3" href="#NWDt"><i>&lt;type <code>RegClassMap</code>&gt;</i></a>

<a name="NW4EAdeC-32alUa-1-u4" href="#NWDp"><i>&lt;register description functions&gt;</i></a>

<a name="NW4EAdeC-32alUa-1-u5" href="#NWDr"><i>&lt;distinguished class identifiers&gt;</i></a>

<a name="NW4EAdeC-32alUa-1-u6" href="#NWDs"><i>&lt;register class description functions&gt;</i></a>

<a name="NW4EAdeC-32alUa-1-u7" href="#NWDu"><i>&lt;allocator support functions&gt;</i></a>

extern int reg_lookup(const char *name);


#endif /* MACHINE_REG_INFO_H */
</pre><p>
<hr><a name="NWDy">*</a>
<h2><a name=toc66>Assembly-Language Printing</a></h2>
<a name="sec:printer"><b>[*]</b></a>
<p>
Class <code>Printer</code> controls printing of Machine-SUIF intermediate files
to assembly language.  Its virtual methods are hooks that allow
target-specific subclasses to customize printing according to the
syntax expected by the assembler for the target system.
<p>
<h3><a name=toc67><a name="NWDz">Class </a><code>Printer</code></a></h3>
<p>
<h5><a name=toc68>Interface.</a></h5>
<p>
<code>Printer</code> is an abstract class.  You only construct <code>Printer</code> objects
for specific targets, for which there are corresponding <code>Printer</code>
subclasses.
<p>
<pre><a name="NW48Cng4-1cktZp-1" href="#NWDz"><dfn>&lt;class <code>Printer</code>&gt;=</dfn></a> <b>(<a href="#NWD12">U-&gt;</a>)</b>
class Printer {
  public:
    virtual ~Printer() { }

    FILE* get_file_ptr() const { return out; }
    void set_file_ptr(FILE* the_file_ptr) { out = the_file_ptr; }

    int  get_Gnum() const { return Gnum; }
    void set_Gnum(int n) { Gnum = n; }

    bool get_omit_unwanted_notes() const { return !omit_unwanted_notes; }
    void set_omit_unwanted_notes(bool omit) { omit_unwanted_notes = omit; }

    virtual void print_notes(FileBlock*);
    virtual void print_notes(Instr*);

    virtual void start_comment() = 0;

    virtual void print_instr(Instr *mi) = 0;
    virtual void print_opnd(Opnd o) = 0;

    virtual void print_extern_decl(VarSym *v) = 0;
    virtual void print_file_decl(int fnum, IdString fnam) = 0;

    virtual void print_sym(Sym *s);
    virtual void print_var_def(VarSym *v) = 0;

    virtual void print_global_decl(FileBlock *fb) = 0;
    virtual void print_proc_decl(ProcSym *p) = 0;
    virtual void print_proc_begin(ProcDef *pd) = 0;
    virtual void print_proc_entry(ProcDef *pd, int file_no_for_1st_line) = 0;
    virtual void print_proc_end(ProcDef *pd) = 0;

<a name="NW48Cng4-1cktZp-1-u1" href="#NWD10"><i>&lt;<code>Printer</code> protected part&gt;</i></a>
};
</pre><p>

Notes on the public methods:
<p>
<ul>
<li><code>get_file_ptr</code> and <code>set_file_ptr</code> fetch and store the
output stream (<code>FILE*</code>) for the assembly file being generated.
<li><code>get_Gnum</code> and <code>set_Gnum</code> fetch and store the size threshold (in
bytes) at which an initialized value begins to be considered
``large''.  Some targets put small static data in a different
object-file section from large data.
<li><code>get_omit_unwanted_notes</code> and <code>set_omit_unwanted_notes</code>  control
whether annotation printing is selective.  Normally, annotations on
instructions are printed as comments in the assembly file, but those
whose keys are in the set <code>nonprinting_notes</code> are skipped.  By
calling <code>set_omit_unwanted_notes</code> with argument <code>false</code>, 
you turn off selective printing, so that all annotations appear.
<li><code>print_notes</code> prints the annotations on the object to which it it
applied.  Global annotations such as those recording the history of a
file's compilation are attached to the <code>FileBlock</code> object.  Local
annotations are attached to individual instructions.  Separate
overloading of <code>print_notes</code> lets you control these cases separately.
<li><code>start_comment</code> is called to print the opening string of an
assembly-language ``line'' comment, i.e., one that is implicitly
terminated by the next end-of-line.
<li><code>print_instr</code> and <code>print_opnd</code> are the workhorse methods.  They
are called to print each instruction and each operand, respectively.
<li><code>print_extern_decl</code> prints the directive that tells the assembler a
symbol is externally defined, i.e., that its definition cannot be
seen until link time.
<li><code>print_file_decl</code> is called to print a directive identifying one of
the source files contributing to the current object file.  Its
arguments are the number and the name of a source file.  (The
numbering gives the order of the files' appearance.  For an obscure
reason, it starts at 2.)
<li><code>print_sym</code> prints a symbol reference.  The default implementation
distinguishes between global and local symbols.  For those local to a
procedure, it prepends the procedure name and a separating dot
(<code>.</code>).  Names of global symbols are printed without adornment.
<li><code>print_var_def</code> prints the definition of a non-automatic variable,
which may or may not have an initializer.
<li><code>print_global_decl</code> is a hook for printing directives that
condition the assembly of a whole file.  For example, it may control
the level of assembler optimization.
<li><code>print_proc_decl</code> is a hook allowing predeclaration of a procedure
(<em>not</em> the procedure's definition).
<li><code>print_proc_begin</code>, <code>print_proc_entry</code> and <code>print_proc_end</code> are
hooks for the key points in the printing of a procedure's code.  The
<code>_begin</code> hook typically adjusts the object section (e.g., with a
<code>.text</code> directive) and perhaps the prevailing alignment.  The
<code>_entry</code> hook typically prints the procedure's prologue and the
<code>_end</code> hook prints its epilogue.
</ul>
<p>

<h5><a name=toc69>Specialization.</a></h5>
<p>
Each <code>Printer</code> object contains a dispatch table that maps
from an opcode to a virtual method for printing an instruction having that
opcode.  This table, called <code>print_instr_table</code>, is initialized when the
target-specific library creates an instance of its own subclass of
<code><a name="NWD10">Printer</a></code>.  The methods used as table entries correspond to the four
kinds of instruction in the Machine SUIF implementation; their names are
<code>print_instr_alm</code>, <code>print_instr_cti</code>, <code>print_instr_dot</code>, and
<code>print_instr_label</code>.  To allow for reuse of a target library by an
extender targeting the same machine, there is an extra virtual method
called <code>print_instr_user_defd</code>, which is called when an opcode lies
outside the range covered by the particular <code>Printer</code> subclass.  This can
be defined by more-derived classes to print additional instructions.
<p>
<pre><a name="NW48Cng4-4Tgxi2-1" href="#NWD10"><dfn>&lt;<code>Printer</code> protected part&gt;=</dfn></a> <b>(<a href="#NWDz">&lt;-U</a>)</b>
  protected:
    // table of Instr printing functions -- filled in by derived class
    typedef void (Printer::*print_instr_f)(Instr *);
    Vector&lt;print_instr_f&gt; print_instr_table;

    // printing functions that populate the print_instr_table
    virtual void print_instr_alm(Instr *) = 0;
    virtual void print_instr_cti(Instr *) = 0;
    virtual void print_instr_dot(Instr *) = 0;
    virtual void print_instr_label(Instr *) = 0;

    virtual void print_instr_user_defd(Instr *) = 0;

    Printer();

    // helper
    virtual void print_annote(Annote *the_annote);

    // remaining state
    FILE *out;
    int Gnum;
    bool omit_unwanted_notes;
</pre><p>

The <code>print_annote</code> protected method prints a SUIF <code>Annote</code> object,
which is expected to be a <code>BrickAnnote</code>.
<p>
<a name="NWD11">The remaining instance fields are exposed to subclass methods.  For</a>
brevity, printing methods typically use the <code>out</code> field directly.
<p>

<h5><a name=toc70>The <code>Printer</code> object for the current target.</a></h5>
<p>
To access the <code>Printer</code> object in the prevailing context, call this
function:
<p>
<pre><a name="NW48Cng4-4bgS0W-1" href="#NWD11"><dfn>&lt;function <code>target_printer</code>&gt;=</dfn></a> <b>(<a href="#NWD12">U-&gt;</a>)</b>
Printer* target_printer();
</pre><p>


<h3><a name=toc71><a name="NWD12">Header file for module </a><code>Printer.h</code></a></h3>
<p>
The interface file has the following layout:
<p>
<pre><a name="NW48Cng4-3I6VPV-1" href="#NWD12"><dfn>&lt;machine/printer.h&gt;=</dfn></a>
/* file &quot;machine/printer.h&quot; */

<a name="NW48Cng4-3I6VPV-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_PRINTER_H
#define MACHINE_PRINTER_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/printer.h&quot;
#endif

#include &lt;machine/substrate.h&gt;
#include &lt;machine/opnd.h&gt;
#include &lt;machine/machine_ir.h&gt;

<a name="NW48Cng4-3I6VPV-1-u2" href="#NWDz"><i>&lt;class <code>Printer</code>&gt;</i></a>

<a name="NW48Cng4-3I6VPV-1-u3" href="#NWD11"><i>&lt;function <code>target_printer</code>&gt;</i></a>

#endif /* MACHINE_PRINTER_H */
</pre><p>
<h2><a name=toc72>C-Language Printing</a></h2>
<p>
Class <code>CPrinter</code> is analogous to <code>Printer</code> (Section&nbsp;<a href="#sec:printer">[&lt;-]</a>),
but its role is to help generate C-language, rather than assembly-language,
output files.  The structure and many of the methods of <code>CPrinter</code> are
the same as those of <code>Printer</code>.
<p>
<h3><a name=toc73><a name="NWD13">Class </a><code>CPrinter</code></a></h3>
<a name="sec:c-printer"><b>[*]</b></a>
<p>
<h5><a name=toc74>Interface.</a></h5>
<p>
Though <code>CPrinter</code> is abstract, it has fewer methods with no default
definition than class <code>Printer</code>, since the output language is fixed.
<p>
<pre><a name="NW2CyJMi-3PagW-1" href="#NWD13"><dfn>&lt;class <code>CPrinter</code>&gt;=</dfn></a> <b>(<a href="#NWD16">U-&gt;</a>)</b>
class CPrinter {
  public:
    virtual ~CPrinter();

    void clear();
    FILE *get_file_ptr() { return out; }
    void set_file_ptr(FILE *the_file_ptr) { out = the_file_ptr; }

    bool get_omit_unwanted_notes() const { return !omit_unwanted_notes; }
    void set_omit_unwanted_notes(bool omit) { omit_unwanted_notes = omit; }

    virtual void print_notes(FileBlock*);
    virtual void print_notes(Instr*);

    virtual void print_instr(Instr *mi) = 0;
    virtual void print_opnd(Opnd o);
    virtual void print_type(TypeId t);

    virtual void print_sym(Sym *s);
    virtual void print_sym_decl(Sym *s);
    virtual void print_sym_decl(char *s, TypeId t);
    virtual void print_var_def(VarSym *v, bool no_init);

    virtual void print_global_decl(FileBlock *fb) = 0;
    virtual void print_proc_decl(ProcSym *p);
    virtual void print_proc_begin(ProcDef *pd);

<a name="NW2CyJMi-3PagW-1-u1" href="#NWD14"><i>&lt;<code>CPrinter</code> protected part&gt;</i></a>
};
</pre><p>

Notes on the public methods:
<p>
<ul>
<li><code>get_file_ptr</code> and <code>set_file_ptr</code> fetch and store the
output stream (<code>FILE*</code>) for the C file being generated.
<li><code>get_omit_unwanted_notes</code> and <code>set_omit_unwanted_notes</code>  control
whether annotation printing is selective.  Normally, annotations on
instructions are printed as comments in the output C file, but those
whose keys are in the set <code>nonprinting_notes</code> are skipped.  By
calling <code>set_omit_unwanted_notes</code> with argument <code>false</code>, 
you turn off selective printing, so that all annotations appear.
<li><code>print_notes</code> prints the annotations on the object to which it it
applied.
<li><code>print_instr</code> and <code>print_opnd</code> are called to print each
instruction and each operand, respectively.
<li><code>print_type</code> prints a C type.  It keeps track of <code>struct</code>,
<code>union</code>, and <code>enum</code> types that have already been printed and
abbreviates them to avoid illegal duplication.
<li><code>print_sym</code> prints a symbol.
<li><code>print_sym_decl</code> prints the declarator for a symbol, which includes
its name and type, but no terminating punctuation.  It is used for
formal parameters as well as global and local declarations.
<li><code>print_var_def</code> prints the defining declaration of a variable
symbol.  If the variable has an initializer and the second argument
<code>no_init</code> is not true, the initializer is included in the printed
definition.
<li><code>print_global_decl</code>, like the corresponding method of class
<code>Printer</code>, is a hook for printing things at the start of the output
file.  If the C output file needs a special <code>#include</code> directive,
it can be printed by this method.
<li><code>print_proc_decl</code> prints the declaration of a procedure, including
a terminating semi-colon and end-of-line string.
<li><code>print_proc_begin</code> prints the header of a procedure definition,
including the opening brace of its body.
</ul>
<p>

<h5><a name=toc75>Specialization.</a></h5>
<p>
Like a <code>Printer</code> object, an instance of <code>CPrinter</code> contains a dispatch
table that maps from an opcode to a virtual method for printing an
instruction that has the opcode.  This table, called <code>print_instr_table</code>,
is initialized when the target-specific library creates an instance of its
own subclass of <code>CPrinter</code>.  The methods <code>print_instr_alm</code>,
<code>print_instr_cti</code>, <code>print_instr_dot</code>, <code>print_instr_label</code>, and
<code>print_instr_user_defd</code> are used for C-language printing in a manner
that's analogous to assembly-language printing.  The main difference is
that <code>print_instr_label</code> has a definition, since label printing in C is
pretty standard.
<p>
The remaining protected methods are helpers that are exposed to the
target-library writer in case some aspect of the target requires special
treatment when translating to C.
<p>
<ul>
<li><code>print_annote</code> method prints a SUIF <code>Annote</code> object, which is
expected to be a <code>BrickAnnote</code>. 
<li><code>print_immed</code> prints an immediate operand.
<li><code>print_addr</code> prints an address expression.  Its second argument, if
non-zero, is the desired referent type; the method applies a cast if
necessary to achieve it.  The third argument is a syntactic context
indicator that helps to control parenthesization.
<li><code>print_value_block</code> is a recursive helper for <code>print_var_def</code>
that prints the initializer part of a variable definition.
<li><code>print_decl</code> is a recursive helper for printing a declarator in C's
distinctive syntax.  The structure of the declarator is described in
the second argument, which may include a symbolic identifier or may
leave it out, for printing types.
<li><code>print_pointer_cast</code> prints a cast to the pointer type that has the
argument type as its referent.
<li><code>print_type_ref</code> prints an abbreviated compond type, on the
assumption that the full definition of the type has already been seen
by the C compiler.  The second argument is one of the keywords
<code><a name="NWD14">struct</a></code>, <code>union</code>, or <code>enum</code>.
<li><code>print_group_def</code> prints the full definition of a <code>struct</code> or
<code>union</code> type.
<li><code>print_enum_def</code> prints the full definition of an <code>enum</code> type.
<li><code>print_atomic_type</code> prints a non-compound type.
<li><code>print_string_literal</code> prints a string literal suitably quoted and
with interior escapes for input to a C compiler.
</ul>
<p>
<pre><a name="NW2CyJMi-2tdcqH-1" href="#NWD14"><dfn>&lt;<code>CPrinter</code> protected part&gt;=</dfn></a> <b>(<a href="#NWD13">&lt;-U</a>)</b>
  protected:
    // table of instr printing functions -- filled in by derived class
    typedef void (CPrinter::*print_instr_f)(Instr*);
    print_instr_f *print_instr_table;

    // instr printing functions that populate the print_instr_table
    virtual void print_instr_alm(Instr*) = 0;
    virtual void print_instr_cti(Instr*) = 0;
    virtual void print_instr_dot(Instr*) = 0;
    virtual void print_instr_label(Instr*);

    virtual void print_instr_user_defd(Instr*) = 0;

    // helper methods

    virtual void print_annote(Annote*);

    virtual void print_immed(Opnd);
    virtual void print_addr(Opnd, TypeId goal = 0, int context = ANY);
    virtual void print_addr_disp(Opnd addr, Opnd disp, TypeId goal,
                                 int context, char *op);

    virtual bool process_value_block(ValueBlock*, TypeId);

    virtual void print_decl(TypeId, const Declarator&amp;);
    virtual void print_pointer_cast(TypeId referent);
    virtual bool print_type_ref(TypeId, const char *keyword);
    virtual void print_group_def(TypeId);
    virtual void print_enum_def (TypeId);
    virtual void print_atomic_type(TypeId);

    virtual void print_string_literal(IdString literal);

    CPrinter();

    FILE *out;
    bool omit_unwanted_notes;

    List&lt;TypeId&gt; noted_types;
    int next_type_tag;

    // syntactic contexts
    enum { ANY, ASSIGN, BINARY, UNARY, PRIMARY };
</pre><p>

<h5><a name=toc76><a name="NWD15">The </a><code>CPrinter</code> object for the current target.</a></h5>
<p>
To access the <code>CPrinter</code> object in the prevailing context, call this
function:
<p>
<pre><a name="NW2CyJMi-3jShyN-1" href="#NWD15"><dfn>&lt;function <code>target_c_printer</code>&gt;=</dfn></a> <b>(<a href="#NWD16">U-&gt;</a>)</b>
CPrinter* target_c_printer();
</pre><p>


<h3><a name=toc77><a name="NWD16">Header file for module </a><code>CPrinter.h</code></a></h3>
<p>
The interface file has the following layout:
<p>
<pre><a name="NW2CyJMi-4Tx1gH-1" href="#NWD16"><dfn>&lt;machine/c_printer.h&gt;=</dfn></a>
/* file &quot;machine/c_printer.h&quot; */

<a name="NW2CyJMi-4Tx1gH-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_CPRINTER_H
#define MACHINE_CPRINTER_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/cprinter.h&quot;
#endif

#include &lt;machine/substrate.h&gt;
#include &lt;machine/machine_ir.h&gt;

class Declarator;

<a name="NW2CyJMi-4Tx1gH-1-u2" href="#NWD13"><i>&lt;class <code>CPrinter</code>&gt;</i></a>

<a name="NW2CyJMi-4Tx1gH-1-u3" href="#NWD15"><i>&lt;function <code>target_c_printer</code>&gt;</i></a>

#endif /* MACHINE_CPRINTER_H */
</pre><p>
<h2><a name=toc78>Machine code finalization</a></h2>
<a name="sec:CodeFin"><b>[*]</b></a>
<p>
Code finalization is the phase of a back end that allocates space in a
procedure-activation record (usually a stack frame) and introduces certain
prologue and epilogue code that is best deferred till the very end of
compilation.  The Machine-SUIF <code>fin</code> pass is responsible for this final
translation work.  It typically takes care of adding code to save and
restore callee-saved registers, for example.  Earlier translation and
optimization passes use symbolic references to stack-frame locations and
leave it to the <code>fin</code> pass to replace these with effective-address
operands based on a stack- or frame-pointer.
<p>
This section introduces two classes used by the <code>fin</code> pass.  Class
<code>CodeFin</code> is the framework on which we hang the target-dependent aspects
of code finalization.  Its virtual methods are hooks that allow
machine-specific subclasses to customize the finalization phase.  Class
<code>StackFrameInfoNote</code> is a custom annotation class that provides a way for
earlier passes affecting the code at a procedure's entry and exits to
record their effects so that the <code>fin</code> pass knows what to do.  The key
for notes of class <code>StackFrameInfoNote</code> is <code>k_stack_frame_info</code>.
<p>

<h3><a name=toc79>Class <code>CodeFin</code></a></h3>
<p>
We present two views of the <code>CodeFin</code> class.  Readers interested in the
OPI's code finalization facilities for an existing target should read only
<a name="NWD17">the first three subsections.  The remaining subsections contain information</a>
relevant to readers interested in defining a <code>CodeFin</code> subclass for a new
target.
<p>

<h4><a name=toc80>OPI for code finalization</a></h4>
<p>
The following class defines a <code>CodeFin</code> object.
<p>
<pre><a name="NW3QGGna-aXqoF-1" href="#NWD17"><dfn>&lt;class <code>CodeFin</code>&gt;=</dfn></a> <b>(<a href="#NWD1B">U-&gt;</a>)</b>
class CodeFin {
  public:
    virtual ~CodeFin() { }

    virtual void init(OptUnit *unit);
    virtual void analyze_opnd(Opnd) = 0;
    virtual void layout_frame() = 0;
    virtual Opnd replace_opnd(Opnd) = 0;
    virtual void make_header_trailer() = 0;
    virtual void finalize() { }

    List&lt;Instr*&gt;&amp; header()  { return _header; }
    List&lt;Instr*&gt;&amp; trailer() { return _trailer; }

<a name="NW3QGGna-aXqoF-1-u1" href="#NWD1A"><i>&lt;<code>CodeFin</code> protected parts&gt;</i></a>
};
</pre><p>

A rundown of the methods declared above:
<p>
<ul>
<li><code>init</code> is called when treatment of a procedure begins.  It
initializes per-procedure variables.
<li><code>analyze_opnd</code> is called on each operand in a pre-scan of the
IR.  It can be used to detect which callee-saved registers are in use,
and to catalog local variables that need to be allocated in the
activation record.
<li><code>layout_frame</code> is the hook that performs dialect-specific layout
of the activation record.
<li><code>replace_opnd</code> is used in rewriting instructions to replace
variable occurrences by effective addresses in the frame.  Its argument
is such a variable operand, and its result is the replacement operand.
<li><code>make_header_trailer</code> is called to perform dialect-specific
creation of prologue and epilogue code sequences.  Methods <code>header</code>
and <code>trailer</code> can then retrieve the respective code sequences.
<li><code>finalize</code> is invoked just before processing of a procedure
ends.  Normally, the target library doesn't need to define this method,
<a name="NWD18">but it can be used for any final cleanup of the procedure's code.</a>
</ul>
<p>

<h4><a name=toc81>Generating a target-specific <code>CodeFin</code> object</a></h4>
<p>
To access the <code>CodeFin</code> object in the prevailing context, call this
function:
<p>
<pre><a name="NW3QGGna-2g6PKV-1" href="#NWD18"><dfn>&lt;function <code>target_code_fin</code>&gt;=</dfn></a> <b>(<a href="#NWD1B">U-&gt;</a>)</b>
CodeFin *target_code_fin();
</pre><p>


<h4><a name=toc82><a name="NWD19">Class </a><code>StackFrameInfoNote</code></a></h4>
<p>
We attach a <code>k_stack_frame_info</code> note to the body of each <code>OptUnit</code>.
This note has a custom class:
<p>
<pre><a name="NW3QGGna-3JAkoI-1" href="#NWD19"><dfn>&lt;class <code>StackFrameInfoNote</code>&gt;=</dfn></a> <b>(<a href="#NWD1B">U-&gt;</a>)</b>
class StackFrameInfoNote : public Note {
 public:
    StackFrameInfoNote() : Note(note_list_any()) { }
    StackFrameInfoNote(const StackFrameInfoNote &amp;other)
        : Note(other) { }
    StackFrameInfoNote(const Note&amp; note) : Note(note) { }

    bool get_is_leaf() const;
    void set_is_leaf(bool is_leaf);

    bool get_is_varargs() const;
    void set_is_varargs(bool is_varargs);

    int get_frame_size() const;
    void set_frame_size(int frame_size);

    int get_frame_offset() const;
    void set_frame_offset(int frame_offset);

    int get_max_arg_area() const;
    void set_max_arg_area(int max_arg_area);
};
</pre><p>

Conceptually, a <code>StackFrameInfoNote</code> instance has the following fields:
<p>
<ul>
<li><code>is_leaf</code> is <code>true</code> if this procedure does not contain any call
instructions. 
<li><code>is_varargs</code> is <code>true</code> if this procedure is a is declared with a
variable number of arguments (either through <code>varargs.h</code> or
<code>stdarg.h</code>).
<li><code>framesize</code> records the total size of the stack frame in
bytes, if known; <code>0</code> otherwise.
<li><code>frameoffset</code> records the frame offset, also in bytes.  It's
interpretation is architecture dependent.
<li><code>max_arg_area</code> records the maximum size of the call argument area
in bytes for procedures that are not leaves.
</ul>
<p>
The <code>framesize</code> and <code>frameoffset</code> cannot actually be known before the
finalization pass, so it may seem pointless to record them in an annotation
if the <code>fin</code> pass is the last to run.  Once in a while, it is useful to
reoptimize after finalization has taken place.  In that case, a second pass
of finalization is needed, and these fields of the <code>StackFrameInfoNote</code>
help <code>fin</code> restart where it left off.
<p>

<h4><a name=toc83>Specializing <code>CodeFin</code> for a target</a></h4>
<p>
As explained above, the <code>CodeFin</code> class does not provide a public
constructor.  This is because the base class does not actually define a
<code>CodeFin</code> object for any specific target.  You develop a <code>CodeFin</code>
object for a specific target (or class of targets) by creating a derived
class of <code>CodeFin</code>.  The <code>CodeFinAlpha</code> class found in the <code>alpha</code>
library is an example of such a derived class.
<p>
<a name="NWD1A">The non-public parts of </a><code>CodeFin</code> contain only instance fields for use by
the public methods.  There are variables to hold values from the
<code>StackFrameInfoNote</code> during the <code>fin</code> pass.  There is a map giving the
frame location for each local symbol.  There is a set per register bank
that is used for collecting the registers that need to be saved, if any,
and there are the lists that will carry prologue and epilogue code during
finalization.
<p>
<pre><a name="NW3QGGna-2KSOmW-1" href="#NWD1A"><dfn>&lt;<code>CodeFin</code> protected parts&gt;=</dfn></a> <b>(<a href="#NWD17">&lt;-U</a>)</b>
  protected:
    // Properties of current procedure, initialized by init()
    //
    OptUnit *cur_unit;

    bool is_leaf;
    bool is_varargs;
    int max_arg_area;

    Map&lt;Sym*,int&gt; frame_map;                    // variables -&gt; frame offsets

  private:
    List&lt;Instr*&gt; _header;                       // header instructions, reversed
    List&lt;Instr*&gt; _trailer;                      // trailer instructions
</pre><p>


<h3><a name=toc84><a name="NWD1B">Header file for module </a><code>code_fin.h</code></a></h3>
<p>
The interface file has the following layout:
<p>
<pre><a name="NW3QGGna-3UpJHe-1" href="#NWD1B"><dfn>&lt;machine/code_fin.h&gt;=</dfn></a>
/* file &quot;machine/code_fin.h&quot; */

<a name="NW3QGGna-3UpJHe-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_CODE_FIN_H
#define MACHINE_CODE_FIN_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/code_fin.h&quot;
#endif

#include &lt;machine/substrate.h&gt;
#include &lt;machine/machine_ir.h&gt;
#include &lt;machine/note.h&gt;

<a name="NW3QGGna-3UpJHe-1-u2" href="#NWD19"><i>&lt;class <code>StackFrameInfoNote</code>&gt;</i></a>

<a name="NW3QGGna-3UpJHe-1-u3" href="#NWD17"><i>&lt;class <code>CodeFin</code>&gt;</i></a>

<a name="NW3QGGna-3UpJHe-1-u4" href="#NWD18"><i>&lt;function <code>target_code_fin</code>&gt;</i></a>

#endif /* MACHINE_CODE_FIN_H */
</pre><p>
<h2><a name=toc85>Sets of Natural Numbers</a></h2>
<a name="sec:NatSet"><b>[*]</b></a>
<p>
Class <code>NatSet</code> represents sets of natural numbers.  An instance of
<code>NatSet</code> is either a finite set or the complement of a finite set.
At present, there are two subclasses of <code>NatSet</code> that allow you to
pick different space and time cost characteristics.
<p>
We view sets as not being constrained by size limits.  One major client
for these set classes is the BVD library for data-flow analysis
<b>[cite&nbsp;<a href="#NWcite-bibbvd">bibbvd</a>]</b>.  In that application, it is useful to be able to begin
developing data-flow information before we know the maximum number of
bit-vector slots that we'll need to represent it.  Furthermore, some
applications of the BVD framework make incremental extensions of
existing data-flow information in which they increase the sizes of the
original bit vectors.
<p>
To create an instance of <code>NatSet</code>, you must choose one of the
following subclasses.   They have different underlying representations
and therefore different performance characteristics.
<p>
<table><!-- alignment is l@{\hspace*{2em}}p{.7\linewidth}--><!-- 2 columns--><tr><td align=left valign=top><code>NatSetDense</code> </td><td align=left valign=top>A <code>NatSet</code> represented using a bit vector:
<ul>
<li>Insertion and removal of elements takes place in
constant time.
<li>Storage is in general proportional to the value
of the largest element of the finite-set part.
<li>Iteration produces elements in
increasing order, but not necessarily in time
proportional to the set cardinality.
<li>Union, intersection, subtraction, and equality
testing can take time proportional to set
storage, but they exploit bitwise parallel
operations. 
</ul> </td></tr>
<tr><td align=left valign=top><code>NatSetSparse</code> </td><td align=left valign=top>A <code>NatSet</code> represented using a sorted linked list:
<ul>       
<li>Insertion and removal of elements depends on the
finite-set cardinality.
<li>Storage is proportional to the cardinality of the
finite-set part.
<li><a name="NWD1C">Iteration produces elements in increasing order</a>
and in time proportional to the number of
elements produced.
</ul>
</td></tr></table>
<p>
We also declare an iterator type compatible with all of the
<code>NatSet</code> types.
<p>
<pre><a name="NW1zngZj-44QVAV-1" href="#NWD1C"><dfn>&lt;class <code>NatSetIterPure</code>&gt;=</dfn></a> <b>(<a href="#NWD1J">U-&gt;</a>)</b>
class NatSetIterPure {
  public:
    virtual ~NatSetIterPure() { }

    virtual unsigned current() const = 0;
    virtual bool is_valid() const = 0;
    virtual void next() = 0;

    virtual void insert(unsigned) = 0;
    virtual void remove(unsigned) = 0;
};
</pre><p>

Its methods are the usual ones for SUIF iterators, except that it supports
insertion and removal of elements into/from the set being traversed.
<p>
<table><!-- alignment is l@{\hspace*{2em}}p{.7\linewidth}--><!-- 2 columns--><tr><td align=left valign=top><code>current()</code>           </td><td align=left valign=top>Return the current element. </td></tr>
<tr><td align=left valign=top><code>is_valid()</code>          </td><td align=left valign=top>Return <code>true</code> unless the iterator is exhausted. </td></tr>
<tr><td align=left valign=top><code>next()</code>              </td><td align=left valign=top>Advance to the next element, if any. </td></tr>
<tr><td align=left valign=top><code>insert(element)</code>     </td><td align=left valign=top>Inserts <code>element</code> in the set under iteration. </td></tr>
<tr><td align=left valign=top><code>remove(element)</code>     </td><td align=left valign=top>Removes <code>element</code> from the set under iteration.
</td></tr></table>
<p>
The <code>insert</code> and <code>remove</code> methods are provided both for convenience.
It is convenient to be able to modify a set via its iterator without having
to pass around both the set and the iterator.  It is often more efficient
<a name="NWD1D">to modify a sorted set at the point currently under the iterator's</a>
attention.  However, the <code>insert</code> and <code>remove</code> methods have a
precondition to simplify implementations.  The element being inserted or
removed must not exceed the element currently under scan.
<p>

The iterator class used in actual programs is a pointer-based realization
of the interface class <code>NatSetIterPure</code>:
<p>
<pre><a name="NW1zngZj-4Q0tQG-1" href="#NWD1D"><dfn>&lt;class <code>NatSetIter</code>&gt;=</dfn></a> <b>(<a href="#NWD1J">U-&gt;</a>)</b>
class NatSetIter : public NatSetIterPure {
  public:
    NatSetIter(NatSet&amp;);
    NatSetIter(const NatSetIter&amp;);
    NatSetIter(NatSetIterRep *rep) : rep(rep) { }
    virtual ~NatSetIter();

    virtual NatSetIter&amp; operator=(const NatSetIter&amp;);

    virtual unsigned current() const;
    virtual bool is_valid() const;
    virtual void next();

    virtual void insert(unsigned);
    virtual void remove(unsigned);

  protected:
    NatSetIterRep *rep;    
};
</pre><p>





<h3><a name=toc86><a name="NWD1E">Class </a><code>NatSet</code></a></h3>
<p>
The <code>NatSet</code> class interface expresses all of the functionality of the
natural-set types except initial construction.  For that, see the
subclasses <code>NatSetDense</code> and <code>NatSetSparse</code> just below.
<p>
<pre><a name="NW1zngZj-L7nvT-1" href="#NWD1E"><dfn>&lt;class <code>NatSet</code>&gt;=</dfn></a> <b>(<a href="#NWD1J">U-&gt;</a>)</b>
class NatSet {
  public:
    virtual ~NatSet() { }
    virtual NatSet&amp; operator=(const NatSet&amp;);

    virtual bool is_finite() const = 0;
    virtual bool is_empty() const = 0;

    virtual int size() const = 0;

    virtual bool contains(unsigned element) const = 0;
    virtual bool contains(const NatSet&amp;) const;
    virtual bool overlaps(const NatSet&amp;) const;

    virtual void insert(unsigned element) = 0;
    virtual void remove(unsigned element) = 0;
    virtual void accommodate(unsigned element) = 0;

    virtual void insert_all() = 0;
    virtual void remove_all() = 0;

    virtual void complement() = 0;
    
    virtual bool operator==(const NatSet&amp;) const;
    virtual bool operator!=(const NatSet &amp;that) const
        { return !(*this == that); }

    virtual void operator+=(const NatSet&amp;);
    virtual void operator*=(const NatSet&amp;);
    virtual void operator-=(const NatSet&amp;);

    virtual NatSetIter iter(bool complement = false) = 0;
    virtual NatSetIter iter(bool complement = false) const = 0;

    virtual void print(FILE* = stdout, unsigned bound = UINT_MAX) const;

<a name="NW1zngZj-L7nvT-1-u1" href="#NWD1F"><i>&lt;<code>NatSet</code> extender's interface&gt;</i></a>
};
</pre><p>

Here's a rundown on the <code>NatSet</code> methods.
<p>
<table><!-- alignment is l@{\hspace*{2em}}p{.7\linewidth}--><!-- 2 columns--><tr><td align=left valign=top><tt>operator=(<i>s</i>)</tt>    </td><td align=left valign=top>Copies <i>s</i> into the current set, preserving
the representation style of the current set. </td></tr>
<tr><td align=left valign=top><code>is_finite()</code>         </td><td align=left valign=top>Returns <code>true</code> if the current set is finite,
i.e., is not the complement of a finite
set. </td></tr>
<tr><td align=left valign=top><code>is_empty()</code>          </td><td align=left valign=top>Returns <code>true</code> if the current set is empty. </td></tr>
<tr><td align=left valign=top><code>size()</code>              </td><td align=left valign=top>Must only be applied when the current set <code>is_finite</code>.
Returns the number of its elements. </td></tr>
<tr><td align=left valign=top><code>contains(</code><i>e</i><code>)</code>   </td><td align=left valign=top>Returns <code>true</code> if <i>e</i> is an element of the
current set. </td></tr>
<tr><td align=left valign=top><code>contains(</code><i>s</i><code>)</code>   </td><td align=left valign=top>Returns <code>true</code> if set <i>s</i> is fully contained by
current set. </td></tr>
<tr><td align=left valign=top><code>overlaps(</code><i>s</i><code>)</code>   </td><td align=left valign=top>Returns <code>true</code> if the intersection of set <i>s</i> with
the current set is not empty. </td></tr>
<tr><td align=left valign=top><code>insert(</code><i>e</i><code>)</code>     </td><td align=left valign=top>Inserts <i>e</i> into the current set. </td></tr>
<tr><td align=left valign=top><code>remove(</code><i>e</i><code>)</code>     </td><td align=left valign=top>Removes <i>e</i> from the current set. </td></tr>
<tr><td align=left valign=top><code>accommodate(</code><i>e</i><code>)</code></td><td align=left valign=top>Ensures the set's representation accommodates <i>e</i>. </td></tr>
<tr><td align=left valign=top><code>insert_all()</code>        </td><td align=left valign=top>Makes the current set represent the whole
universe (the complement of the empty set). </td></tr>
<tr><td align=left valign=top><code>remove_all()</code>        </td><td align=left valign=top>Makes the current set empty. </td></tr>
<tr><td align=left valign=top><code>complement()</code>        </td><td align=left valign=top>Replaces the current set by its complement. </td></tr>
<tr><td align=left valign=top><code>operator==(</code><i>s</i><code>)</code> </td><td align=left valign=top>Returns <code>true</code> if the current set equals <i>s</i>. </td></tr>
<tr><td align=left valign=top><code>operator!=(</code><i>s</i><code>)</code> </td><td align=left valign=top>Returns <code>true</code> if the current set does not
equal <i>s</i>. </td></tr>
<tr><td align=left valign=top><code>operator+=(</code><i>s</i><code>)</code> </td><td align=left valign=top>Unions set <i>s</i> into the current set. </td></tr>
<tr><td align=left valign=top><code>operator*=(</code><i>s</i><code>)</code> </td><td align=left valign=top>Intersects set <i>s</i> into the current set. </td></tr>
<tr><td align=left valign=top><code>operator-=(</code><i>s</i><code>)</code> </td><td align=left valign=top>Subtracts set <i>s</i> from the current set. </td></tr>
<tr><td align=left valign=top><code>iter()</code>              </td><td align=left valign=top>Produces an iterator (of type <code>NatSetIter</code>)
over the current set.  This iterator doesn't
terminate unless the set is finite. </td></tr>
<tr><td align=left valign=top><tt><a name="NWD1F">print(</a><i>f</i>, <i>b</i>)</tt>   </td><td align=left valign=top>Prints the elements of the current set to file <i>f</i>,
excluding those greater than bound <i>b</i>.
</td></tr></table>
<p>

<h5><a name=toc87>Extender's view of <code>NatSet</code>.</a></h5>
<p>
The implementation of a concrete <code>NatSet</code> must provide the following:
<p>
<pre><a name="NW1zngZj-kyLpX-1" href="#NWD1F"><dfn>&lt;<code>NatSet</code> extender's interface&gt;=</dfn></a> <b>(<a href="#NWD1E">&lt;-U</a>)</b>
  protected:
    friend class NatSetCopy;

    virtual int us_size() const = 0;
    virtual NatSet* clone() const = 0;
</pre><p>

where
<p>
<blockquote>
<code>us_size()</code> returns the size of the underlying finite set.<br><code>clone()</code> copies the set into the heap and returns a pointer
to the copy.
</blockquote>
<p>

<h3><a name=toc88><a name="NWD1G">Class </a><code>NatSetDense</code></a></h3>
<p>
The <code>NatSetDense</code> variant of the natural-number sets has the same
functionality as <code>NatSet</code>, but you can construct one from whole cloth.
It is a represented as a <code>BitVector</code>, which is capable of representing
infinite sets: the complement of a finite set has an ``infinity bit'' of
one, meaning that all the bit positions not explicitly represented are
treated as being one.
<p>
<pre><a name="NW1zngZj-2Ecvf1-1" href="#NWD1G"><dfn>&lt;class <code>NatSetDense</code>&gt;=</dfn></a> <b>(<a href="#NWD1J">U-&gt;</a>)</b>
class NatSetDense : public NatSet {
  public:
    NatSetDense(bool complement = false, int size_hint = 0);
    NatSetDense(const NatSet&amp;);
    NatSet&amp; operator=(const NatSet&amp; that);

    bool is_finite() const;
    bool is_empty() const;

    int size() const;

    bool contains(unsigned element) const;
    bool contains(const NatSet&amp;) const;
    bool overlaps(const NatSet&amp;) const;

    void insert(unsigned element);
    void remove(unsigned element);
    void accommodate(unsigned element);

    void insert_all();
    void remove_all();

    void complement();
    
    bool operator==(const NatSet&amp;) const;

    void operator+=(const NatSet&amp;);
    void operator*=(const NatSet&amp;);
    void operator-=(const NatSet&amp;);

    NatSetIter iter(bool complement = false);
    NatSetIter iter(bool complement = false) const;

  protected:
    BitVector us;               // underlying set

    int us_size() const;
    NatSet* clone() const;
};
</pre><p>


<h3><a name=toc89><a name="NWD1H">Class </a><code>NatSetSparse</code>.</a></h3>
<p>
The <code>NatSetSparse</code> class is analogous to <code>NatSetDense</code> but uses a sorted
linked-list representation.  Apart from its constructors and assignment
operator, <code>NatSetSparse</code> inherits all methods from <code>NatSet</code>.
<p>
<pre><a name="NW1zngZj-3VYTnt-1" href="#NWD1H"><dfn>&lt;class <code>NatSetSparse</code>&gt;=</dfn></a> <b>(<a href="#NWD1J">U-&gt;</a>)</b>
class NatSetSparse : public NatSet {
  public:
    NatSetSparse(bool complement = false, int size_hint = 0)
        : is_complemented(complement) { }
    NatSetSparse(const NatSet&amp;);

    NatSet&amp; operator=(const NatSet &amp;rhs);

    bool is_finite() const;
    bool is_empty() const;

    int size() const;

    bool contains(unsigned element) const;

    void insert(unsigned element);
    void remove(unsigned element);
    void accommodate(unsigned element) { }

    void insert_all();
    void remove_all();

    void complement();
    
    bool operator==(const NatSet&amp;) const;

    NatSetIter iter(bool complement = false);
    NatSetIter iter(bool complement = false) const;

  protected:
    Set&lt;unsigned&gt; us;
    bool is_complemented;

    int us_size() const;
    NatSet* clone() const;
};
</pre><p>

<h3><a name=toc90><a name="NWD1I">Class </a><code>NatSetCopy</code>.</a></h3>
<p>
The <code>NatSetCopy</code> class plays a different role from those above.  You use
it when you want to make a private copy of an existing set, giving it the
same representation, and hence the same performance characteristics, as
that original set.
<p>
<pre><a name="NW1zngZj-36w5Fn-1" href="#NWD1I"><dfn>&lt;class <code>NatSetCopy</code>&gt;=</dfn></a> <b>(<a href="#NWD1J">U-&gt;</a>)</b>
class NatSetCopy : public NatSet {
  public:
    NatSetCopy(const NatSet&amp;);
    NatSet&amp; operator=(const NatSet&amp;);

    bool is_finite() const;
    bool is_empty() const;

    int size() const;

    bool contains(unsigned element) const;
    bool contains(const NatSet&amp;) const;
    bool overlaps(const NatSet&amp;) const;

    void insert(unsigned element);
    void remove(unsigned element);
    void accommodate(unsigned element);

    void insert_all();
    void remove_all();

    void complement();
    
    bool operator==(const NatSet&amp;) const;

    void operator+=(const NatSet&amp;);
    void operator*=(const NatSet&amp;);
    void operator-=(const NatSet&amp;);

    NatSetIter iter(bool complement = false);
    NatSetIter iter(bool complement = false) const;

    void print(FILE* = stdout, unsigned bound = UINT_MAX) const;

  protected:
    int us_size() const;
    NatSet* clone() const;

  private:
    NatSet *own;
};
</pre><p>



<h3><a name=toc91><a name="NWD1J">Header file </a><code>nat_set.h</code></a></h3>
<p>
The header file for module <code>nat_set</code> has the following layout.
<p>
<pre><a name="NW1zngZj-2e4MRz-1" href="#NWD1J"><dfn>&lt;machine/nat_set.h&gt;=</dfn></a>
/* file &quot;machine/nat_set.h&quot; */

<a name="NW1zngZj-2e4MRz-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_NAT_SET_H
#define MACHINE_NAT_SET_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/nat_set.h&quot;
#endif

#include &lt;machine/substrate.h&gt;

class NatSet;
class NatSetIterRep;

<a name="NW1zngZj-2e4MRz-1-u2" href="#NWD1C"><i>&lt;class <code>NatSetIterPure</code>&gt;</i></a>

<a name="NW1zngZj-2e4MRz-1-u3" href="#NWD1D"><i>&lt;class <code>NatSetIter</code>&gt;</i></a>

<a name="NW1zngZj-2e4MRz-1-u4" href="#NWD1E"><i>&lt;class <code>NatSet</code>&gt;</i></a>

<a name="NW1zngZj-2e4MRz-1-u5" href="#NWD1G"><i>&lt;class <code>NatSetDense</code>&gt;</i></a>

<a name="NW1zngZj-2e4MRz-1-u6" href="#NWD1H"><i>&lt;class <code>NatSetSparse</code>&gt;</i></a>

<a name="NW1zngZj-2e4MRz-1-u7" href="#NWD1I"><i>&lt;class <code>NatSetCopy</code>&gt;</i></a>

#endif /* MACHINE_NAT_SET_H */
</pre><p>
<h2><a name=toc92>Annotations</a></h2>
<p>
An annotation attaches one or more values to an IR object.  Each such
association is identified by a <em>key</em>.  An object can have one or more
annotations under a particular key.  You supply both the object pointer and
<a name="NWD1K">the key when you attach, detach, or inspect an annotation.</a>
<p>

<h5><a name=toc93>Type <code>NoteKey</code>.</a></h5>
<p>
The OPI uses type <code>NoteKey</code> as the type of annotation keys.  In Machine
SUIF, <code>NoteKey</code> is defined to be <code>IdString</code>, since these values are
conveniently mnemonic and they can be tested for equality efficiently.
<p>
<pre><a name="NW43k0dj-2TOKxg-1" href="#NWD1K"><dfn>&lt;typedef <code>NoteKey</code>&gt;=</dfn></a> <b>(<a href="#NWD1U">U-&gt;</a>)</b>
typedef IdString NoteKey;
</pre><p>


<h3><a name=toc94>Class <code>Note</code></a></h3>
<p>
In Machine SUIF, class <code>Note</code> is implemented as a wrapper for a base SUIF
annotation.  The only storage underlying a <code>Note</code> consists of a value of
type <code>Annote*</code> and a pointer to a reference count.  You must use
subclasses of <code>Note</code> to construct useful annotations; the only public
<code><a name="NWD1L">Note</a></code> constructors are the null-note constructor and the copy
constructor.  If you create a custom subclass of <code>Note</code>, you should
record all of their state in the SUIF <code>Annote</code>, and not add more instance
fields.  That allows the note to be written to and read from intermediate
files transparently (once a <code>set_note</code> call has attached the SUIF
annotation to the IR object), and it also enables easy interconversion
between the base class and your subclass, because there is no risk of
``slicing'' bugs, i.e., loss of instance data through upcasting.
<p>
<pre><a name="NW43k0dj-2uV4ks-1" href="#NWD1L"><dfn>&lt;class <code>Note</code>&gt;=</dfn></a> <b>(<a href="#NWD1U">U-&gt;</a>)</b>
class Note {
  public:
    Note();                             // null-note constructor
    Note(const Note&amp;);                  // copy constructor
    ~Note();

    const Note&amp; operator=(const Note&amp;);
    bool operator==(const Note&amp;) const;
    operator bool() const { return annote != NULL; }

  protected:

    Annote *annote;                     // underlying SUIF annotation
    mutable int *ref_count;             // nullified by set_note

    friend Note clone(const Note&amp;);
    friend Note get_note (IrObject*, NoteKey);
    friend Note take_note(IrObject*, NoteKey);
    friend void set_note (IrObject*, NoteKey, const Note&amp;);
    friend Note note_flag();
    friend Note note_list_any();

    // Protected constructor, only invoked by friends.
    Note(Annote*, bool owned);

    void clear();

    // Methods that access the value sequence of a BrickAnnote
    int _values_size() const;

    void _insert_before(int pos, long value);
    void _insert_before(int pos, Integer value);
    void _insert_before(int pos, IdString value);
    void _insert_before(int pos, IrObject *value);

    void _append(long value);
    void _append(Integer value);
    void _append(IdString value);
    void _append(IrObject *value);

    void _replace(int pos, long value);
    void _replace(int pos, Integer value);
    void _replace(int pos, IdString value);
    void _replace(int pos, IrObject *value);

    void _remove(int pos);

    long _get_value(int pos, long const&amp;) const
        { return _get_c_long(pos); }
    Integer _get_value(int pos, Integer const&amp;) const
        { return _get_integer(pos); }
    IdString _get_value(int pos, IdString const&amp;) const
        { return _get_string(pos); }
    IrObject* _get_value(int pos, IrObject* const&amp;) const
        { return _get_ir_object(pos); }

    long      _get_c_long(int pos) const;
    Integer   _get_integer(int pos) const;
    IdString  _get_string(int pos) const;
    IrObject* _get_ir_object(int pos) const;
};
</pre><p>

<h5><a name=toc95>Public methods.</a></h5>
The public methods of class <code>Note</code> allow you to construct a null note, to
copy an existing note, to compare notes for equality, and to test whether a
note is null.  What does it mean to copy a note?  In Machine SUIF, it means
to make a new reference to the same underlying SUIF <code>Annote</code>.  So if you
assign one <code>Note</code>-valued variable to another, then changes to the
underlying value of either variable <em>does</em> affect the other.  (To
override this reference-semantics behavior, you have to use the <code>clone</code>
function.)
<p>
Two notes are equal when their underlying SUIF annotations are isomorphic
and have pairwise equal components.  A null note is recognized by the fact
that its internal pointers (the <code>Annote*</code> and the reference-count
pointer) are null.  The main purpose of a null note is to indicate the
absence of an attachment to a particular object, for example, if the result
of evaluating <code>get_note(mi, k_line)</code> is a null note value, it means that
object <code>mi</code> has no note under the key <code>k_line</code>.
<p>
When a note is converted to type <code>bool</code>, the result is false only when
the note is null; otherwise, the result is true.  The purpose of this
conversion rule is allow you declare, initialize, and test a note variable
in one statement.  For example,
<p>
<pre>
    if (LineNote note = get_note(mi, k_line)) {
        const char *file = note.get_file().chars();
          ...
    }
</pre>

If object <code>mi</code> has no <code>k_line</code> note, the ``then'' clause of the <code>if</code>
statement is skipped.
<p>

<h5><a name=toc96>Friends of <code>Note</code>.</a></h5>
<p>
Since the only way to construct a non-null note or to look at its
underlying representation is through protected methods, several OPI
functions are declared as friends of class <code>Note</code>.
<p>
<h5><a name=toc97>Protected methods.</a></h5>
<p>
The way most notes come into being is via the protected constructor that
takes an <code>Annote*</code> and a Boolean.  The first of these arguments becomes
the underlying annotation in the new note.  The second is true if that
underlying <code>Annote</code> is already attached to (and hence, owned by) a SUIF
object.  If so, the new note needs no reference count; it will be reclaimed
when its owning object is reclaimed.  Otherwise, the annotation is not yet
attached; the new note gets a reference count to be sure that the
<code>Annote*</code> is properly <code>delete</code>d if it happens never to be attached to
an object.
<p>
The <code>clear</code> method is used when one of a note's references is discarded.
If the note has a reference count, this method decrements it, and it takes
care of reclaiming storage if the count reaches zero.
<p>
The rest of the methods in class <code>Note</code> are for the common case in which
the note associates a tuple of values with the object to which it is
attached.  You use them when building a specialized subclass of <code>Note</code>;
they allow you to manipulate a tuple of values that comprise note's
contents.  We call it a ``tuple'' because it is not homogeneous: the tuple
methods allow for four kinds of values: C <code>long</code>, <code>Integer</code>,
<code>IdString</code>, and <code>IrObject*</code>.
 <b>[</b>The C <code>long</code> values are of course a subset of the <code>Integer</code>s,
but because relatively small numbers are so common, it is convenient to
have the extra case for <code>long</code>s.<b>]</b> 
<p>
The names of the tuple methods follow the OPI's conventions for a
sequence whose (conceptual) name is <code>values</code>, but there's an extra <code>_</code>
at the front of each to avoid precluding the use of the actual OPI name as
a public method of some derived class.  Because the <code>values</code> tuple can
have multiple element types, the <code>_get_</code>...methods are unusual.  When
writing a subclass method, if you know that the tuple element you
want to extract is, say, a string, you use <code>_get_string</code> to fetch it.
But when writing a templated subclass, the type of the tuple element may be
a template parameter, e.g., <code>T</code>.  In that case, you can write
<code>_get_value(pos, T())</code>, and the C++ overloading mechanism will choose the
correct method for you.
<p>
<h5><a name=toc98><a name="NWD1M">Atomic notes.</a></a></h5>
<p>
There are two kinds of <em>atomic</em> notes: null notes, which can't be
attached to objects, and flag notes, which can be attached, but carry no
other information than that conveyed by their presence on an object.  There
is an OPI function to create each of these kinds, and a predicate to test
for nullness.
<p>
<pre><a name="NW43k0dj-3SX5rg-1" href="#NWD1M"><dfn>&lt;functions for atomic notes&gt;=</dfn></a> <b>(<a href="#NWD1U">U-&gt;</a>)</b>
Note note_null();
bool is_null(const Note&amp;);

Note note_flag();
</pre><p>

As mentioned above, the representation for a null note contains a null
<code>Annote*</code> field.  A flag annote holds a pointer to a <code>GeneralAnnote</code>, a
subclass of <code>Annote</code>.
<p>

<h5><a name=toc99><a name="NWD1N">Tuple notes.</a></a></h5>
<p>
A non-atomic note contains a pointer to a <code>BrickAnnote</code>.  That's a kind
of <code>Annote</code> that can carry a heterogeneous series of values (``bricks'').
The methods of <code>Note</code> for manipulating these values are protected, so you
must use or create a derived note class in order to take advantage of
them.  Derived classes use the following function to generate a tuple-note
value.
<p>
<pre><a name="NW43k0dj-ip60R-1" href="#NWD1N"><dfn>&lt;creator for non-atomic notes&gt;=</dfn></a> <b>(<a href="#NWD1U">U-&gt;</a>)</b>
Note note_list_any();   // used only by Note classes
</pre><p>

<a name="NWD1O">You should only need this function when deriving a note subclass, however.</a>
<p>

<h5><a name=toc100>Attaching, detaching, and testing for notes.</a></h5>
<p>
The OPI functions that you use to test for the presence of notes on an
object, to access or remove a note from an object, or to attach a note to
an object, are declared as follows.
<p>
<pre><a name="NW43k0dj-3RMet8-1" href="#NWD1O"><dfn>&lt;note-object association functions&gt;=</dfn></a> <b>(<a href="#NWD1U">U-&gt;</a>)</b>
bool has_notes(IrObject*);
bool has_note (IrObject*, NoteKey);
Note get_note (IrObject*, NoteKey);
Note take_note(IrObject*, NoteKey);
void set_note (IrObject*, NoteKey, const Note&amp;);
</pre><p>

Functions <code>get_note</code> and <code>take_note</code> return a null note if the object
passed to them has no associated note under the given note key.  You can
test for nullness with the <code>is_null</code> predicate or by using an <code>if</code> or
<code>while</code> statement that declares, binds, and tests a note variable all at
once.  (See the example of an <code>if</code> statement above.)
<p>

<h3><a name=toc101><a name="NWD1P">Specialized Note Classes</a></a></h3>
<p>
<h5><a name=toc102>Single-valued notes.</a></h5>
<p>
Class <code>OneNote&lt;ValueType&gt;</code> allows attachment of a single value to an
object.  The type of the value is the template parameter <code>ValueType</code>.
<p>
<pre><a name="NW43k0dj-1aPhJW-1" href="#NWD1P"><dfn>&lt;class <code>OneNote</code>&gt;=</dfn></a> <b>(<a href="#NWD1U">U-&gt;</a>)</b>
template &lt;class ValueType&gt;
class OneNote : public Note {
 public:
    OneNote() : Note(note_list_any()) { _replace(0, ValueType()); }
    OneNote(ValueType value) : Note(note_list_any()) { set_value(value); }
    OneNote(const OneNote&lt;ValueType&gt; &amp;other) : Note(other) { }
    OneNote(const Note &amp;note) : Note(note) { }

    ValueType get_value() const
        { return _get_value(0, ValueType()); }
    void set_value(ValueType value)
        { _replace(0, value); }
};
</pre><p>

The first (parameterless) constructor gives the note a default value.  To
give it a non-default value, you can either use the second constructor,
which accepts a value, or you can create the note and then use the
<code><a name="NWD1Q">set_value</a></code> method.  To fetch the value from the note, you apply the
<code>get_value</code> method.
<p>

<h5><a name=toc103>List-carrying notes.</a></h5>
<p>
Class <code>ListNote&lt;ValueType&gt;</code> allows you to attach zero or more values, all
of which have type <code>ValueType</code>.
<p>
<pre><a name="NW43k0dj-sTL35-1" href="#NWD1Q"><dfn>&lt;class <code>ListNote</code>&gt;=</dfn></a> <b>(<a href="#NWD1U">U-&gt;</a>)</b>
template &lt;class ValueType&gt;
class ListNote : public Note {
  public:
    ListNote() : Note(note_list_any()) { }
    ListNote(const ListNote&lt;ValueType&gt; &amp;other) : Note(other) { }
    ListNote(const Note &amp;note) : Note(note) { }

    int values_size() const
        { return _values_size(); }
    ValueType get_value(int pos) const
        { return _get_value(pos, ValueType()); }
    void set_value(int pos, ValueType value)
        { _replace(pos, value); }
    void append(ValueType value)
        { _append(value); }
    void insert_before(int pos, ValueType value)
        { _insert_before(pos, value); }
    void remove(int pos)
        { _remove(pos); }
};
</pre><p>

When you first create a <code>ListNote</code>, is contains no  values; that is, its
<code>value_size</code> method returns zero.  The methods of the class allow you to
add, remove, update, and access values.
<p>

<h5><a name=toc104><a name="NWD1R">Custom notes for source-code location.</a></a></h5>
<p>
This is a typical custom note class.  It is mentioned as an example in
<em>The Extender's Guide</em>.  You often want to be able to attach a few
values of different kinds to an object.  In this case, the object is
usually an instruction, and the values are the source file name (a string)
and the source line number (an integer) that gave rise to the instruction.
Here's the entire derived class:
<p>
<pre><a name="NW43k0dj-302t0R-1" href="#NWD1R"><dfn>&lt;class <code>LineNote</code>&gt;=</dfn></a> <b>(<a href="#NWD1U">U-&gt;</a>)</b>
class LineNote : public Note {
 public:
    LineNote() : Note(note_list_any()) { }
    LineNote(const LineNote &amp;other) : Note(other) { }
    LineNote(const Note &amp;note) : Note(note) { }

    int get_line() const        { return _get_c_long(0); }
    void set_line(int line)     { _replace(0, line); }
    IdString get_file() const   { return _get_string(1); }
    void set_file(IdString file){ _replace(1, file); }
};
</pre><p>

Here, we chose to make the line number the first element of the underlying
tuple and the file name the second element.  But no users of class
<code>LineNote</code> need to know that.
<p>

<h5><a name=toc105><a name="NWD1S">Custom note for multiway branches.</a></a></h5>
<p>
Notes of class <code>MbrNote</code> attach information about a multiway branch to
the instruction that implements it, which for some target is not
distinguishable from an ordinary indirect jump instruction without this
annotation.
<p>
<pre><a name="NW43k0dj-1DJHfo-1" href="#NWD1S"><dfn>&lt;class <code>MbrNote</code>&gt;=</dfn></a> <b>(<a href="#NWD1U">U-&gt;</a>)</b>
class MbrNote : public Note {
 public:
    MbrNote() : Note(note_list_any()) { }
    MbrNote(const MbrNote &amp;other) : Note(other) { }
    MbrNote(const Note &amp;note) : Note(note) { }

    int get_case_count() const;
    VarSym* get_table_sym() const
        { return to&lt;VarSym&gt;(_get_ir_object(0)); }
    void set_table_sym(VarSym* var)
        { _replace(0, var); }

    LabelSym* get_default_label() const
        { return to&lt;LabelSym&gt;(_get_ir_object(1)); }
    void set_default_label(LabelSym* label)
        { _replace(1, label); }

    int get_case_constant(int pos) const
        { return _get_c_long((pos &lt;&lt; 1) + 2); }
    void set_case_constant(int constant, int pos)
        { _replace((pos &lt;&lt; 1) + 2, constant); }

    LabelSym* get_case_label(int pos) const
        { return to&lt;LabelSym&gt;(_get_ir_object((pos &lt;&lt; 1) + 3)); }
    void set_case_label(LabelSym* label, int pos)
        { _replace((pos &lt;&lt; 1) + 3, label); }
};
</pre><p>

The contents of a <code>MbrNote</code> include a sequence of
(<code>case_constant</code>, <code>case_label</code>) pairs, where the <code>case_constant</code> is
the integral value of the tested expression that marks a particular case
and the <code>case_label</code> is the label of the code to which the instruction
jumps in that case.  In addition to the sequence of pairs, there are fixed
``fields'':  <code>case_count</code> is the number of non-default cases, i.e., the
length of the sequence of pairs just mentioned;  <code>table_sym</code> is the
variable symbol holding the dispatch table used to compute the target of
the indirect jump; and <code>default_label</code> is the code label to which control
transfers when the tested expression doesn't evaluate to one of the
<a name="NWD1T">explicit case constants.</a>
<p>

<h5><a name=toc106>Custom note for attaching a natural-number set.</a></h5>
<p>
Class <code>NatSetNote</code> connects a <code>NatSet</code> to an IR object.  One use is to
record the sets of registers implicitly used or defined by an instruction
for the benefit of data-flow analyzers.
<p>
<pre><a name="NW43k0dj-37X3rY-1" href="#NWD1T"><dfn>&lt;class <code>NatSetNote</code>&gt;=</dfn></a> <b>(<a href="#NWD1U">U-&gt;</a>)</b>
class NatSetNote : public Note {
  public:
    NatSetNote(bool dense = false);
    NatSetNote(const NatSet*, bool dense = false);
    NatSetNote(const NatSetNote &amp;other) : Note(other) { }
    NatSetNote(const Note &amp;note) : Note(note) { }

    void get_set(NatSet*) const;
    void set_set(const NatSet*);
};
</pre><p>

Just as there are ``dense'' (bit-vector based) and ``sparse'' (linked-list
based) representations for an in-memory <code>NatSet</code>, you can chose between
dense and sparse <code>NatSetNote</code> representations.  By default, the sparse-set
form is used, meaning that each set element is stored individually in the
values tuple of the note.  On the other hand, if you pass the argument
<code>true</code> to the <code>NatSetNote</code> constructor, it will choose a dense-set form
and represent the set as a bit vector, stored in a single <code>Integer</code>
value.  In either case, the set is allowed to be the complement of a finite
set (the result of applying the <code>NatSet::complement</code> method).
<p>
You can the supply the set of values to attach by passing a <code>NatSet*</code> to
the <code>NatSetNote</code> constructor, or you can call the <code>set_set</code> method of
an existing note.  When you want to read back the set contained in a note,
you must pass a pointer to a <code>NatSet</code> to the <code>get_set</code> method, which
clears it and then fills it from the note.  Here is one way to do this:
<p>
<pre>
    if (NatSetNote regs_used_note = get_note(instr, k_regs_used)) {
        NatSetDense regs_used;
        regs_used_note.get_set(&amp;regs_used);
          ...                               // regs_used holds register set
    }
</pre>

<a name="NWD1U">You don't have to know whether the note was represented in sparse or dense</a>
form when you read it back.  We could just as well have declared
<code>regs_used</code> to have type <code>NatSetSparse</code> in the example above.
<p>

<h3><a name=toc107>header file <code>opnd.h</code></a></h3>
<p>
The header file for operands has the following outline:
<p>
<pre><a name="NW43k0dj-1BlvpW-1" href="#NWD1U"><dfn>&lt;machine/note.h&gt;=</dfn></a>
/* file &quot;machine/note.h&quot; */

<a name="NW43k0dj-1BlvpW-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_NOTE_H
#define MACHINE_NOTE_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/note.h&quot;
#endif

#include &lt;machine/substrate.h&gt;
#include &lt;machine/nat_set.h&gt;

<a name="NW43k0dj-1BlvpW-1-u2" href="#NWD1K"><i>&lt;typedef <code>NoteKey</code>&gt;</i></a>

<a name="NW43k0dj-1BlvpW-1-u3" href="#NWD1L"><i>&lt;class <code>Note</code>&gt;</i></a>

<a name="NW43k0dj-1BlvpW-1-u4" href="#NWD1M"><i>&lt;functions for atomic notes&gt;</i></a>

<a name="NW43k0dj-1BlvpW-1-u5" href="#NWD1N"><i>&lt;creator for non-atomic notes&gt;</i></a>

<a name="NW43k0dj-1BlvpW-1-u6" href="#NWD1O"><i>&lt;note-object association functions&gt;</i></a>

<a name="NW43k0dj-1BlvpW-1-u7" href="#NWD1P"><i>&lt;class <code>OneNote</code>&gt;</i></a>

<a name="NW43k0dj-1BlvpW-1-u8" href="#NWD1Q"><i>&lt;class <code>ListNote</code>&gt;</i></a>

<a name="NW43k0dj-1BlvpW-1-u9" href="#NWD1R"><i>&lt;class <code>LineNote</code>&gt;</i></a>

<a name="NW43k0dj-1BlvpW-1-u10" href="#NWD1S"><i>&lt;class <code>MbrNote</code>&gt;</i></a>

<a name="NW43k0dj-1BlvpW-1-u11" href="#NWD1T"><i>&lt;class <code>NatSetNote</code>&gt;</i></a>

#endif /* MACHINE_NOTE_H */
</pre><p>
<h2><a name=toc108>Problems</a></h2>
<p>
This section contains problem-reporting utilities for Machine SUIF.
<p>
<h3><a name=toc109>Progress diagnostics and warning messages</a></h3>
<p>
<h5><a name=toc110>Function <code>debug</code>.</a></h5>
<p>
<code>debug</code> prints diagnostic messages provided the user has set <code>debuglvl</code>
to the appropriate level of verbosity.  Most Machine-SUIF passes take a
command-line option for setting this variable.
<p>
The first argument must be less than or equal to the current value of
<code><a name="NWD1V">debuglvl</a></code> for the call on <code>debug</code> to have any effect.  If that
condition holds, the second and subsequent arguments are used as they would
be in a call to <code>fprintf</code> with <code>stderr</code> as the output stream.
<p>
We condition the definition of <code>debug</code> so that its calls can be
completely omitted from compiled passes and libraries if the preprocessor
token <code>NDEBUG</code> is defined and optimizations are turned on at the time
Machine SUIF is built.
<p>
<pre><a name="NW1peSsA-otECB-1" href="#NWD1V"><dfn>&lt;function <code>debug</code>&gt;=</dfn></a> <b>(<a href="#NWD1Z">U-&gt;</a>)</b>
extern int debuglvl;            /* user defined diagnostic print level */

#ifndef NDEBUG
extern void debug(const int, const char * ...);
#else
#define debug if (false)
#endif
</pre><p>

<h5><a name=toc111><a name="NWD1W">Function </a><code>warn</code>.</a></h5>
<p>
<code>warn</code> is similar to <code>debug</code> except that it is unconditional.
<p>
<pre><a name="NW1peSsA-3EeixM-1" href="#NWD1W"><dfn>&lt;function <code>warn</code>&gt;=</dfn></a> <b>(<a href="#NWD1Z">U-&gt;</a>)</b>
#ifndef NDEBUG
extern void warn(const char * ...);
#else
#define warn if (false)
#endif
</pre><p>


<h5><a name=toc112><a name="NWD1X">Macros </a><code>if_debug</code>.</a></h5>
<p>
The macro <code>if_debug(lvl)</code> causes the subsequence statement to be executed
only if <code>debuglvl</code> equals or exceeds <code>lvl</code>.  The reason for using it
instead of testing <code>debuglvl</code> directly is that <code>if_debug</code> can be
redefined to erase the subsequent statement, thereby making production code
smaller and a bit faster.
<p>
<pre><a name="NW1peSsA-nsK1R-1" href="#NWD1X"><dfn>&lt;macro <code>if_debug</code>&gt;=</dfn></a> <b>(<a href="#NWD1Z">U-&gt;</a>)</b>
#ifndef NDEBUG
#define if_debug(lvl) if (debuglvl &gt;= lvl)
#else
#define if_debug(lvl) if (false)
#endif
</pre><p>


<h3><a name=toc113>Assertions</a></h3>
<p>
In Machine SUIF, the assertion primitive is called <code>claim</code>.  You
state your assertion as a <code>claim</code> that a given Boolean expression holds.
If the expression evaluates to <code>false</code> the program prints a message,
optionally containing formatted text supplied with the claim, and it
aborts.
 <b>[</b>Our assertion machinery is adapted from an earlier version of SUIF.<b>]</b> 
It is as if function <code>claim</code> had the following declarations.
<pre>
   <a name="NWD1Y">extern void claim(bool assertion);</a>
   extern void claim(bool assertion, const char *format, ...);
</pre>
<p>
The implementation adds source-code location information to help identify a
claim that is violated.  As with the <code>debug</code> and <code>warn</code> functions, we
can conditionally omit calls to <code>claim</code> in an installation of Machine
SUIF by defining <code>NDEBUG</code> and turning on compiler optimizations.
<p>
<pre><a name="NW1peSsA-3yhLnJ-1" href="#NWD1Y"><dfn>&lt;function <code>claim</code>&gt;=</dfn></a> <b>(<a href="#NWD1Z">U-&gt;</a>)</b>

extern char *__assertion_file_name;
extern int __assertion_line_num;
extern char *__assertion_module_name;

extern void _internal_assertion_failure(void);
extern void _internal_assertion_failure(const char *format, va_list ap);

inline void __do_assertion(bool assertion)
  {  if (!(assertion))  _internal_assertion_failure(); }

inline void __do_assertion(bool assertion, const char *format, ...)
  {
    if (!(assertion))
      {
        va_list ap;
        va_start(ap, format);
        _internal_assertion_failure(format, ap);
        va_end(ap);
      }
  }

#ifndef NDEBUG

#ifndef _MODULE_
#define _MODULE_ NULL
#endif

#define claim  __assertion_file_name = __FILE__, \
               __assertion_line_num = __LINE__, \
               __assertion_module_name = _MODULE_, \
               __do_assertion
#else
#define claim if (false)
#endif
</pre><p>


<h3><a name=toc114><a name="NWD1Z">Header file </a><code>problems.h</code></a></h3>
<p>
The header file for module <code>problems</code> has the following layout.
<p>
<pre><a name="NW1peSsA-4POXWt-1" href="#NWD1Z"><dfn>&lt;machine/problems.h&gt;=</dfn></a>
/* file &quot;machine/problems.h&quot; */

<a name="NW1peSsA-4POXWt-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_PROBLEMS_H
#define MACHINE_PROBLEMS_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/problems.h&quot;
#endif

#include &lt;machine/substrate.h&gt;

<a name="NW1peSsA-4POXWt-1-u2" href="#NWD1V"><i>&lt;function <code>debug</code>&gt;</i></a>

<a name="NW1peSsA-4POXWt-1-u3" href="#NWD1W"><i>&lt;function <code>warn</code>&gt;</i></a>

<a name="NW1peSsA-4POXWt-1-u4" href="#NWD1X"><i>&lt;macro <code>if_debug</code>&gt;</i></a>

<a name="NW1peSsA-4POXWt-1-u5" href="#NWD1Y"><i>&lt;function <code>claim</code>&gt;</i></a>

#endif /* MACHINE_PROBLEMS_H */
</pre><p><h2><a name=toc115>Utilities</a></h2>
<p>
This section contains utilities for Machine SUIF.
<p>
<h3><a name=toc116>Operand scanning and replacement</a></h3>
<p>
Utility <code>map_opnds</code> applies a functional object to the operands of
an instruction and replaces each by the result returned (which may of
course be the same as the original).  The related utilities
<code>map_src_opnds</code> and <code>map_dst_opnds</code> do the same for the source
and destination subsets of an instruction's operands, respectively.
<p>
<a name="NWD1a">The object applied to each operand is of class </a><code>OpndFilter</code>.  The
only significant method of this class is its ``apply'' operator
(<code>operator()</code>), which takes and returns an <code>Opnd</code>.  You can
subclass <code>OpndFilter</code> so that the apply operator examines and/or
transforms operands as you wish and so that an instance of your subclass
carries whatever state might be needed when each operand is visited.
The base class is quite simple:
<p>
<pre><a name="NW4MGyWr-3OemUJ-1" href="#NWD1a"><dfn>&lt;class <code>OpndFilter</code>&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b>
class OpndFilter {
  public:
    OpndFilter(bool thru_addr_exps = true)
        { _thru_addr_exps = thru_addr_exps; }
    virtual ~OpndFilter() {}

    typedef enum { IN, OUT } InOrOut;

    virtual Opnd operator()(Opnd, InOrOut) = 0;

    bool thru_addr_exps() const { return _thru_addr_exps; }
  protected:
    bool _thru_addr_exps;
};
</pre><p>

<a name="NWD1b">The </a><code>map_opnds</code>, <code>map_src_opnds</code>, and <code>map_dst_opnds</code>
functions take the instruction whose operands are to be scanned and a
concrete instance of <code>OpndFilter</code>.
<p>
<pre><a name="NW4MGyWr-3Uzeoo-1" href="#NWD1b"><dfn>&lt;function <code>map_opnds</code>&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b>
void map_opnds(Instr *instr, OpndFilter &amp;filter);
void map_opnds(Opnd addr_exp, OpndFilter &amp;filter);
void map_src_opnds(Instr *instr, OpndFilter &amp;filter);
void map_dst_opnds(Instr *instr, OpndFilter &amp;filter);
</pre><p>

The <code>map_opnds</code> function applies the filter to each operand,
indicating via a second argument whether the operand is an input
(<code>IN</code>) or an output (<code>OUT</code>) of the instruction.  It replaces the
original operand by the filter's result.
<p>
When <code>map_opnds</code> reaches an address-expression operand, it applies
the filter to the whole operand before doing any of the constituent
operands.  If the filter returns the address-expression operand
unchanged, then the filter is applied to, and may replace, the
constituent operands of the address expression.  Recall that all
constituent operands of an address expression are instruction inputs,
even if the address expression is a destination operand.  The filter
therefore always receives the indicator <code>IN</code> when applied to a
suboperand of an address expression.
<p>
Function <code>map_src_opnds</code> is just like <code>map_opnds</code>, but it only
maps the direct source operands of the instruction.  Likewise,
<code>map_dst_opnds</code> maps only the destination operands.
<p>
A typical use for <code>map_opnds</code> is to rewrite operands that have been
assigned to physical registers.  The filter simply checks whether its
argument is one of those to be rewritten.  If so, it returns the
appropriate hard-register operand; if not, it returns its argument
unchanged.
<p>



<h3><a name=toc117>Annotation help</a></h3>
<p>
Certain annotations are used often enough to make it worthwhile defining
<a name="NWD1c">utilities to query and update them.</a>
<p>
<h5><a name=toc118>Formal parameters assigned to registers.</a></h5>
<p>
The <code>param_reg</code> annotation records the assignment of a
formal-parameter symbol to a specific argument register.  The only data
stored is the abstract register number.  The following functions manage
<code>param_reg</code> annotations.
<p>
<pre><a name="NW4MGyWr-T7R8O-1" href="#NWD1c"><dfn>&lt;parameter-register utilities&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b>
bool is_reg_param(VarSym*);
int get_param_reg(VarSym*);
void set_param_reg(VarSym*, int reg);
</pre><p>

<table><!-- alignment is l@{\hspace*{2em}}p{.7\linewidth}--><!-- 2 columns--><tr><td align=left valign=top><code>is_reg_param(</code><i>p</i><code>)</code>       </td><td align=left valign=top>Returns <code>true</code> if parameter symbol <i>p</i> is
assigned to a register. </td></tr>
<tr><td align=left valign=top><code>get_param_reg(</code><i>p</i><code>)</code>      </td><td align=left valign=top>Returns the abstract number of the register to
which parameter <i>p</i> is assigned, or -1
if it's not assigned to a register. </td></tr>
<tr><td align=left valign=top><code>set_param_reg(</code><i>p</i><code>, </code><i>r</i><code>)</code> </td><td align=left valign=top>Records the assignment of parameter <i>p</i> to
register <i>r</i>.
</td></tr></table>
<p>

<h4><a name=toc119><a name="NWD1d">Annotation transfer</a></a></h4>
<p>
Sometimes when you replace one annotated <code>IrObject</code> with another, you
want to transfer the annotations of the former to the latter.  For this we
have:
<p>
<pre><a name="NW4MGyWr-qeBaA-1" href="#NWD1d"><dfn>&lt;note-transfer functions&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b>
extern void move_notes(IrObject *from, IrObject *to);
extern void copy_notes(IrObject *from, IrObject *to);
</pre><p>

The <code>move_notes</code> function removes all annotations from the one object and
attaches them to another, while <code>copy_notes</code> clones the annotations
before attaching them, rather than removing them from the original.
<p>

<h4><a name=toc120><a name="NWD1e">Annotation suppression during printing</a></a></h4>
<p>
The following list contains annotation keys.  This list is used by the
Machine-SUIF printing utilities to keep output free of tedious
annotations.  Most printing passes allow you to override this list and
print all annotations.
<p>
<pre><a name="NW4MGyWr-7OJPK-1" href="#NWD1e"><dfn>&lt;non-printing-note keys&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b>
extern Set&lt;IdString&gt; nonprinting_notes;
</pre><p>


<h3><a name=toc121><a name="NWD1f">Symbol, symbol-table, and type utilities</a></a></h3>
<p>
<h5><a name=toc122>Symbol predicates.</a></h5>
<p>
The following set of predicates on symbols distinguish their scopes.
<p>
<pre><a name="NW4MGyWr-1p07ra-1" href="#NWD1f"><dfn>&lt;symbol predicates&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b>
bool is_global(Sym*);
bool is_external(Sym*);
bool is_defined(Sym*);
bool is_private(Sym*);
bool is_auto(VarSym*);
</pre><p>

Predicate <code>is_global</code> is true of a symbol whose scope is not local to a
procedure.  It works by finding the symbol table to which the symbol
belongs and checking whether its parent is a <code>file_set_block</code> or a
<code>file_block</code>.  The latter objects own the global symbol tables.
<p>
A symbol satisfying <code>is_external</code> lives in the external symbol table at
the <code>file_set_block</code> level, which means it is visible externally.  It may
be defined within the file set or outside of it.
<p>
A symbol satisfying <code>is_defined</code> is a global symbol whose defining
declaration is in the current file set.
<p>
A symbol satisfying <code>is_private</code> lives in the symbol table of a
<code>file_block</code>, which means that it is global, but isn't visible outside of
the file.
<p>
An ``automatic'' variable, one whose symbol satisfies <code>is_auto</code>, is local
to a procedure.
<p>

<h5><a name=toc123><a name="NWD1g">Symbol finders.</a></a></h5>
<p>
<code>lookup_local_var</code> looks up a variable symbol in the current local scope,
while <code>lookup_external_var</code> looks up a variable symbol in the external
scope, i.e., one that is either exported from or imported by the file
currently being compiled.  <code>lookup_external_proc</code> does the same for a
procedure symbol.  In each case, if the symbol is not found, the routine
returns <code>NULL</code>.
<p>
<pre><a name="NW4MGyWr-pr3t1-1" href="#NWD1g"><dfn>&lt;symbol finders&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b>
VarSym* lookup_local_var(IdString name);
VarSym* lookup_external_var(IdString name);
ProcSym* lookup_external_proc(IdString name);
</pre><p>


<h5><a name=toc124><a name="NWD1h">Symbol creators.</a></a></h5>
<p>
These functions each generate a new symbol in the local scope with a name
guaranteed not to clash in that scope.
<p>
<pre><a name="NW4MGyWr-46CRen-1" href="#NWD1h"><dfn>&lt;symbol creators&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[D<a href="#NWD1i">-&gt;</a>]</b>
VarSym* new_named_var(TypeId, IdString name);
VarSym* new_unique_var(TypeId, const char *prefix = &quot;_var&quot;);
VarSym* new_unique_var(Opnd init, const char *prefix = &quot;_var&quot;);
LabelSym* new_unique_label(const char *prefix = &quot;_label&quot;);

VarSym* new_empty_table_var(TypeId elem_type, int length);
VarSym* new_dispatch_table_var(MbrNote&amp;);
</pre><p>

With <code>new_named_var</code>, the resulting variable has exactly the <code>name</code>
given.  With the others, the caller may provide a prefix string for the
new symbol's name.  The name of the resulting symbol has a numeric suffix
that assures uniqueness in the local scope.
<p>
<code>new_named_var</code> and <code>new_unique_var</code> each generate a variable symbol.
If given a type, <code>new_unique_var</code> creates an uninitialized variable with
that type.  When an operand is passed instead of a type, it must be a
numeric-immediate operand.  In that case, the type of the operand becomes
the type of the new variable, and the immediate value becomes its initial
value.
<p>
<code>new_unique_label</code> generates a new local code-label symbol.
<p>
<code>new_empty_table_var</code> creates a new, unique, uninitialized, local
array variable with a given element type and element count.  Such a
variable might be used for saving and restoring a set of registers,
for example.
<p>
<code>new_dispatch_table_var</code> creates and initializes a new unique variable to
<a name="NWD1i">serve as the dispatch table for a multiway branch instruction.  The</a>
annotation passed as its argument carries all the necessary information
about the size of the table and the code labels that become its contents.
As a side effect, this function stores the new variable symbol back into
the argument annotation.
<p>
The following function returns the external procedure symbol having the
given type and name.
<p>
<pre><a name="NW4MGyWr-46CRen-2" href="#NWD1h"><dfn>&lt;symbol creators&gt;+=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[<a href="#NWD1h">&lt;-</a>D]</b>

ProcSym* find_proc_sym(TypeId, IdString name);
</pre><p>

<a name="NWD1j">If such a symbol already exists, it's simply returned.  Otherwise, a new</a>
symbol is created and entered in the external symbol table.
<p>
<h5><a name=toc125>Accessing and changing symbol properties.</a></h5>
<p>
To fetch or store the type of a variable or procedure symbol:
<p>
<pre><a name="NW4MGyWr-2dRZov-1" href="#NWD1j"><dfn>&lt;symbol-property functions&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[D<a href="#NWD1k">-&gt;</a>]</b>
TypeId get_type(VarSym*);
void set_type(VarSym*, TypeId);

TypeId get_type(ProcSym*);
void set_type(ProcSym*, TypeId);
</pre><p>

<a name="NWD1k">To fetch or set the address-taken attribute of a variable:</a>
<p>
<pre><a name="NW4MGyWr-2dRZov-2" href="#NWD1j"><dfn>&lt;symbol-property functions&gt;+=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[<a href="#NWD1j">&lt;-</a>D<a href="#NWD1l">-&gt;</a>]</b>

bool is_addr_taken(VarSym*);
void set_addr_taken(VarSym*, bool);
</pre><p>

<a name="NWD1l">Function </a><code>update_dispatch_table_var</code> updates one target label in the
dispatch table for a multiway branch.  It takes a <code>MbrNote</code> and the
zero-based index of the multiway branch case.  The annotation supplies both
the variable symbol whose definition holds the dispatch table and the new
label for the case at the given index.
<p>
<pre><a name="NW4MGyWr-2dRZov-3" href="#NWD1j"><dfn>&lt;symbol-property functions&gt;+=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[<a href="#NWD1k">&lt;-</a>D<a href="#NWD1m">-&gt;</a>]</b>

void update_dispatch_table_var(MbrNote&amp;, int index);
</pre><p>

<a name="NWD1m">Function </a><code>strip_dispatch_table_var</code> decommisions the dispatch table for a
multiway branch, leaving only a single entry that contains a null label
value.  Again, the <code>MbrNote</code> for the branch is the source of a variable
whose definition gets stripped.
<p>
<pre><a name="NW4MGyWr-2dRZov-4" href="#NWD1j"><dfn>&lt;symbol-property functions&gt;+=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[<a href="#NWD1l">&lt;-</a>D]</b>

void strip_dispatch_table_var(MbrNote&amp;);
</pre><p>



<h5><a name=toc126><a name="NWD1n">Formal parameter helpers.</a></a></h5>
<p>
These functions inspect the formal parameters of an optimization unit.
<p>
<pre><a name="NW4MGyWr-vDH5A-1" href="#NWD1n"><dfn>&lt;formal parameter helpers&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b>
int get_formal_param_count(OptUnit*);
VarSym* get_formal_param(OptUnit*, int pos);
</pre><p>

<h5><a name=toc127><a name="NWD1o">Symbol-table accessors.</a></a></h5>
<p>
<pre><a name="NW4MGyWr-45ApXv-1" href="#NWD1o"><dfn>&lt;symbol-table accessors&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b>
SymTable* external_sym_table();
SymTable* file_set_sym_table();
SymTable* get_sym_table(FileBlock*);
SymTable* get_sym_table(ProcDef*);
</pre><p>

<h5><a name=toc128><a name="NWD1p">Symbol-table predicates.</a></a></h5>
<p>
The following set of predicates on symbol tables identify their level
in the hierarchy.
<p>
<pre><a name="NW4MGyWr-3uDyX3-1" href="#NWD1p"><dfn>&lt;symbol-table predicates&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b>
bool is_global(SymTable*);
bool is_external(SymTable*);
bool is_private(SymTable*);
</pre><p>


<h5><a name=toc129>Taxonomy of types.</a></h5>
<p>
To keep dependence on SUIF's machinery for composing and decomposing type
objects localized, we define functions that operate on a <code>TypeId</code>.  We
make no attempt to cover all of different kinds of type objects that SUIF
provides.  Back end work doesn't make too much use of types.  When others
features are needed, we'll add them.
<p>
SUIF views the type kingdom as consisting of data types, procedure types,
and qualified types.  A data type is the type of a data value other than
code.  A procedure type describes a piece of code that you can call.  A
qualified type is based on a data type, but it describes a storage
location, rather than a value.  To the underlying value type, it adds
qualifiers like <code>const</code> and <code>volatile</code>.  In SUIF, variable symbols,
array elements, and record fields must have qualified type.
<p>
<a name="NWD1q">Most Machine SUIF code does not need to make these distinctions, because</a>
the helpers we define here take care of coercing type-object pointers to
the appropriate subclasses.
<p>

<h5><a name=toc130>Predicates on <code>TypeId</code>'s.</a></h5>
<p>
Here are functions that identify different kinds of types.
<p>
<pre><a name="NW4MGyWr-1uN21Z-1" href="#NWD1q"><dfn>&lt;type helpers&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[D<a href="#NWD1r">-&gt;</a>]</b>
bool is_void(TypeId);
bool is_scalar(TypeId);         // data type other than array or record
bool is_boolean(TypeId);
bool is_integral(TypeId);
bool is_signed(TypeId);         // apply only to an integral type
bool is_floating_point(TypeId);
bool is_pointer(TypeId);
bool is_enum(TypeId);
bool is_record(TypeId);         // e.g., struct or union type
bool is_struct(TypeId);
bool is_union(TypeId);
bool is_array(TypeId);
</pre><p>


<h5><a name=toc131><a name="NWD1r">Properties of typed values.</a></a></h5>
<p>
These functions return the size and the alignment requirement, both
expressed in bits, of the value described by a <code>TypeId</code>.  (To say that a
value must have, e.g., 32-bit alignment means that its address in bytes
must be a multiple of four, i.e., 32/8.)
<p>
<pre><a name="NW4MGyWr-1uN21Z-2" href="#NWD1q"><dfn>&lt;type helpers&gt;+=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[<a href="#NWD1q">&lt;-</a>D<a href="#NWD1s">-&gt;</a>]</b>

int get_bit_size(TypeId);
int get_bit_alignment(TypeId);
</pre><p>

<a name="NWD1s">Once in a while, a back end needs to construct a type identifier.  Here are</a>
functions for creating a pointer type, given the type pointed to (which we
call the <em>referent</em> type), and for extracting the referent type from a
<code>TypeId</code> that is known to be a pointer type.
<p>
<pre><a name="NW4MGyWr-1uN21Z-3" href="#NWD1q"><dfn>&lt;type helpers&gt;+=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[<a href="#NWD1r">&lt;-</a>D<a href="#NWD1t">-&gt;</a>]</b>

TypeId pointer_type(TypeId referent);
TypeId get_referent_type(TypeId);
</pre><p>

<a name="NWD1t">Here's a function that creates an array type from the type of its elements</a>
plus the lower and upper bounds of its index range, and one that extract
the element type of an array type.
<p>
<pre><a name="NW4MGyWr-1uN21Z-4" href="#NWD1q"><dfn>&lt;type helpers&gt;+=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[<a href="#NWD1s">&lt;-</a>D<a href="#NWD1u">-&gt;</a>]</b>

TypeId array_type(TypeId element_type, int lower_bound, int upper_bound);
TypeId get_element_type(TypeId array_type);
</pre><p>

<a name="NWD1u">And this one extracts the result type from a procedure type.</a>
<p>
<pre><a name="NW4MGyWr-1uN21Z-5" href="#NWD1q"><dfn>&lt;type helpers&gt;+=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[<a href="#NWD1t">&lt;-</a>D<a href="#NWD1v">-&gt;</a>]</b>

TypeId get_result_type(TypeId type);
</pre><p>


<h5><a name=toc132><a name="NWD1v">Creating a C procedure type.</a></a></h5>
<p>
Function <code>find_proc_type</code> uses the SUIF type factory to obtain the C
procedure type for a two-argument procedure, given its argument types and
its result type.
<p>
<pre><a name="NW4MGyWr-1uN21Z-6" href="#NWD1q"><dfn>&lt;type helpers&gt;+=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[<a href="#NWD1u">&lt;-</a>D]</b>

TypeId find_proc_type(TypeId result, TypeId arg0, TypeId arg1);
</pre><p>

<h3><a name=toc133><a name="NWD1w">Cloning</a></a></h3>
<p>
Function <code>deep_clone</code> copys one IR object, including all of the
subobjects that it owns.  It is implemented as a template function so that
the result type will always be the same as the argument type.
<p>
<pre><a name="NW4MGyWr-3lNmO3-1" href="#NWD1w"><dfn>&lt;cloning functions&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b>
template&lt;class T&gt;
T*
deep_clone(T *object)
{
    return to&lt;T&gt;(object-&gt;deep_clone(the_suif_env));
}
</pre><p>

<a name="NWD1x">Function </a><code>renaming_clone</code> is used to clone a local IR object (one that is
part of an optimization unit) into a new scope, i.e., one governed by a
different local symbol table.  It takes the object and the symbol table of
the destination scope as arguments.  It returns the cloned object.
<p>
<pre><a name="NW4MGyWr-1f2mQg-1" href="#NWD1x"><dfn>&lt;cloning function&gt;=</dfn></a>

IrObject* renaming_clone(IrObject*, SymTable *receiving_scope);
</pre><p>

Any local symbols found in the object being cloned are themselves cloned
and inserted in the <code>receiving_scope</code> table.  If necessary, their names
are changed to avoid clashes with existing symbols of that scope.
Non-local symbols of the cloned object are not cloned, since they remain in
scope.
<p>
<a name="NWD1y">A typical application for </a><code>renaming_clone</code> is in inlining, where the body
of one procedure is cloned and inserted into the body of another.
<p>

<h3><a name=toc134>A string utility</a></h3>
<p>
Since the <code>strdup</code> function, which returns a fresh copy of a C string,
is not standard, we provide <code>strdupe</code> as a substitute.
<p>
<pre><a name="NW4MGyWr-1xAQgR-1" href="#NWD1y"><dfn>&lt;function <code>strdupe</code>&gt;=</dfn></a>
inline char *
strdupe(const char *s)
{
    int n = strlen(s) + 1;
    char *r = new char[n];
    return (char *)memcpy(r, s, n);
}
</pre><p>

<h3><a name=toc135><a name="NWD1z">A hashing utility</a></a></h3>
<p>
The hash code generator for <code>long</code> integers, needed by SUIF's hash-map
utility, will eventually be part of base SUIF.  For now:
<p>
<pre><a name="NW4MGyWr-Z9FYU-1" href="#NWD1z"><dfn>&lt;hashing helpers&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b>
size_t hash(const unsigned long);
</pre><p>

<h3><a name=toc136><a name="NWD20">Printing utilities</a></a></h3>
<p>
Our convention in the OPI is to overload the function <code>fprint</code> for
printing to a <code>FILE*</code>.  The following variants of <code>fprint</code> print
<code>IrObject</code>s (at least at a quality suitable for debugging) and
extended-precision integers.
<p>
<pre><a name="NW4MGyWr-2jqEIQ-1" href="#NWD20"><dfn>&lt;printing utilities&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b>
void fprint(FILE*, IrObject*);
void fprint(FILE*, Integer);
</pre><p>

<h3><a name=toc137><a name="NWD21">Sequence utilities</a></a></h3>
<p>
Some utilities that apply to STL container objects.  Function <code>clear</code>
makes its list argument empty.
<p>
<pre><a name="NW4MGyWr-24BKoL-1" href="#NWD21"><dfn>&lt;sequence utilities&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[D<a href="#NWD22">-&gt;</a>]</b>
template &lt;class Item&gt;
void clear(list&lt;Item&gt; &amp;l)
{
    l.clear_list();
}
</pre><p>

<a name="NWD22">Function </a><code>get_last_handle</code> returns a handle on the last element of its
list argument, or else the sentinal handle of that list.
<p>
<pre><a name="NW4MGyWr-24BKoL-2" href="#NWD21"><dfn>&lt;sequence utilities&gt;+=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[<a href="#NWD21">&lt;-</a>D<a href="#NW4MGyWr-24BKoL-3">-&gt;</a>]</b>

template &lt;class Item&gt;
list&lt;Item&gt;::iterator
get_last_handle(list&lt;Item&gt; &amp;l)
{
    return l.get_nth(l.size() - 1);
}
</pre><p>

<pre><a name="NW4MGyWr-24BKoL-3" href="#NWD21"><dfn>&lt;sequence utilities&gt;+=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[<a href="#NWD22">&lt;-</a>D<a href="#NW4MGyWr-24BKoL-4">-&gt;</a>]</b>

template &lt;class Item&gt;
list&lt;Item&gt;::iterator
find(list&lt;Item&gt; &amp;l, const Item &amp;item)
{
    for (list&lt;Item&gt;::iterator h = l.begin(); h != l.end(); ++h)
        if (*h == item)
            return h;
    return l.end();
}
</pre><p>

<pre><a name="NW4MGyWr-24BKoL-4" href="#NWD21"><dfn>&lt;sequence utilities&gt;+=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[<a href="#NW4MGyWr-24BKoL-3">&lt;-</a>D<a href="#NWD23">-&gt;</a>]</b>

template &lt;class Item&gt;
bool
contains(list&lt;Item&gt; &amp;l, const Item &amp;item)
{
    return find(l, item) != l.end();
}
</pre><p>

<a name="NWD23">Function </a><code>maybe_expand</code> makes sure that a vector's size is large enough
to cover an entry at <code>index</code>.  If not, it resizes the vector to cover
<code>index</code>.  Argument <code>init</code> provides an initial value for any added
elements.
<p>
<pre><a name="NW4MGyWr-24BKoL-5" href="#NWD21"><dfn>&lt;sequence utilities&gt;+=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[<a href="#NW4MGyWr-24BKoL-4">&lt;-</a>D<a href="#NWD24">-&gt;</a>]</b>

template &lt;class Item&gt;
void
maybe_expand(Vector&lt;Item&gt; &amp;v, size_t index, const Item &amp;init)
{
    if (index &gt;= v.size())
        v.resize(index + 1, init);
}
</pre><p>

<a name="NWD24">Function </a><code>end_splice</code> works around the lack of a <code>splice</code> method in the
<code>suif_list</code> template.  It moves the elements of its second argument to
the end of the first, leaving the donor list empty.  In the real STL, this
can be done in constant time.
<p>
<pre><a name="NW4MGyWr-24BKoL-6" href="#NWD21"><dfn>&lt;sequence utilities&gt;+=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b> <b>[<a href="#NWD23">&lt;-</a>D]</b>

template &lt;class Item&gt;
void
end_splice(List&lt;Item&gt; &amp;l, List&lt;Item&gt; &amp;x)
{
    while (!x.empty())
    {
        l.insert(l.end(), x.front());
        x.pop_front();
    }
}
</pre><p>


<h3><a name=toc138><a name="NWD25">Miscellany</a></a></h3>
<p>
The following are handy when changing the representation of a optimization
unit from instruction-list to, say, CFG form.
<p>
<pre><a name="NW4MGyWr-4Cn9wk-1" href="#NWD25"><dfn>&lt;optimization-unit body functions&gt;=</dfn></a> <b>(<a href="#NWD26">U-&gt;</a>)</b>
AnyBody* get_body(OptUnit*);
void set_body(OptUnit*, AnyBody*);
</pre><p>


<h3><a name=toc139><a name="NWD26">Header file </a><code>util.h</code></a></h3>
<p>
The header file for module <code>util</code> has the following layout.
<p>
<pre><a name="NW4MGyWr-YY0Ch-1" href="#NWD26"><dfn>&lt;machine/util.h&gt;=</dfn></a>
/* file &quot;machine/util.h&quot; */

<a name="NW4MGyWr-YY0Ch-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_UTIL_H
#define MACHINE_UTIL_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/util.h&quot;
#endif

#include &lt;machine/substrate.h&gt;
#include &lt;machine/machine_ir.h&gt;
#include &lt;machine/opnd.h&gt;
#include &lt;machine/note.h&gt;

<a name="NW4MGyWr-YY0Ch-1-u2" href="#NWD1a"><i>&lt;class <code>OpndFilter</code>&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u3" href="#NWD1b"><i>&lt;function <code>map_opnds</code>&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u4" href="#NWD1c"><i>&lt;parameter-register utilities&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u5" href="#NWD1n"><i>&lt;formal parameter helpers&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u6" href="#NWD1d"><i>&lt;note-transfer functions&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u7" href="#NWD1e"><i>&lt;non-printing-note keys&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u8" href="#NWD1f"><i>&lt;symbol predicates&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u9" href="#NWD1g"><i>&lt;symbol finders&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u10" href="#NWD1h"><i>&lt;symbol creators&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u11" href="#NWD1j"><i>&lt;symbol-property functions&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u12" href="#NWD1q"><i>&lt;type helpers&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u13" href="#NWD1p"><i>&lt;symbol-table predicates&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u14" href="#NWD1o"><i>&lt;symbol-table accessors&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u15" href="#NWD1w"><i>&lt;cloning functions&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u16" href="#NWD1z"><i>&lt;hashing helpers&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u17" href="#NWD20"><i>&lt;printing utilities&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u18" href="#NWD21"><i>&lt;sequence utilities&gt;</i></a>

<a name="NW4MGyWr-YY0Ch-1-u19" href="#NWD25"><i>&lt;optimization-unit body functions&gt;</i></a>

#endif /* MACHINE_UTIL_H */
</pre><p>
<h2><a name=toc140>Contexts</a></h2>
<a name="sec:Contexts"><b>[*]</b></a>
<p>
As mentioned in Section&nbsp;<a href="#sec:extension-bases">[&lt;-]</a>, a <em>context</em> gathers
all the items that characterize the target machine into one record.  OPI
programmers don't need to concern themselves with the context data
structure; they only need to keep it set correctly for the current target.
But users who add target-machine descriptions do so by developing a refined
context that holds the characteristics of the machine they want to add.
<p>
Machine SUIF deals with only one context at a time, because compilation
typically deals with only one kinds of machine at a time.  For the rare
cases in which two machine descriptions might be needed simultaneously, you
divide the task into two phases, one for each machine.
<p>
As an OPI programmer, you see target characteristics through global
functions and through the data structures that they return.  Function
<code>target_printer</code>, which returns a <code>Printer</code> pointer, is typical.  But all
this function does is to access <code>the_context</code>, a global variable of type
<code>Context*</code>.  This global context has a method named <code>target_printer</code> that
provides the implementation of the global function, which calls that
method.
<p>
So why not call such methods of <code>the_context</code> directly?  For one thing,
it's shorter to write calls on global functions, and these things occur
quite frequently.  More importantly, the context is not needed in some
compilation settings, such as run-time optimization.  So for portability,
code written against the OPI should be almost ``context free''.
<p>
But there is still another reason why context methods are not accessed in
OPI code.  It has to do with the way contexts are built for extensibility.
Class <code>Context</code> itself has no interesting functionality.  The
<code>target_printer</code> method is actually declared in another class, called
<code>MachineContext</code>.  It is an interface class: <code>target_printer</code> and other
public methods are pure virtual methods.  <code>MachineContext</code> is not a
subclass of <code>Context</code>.  It is a chunk of interface that target libraries
use when composing an actual context instance that is right for the target
in question.  The method of composition is multiple inheritance.  A typical
concrete context inherits from <code>Context</code>, <code>MachineContext</code>, and
<code>SuifVmContext</code>.  (Context-interface classes are named for the libraries
that define them: <code>MachineContext</code> is defined in the <code>machine</code> library,
<code>SuifVmContext</code> in the <code>suifvm</code> library, and so on.)
<p>
So while the declared type of <code>the_context</code> is <code>Context*</code>, it normally
points to an object whose class inherits not only from <code>Context</code>, but
also from several interface classes.  A method such as <code>target_printer</code> is
invoked by casting <code>the_context</code> to type <code>MachineContext*</code>:
<p>
<pre>
    dynamic_cast&lt;MachineContext*&gt;(the_context)-&gt;target_printer();
</pre>

Further motivation and a description of how we use multiple inheritance
from independent context-interface classes, together with dynamic casting
based on run-time type information (RTTI), can be found in the
<em>Extender's Guide</em>.
<p>

<h3><a name=toc141><a name="NWD27">Establishing context</a></a></h3>
<a name="sec:establishing-context"><b>[*]</b></a>
<p>
Any Machine-SUIF pass that calls one or more target-characterization
functions must first set <code>the_context</code>.  This is accomplished by calling
<code>focus(FileBlock*)</code>, which sets <code>the_context</code> using the
<code>target_context</code> function.
<p>
<pre><a name="NW14HCqf-15qAPT-1" href="#NWD27"><dfn>&lt;context creation&gt;=</dfn></a> <b>(<a href="#NWD2K">U-&gt;</a>)</b>
extern Context *the_context;

Context* target_context(FileBlock*);
Context* find_context(IdString lib_name);
</pre><p>

<a name="NWD28">Function </a><code>target_context</code> expects to find a <code>target_lib</code> note on its
file-block argument giving the name of the target-specific library for the
file.  It calls <code>find_context</code> to obtain the corresponding context.  If
necessary <code>find_context</code> loads that library.  The library's
initialization code registers a function that creates a new
target-characterization context.  It registers this context-creator
function in the following map:
<p>
<pre><a name="NW14HCqf-2GEnCB-1" href="#NWD28"><dfn>&lt;context-creator registry&gt;=</dfn></a> <b>(<a href="#NWD2K">U-&gt;</a>)</b>

extern Map&lt;IdString,Context*(*)()&gt; the_context_creator_registry;
</pre><p>

Most passes have no need to be aware of <code>the_context</code> or the
<code>target_lib</code> annotation; the latter is attached by a code-generation pass
and is usually retained through subsequent phases.  There is no need to
delete <code>the_context</code> at the end of the pass; <code>target_context</code> builds a
cache, so that context records are reused while compilation is going on and
then deleted all at once when a pass terminates.
<p>


<h3><a name=toc142><a name="NWD29">Class </a><code>Context</code></a></h3>
<p>
<code>Context</code> is an empty interface class.  It is used as a completely
library-independent handle on the current library-created context.
Although it is not expected to have subclasses, we give it a virtual
destructor.  That's because the C++ RTTI machinery can only navigate to
so-called ``polymorphic'' classes, which means those having virtual
methods.
<p>
<pre><a name="NW14HCqf-nKzAs-1" href="#NWD29"><dfn>&lt;class <code>Context</code>&gt;=</dfn></a> <b>(<a href="#NWD2K">U-&gt;</a>)</b>
class Context {
  public:
    Context() { }
    virtual ~Context() { }
};
</pre><p>


<h3><a name=toc143><a name="NWD2A">Class </a><code>MachineContext</code></a></h3>
<p>
Class <code>MachineContext</code> is a non-trivial interface class.  It declares the
virtual methods for instruction properties and register properties.  Note
that it is <em>not</em> derived fron <code>Context</code>.
<p>
<pre><a name="NW14HCqf-pPagH-1" href="#NWD2A"><dfn>&lt;class <code>MachineContext</code>&gt;=</dfn></a> <b>(<a href="#NWD2K">U-&gt;</a>)</b>
class MachineContext {
  public:
    MachineContext();
    virtual ~MachineContext();

    <a name="NW14HCqf-pPagH-1-u1" href="#NWD2B"><i>&lt;<code>MachineContext</code> generic-pointer method&gt;</i></a>

    <a name="NW14HCqf-pPagH-1-u2" href="#NWD2C"><i>&lt;<code>MachineContext</code> register-info methods&gt;</i></a>

    <a name="NW14HCqf-pPagH-1-u3" href="#NWD2D"><i>&lt;<code>MachineContext</code> printer methods&gt;</i></a>

    <a name="NW14HCqf-pPagH-1-u4" href="#NWD2F"><i>&lt;<code>MachineContext</code> code-finalizer method&gt;</i></a>

    <a name="NW14HCqf-pPagH-1-u5" href="#NWD2G"><i>&lt;<code>MachineContext</code> instruction-predicate methods&gt;</i></a>

    <a name="NW14HCqf-pPagH-1-u6" href="#NWD2H"><i>&lt;<code>MachineContext</code> opcode-generator methods&gt;</i></a>

    <a name="NW14HCqf-pPagH-1-u7" href="#NWD2I"><i>&lt;<code>MachineContext</code> opcode query methods&gt;</i></a>

  protected:
    <a name="NW14HCqf-pPagH-1-u8" href="#NWD2J"><i>&lt;<code>MachineContext</code> protected matter&gt;</i></a>
};
</pre><p>

<h5><a name=toc144><a name="NWD2B">Target-characterization methods.</a></a></h5>
<p>
The target's generic-pointer type, the value produced by function
<code>type_addr</code> (see Section&nbsp;<a href="#sec:types">[&lt;-]</a>), is fetched by:
<p>
<pre><a name="NW14HCqf-2UGca5-1" href="#NWD2B"><dfn>&lt;<code>MachineContext</code> generic-pointer method&gt;=</dfn></a> <b>(<a href="#NWD2A">&lt;-U</a>)</b>
    virtual TypeId type_addr() const = 0;
</pre><p>

<a name="NWD2C">In addition, the following methods implement like-named functions for use</a>
by register allocators (Section&nbsp;<a href="#sec-reg-desc">[&lt;-]</a>):
<p>
<pre><a name="NW14HCqf-3WB842-1" href="#NWD2C"><dfn>&lt;<code>MachineContext</code> register-info methods&gt;=</dfn></a> <b>(<a href="#NWD2A">&lt;-U</a>)</b>
    virtual int reg_count() const
        { claim(false); return -1; }
    virtual const char* reg_name(int reg) const
        { claim(false); return NULL; }
    virtual int reg_width(int reg) const
        { claim(false); return -1; }
    virtual const NatSet* reg_aliases(int reg) const
        { claim(false); return NULL; }

    virtual int reg_class_count() const
        { claim(false); return -1; }
    virtual const NatSet* reg_members(RegClassId) const
        { claim(false); return NULL; }
    virtual const NatSet* reg_allocables(bool maximals = false) const
        { claim(false); return NULL; }
    virtual const NatSet* reg_caller_saves(bool maximals = false) const
        { claim(false); return NULL; }
    virtual const NatSet* reg_callee_saves(bool maximals = false) const
        { claim(false); return NULL; }
    virtual int reg_maximal(int reg) const
        { return reg; }
    virtual InstrHandle reg_fill(Opnd dst, Opnd src, InstrHandle marker,
                                 bool post_reg_alloc = false) const
        { claim(false); return marker; }
    virtual InstrHandle reg_spill(Opnd dst, Opnd src, InstrHandle marker,
                                  bool post_reg_alloc = false) const
        { claim(false); return marker; }
    virtual void reg_classify(Instr*, OpndCatalog*, RegClassMap*) const
        { claim(false); }
    virtual RegClassId reg_class_intersection(RegClassId, RegClassId) const
        { claim(false); return REG_CLASS_NONE; }
    virtual int reg_choice(RegClassId, const NatSet *pool,
                           const NatSet *excluded, bool rotate) const
        { claim(false); return -1; }
</pre><p>

<a name="NWD2D">The target's </a><code>Printer</code> pointer, which corresponds to global variable
<code>printer</code> (Section&nbsp;<a href="#sec:printer">[&lt;-]</a>), is fetched by:
<p>
<pre><a name="NW14HCqf-koHWU-1" href="#NWD2D"><dfn>&lt;<code>MachineContext</code> printer methods&gt;=</dfn></a> <b>(<a href="#NWD2A">&lt;-U</a>)</b> <b>[D<a href="#NWD2E">-&gt;</a>]</b>
    virtual Printer* target_printer() const = 0;
</pre><p>

<a name="NWD2E">And similarly for its </a><code>CPrinter</code> pointer:
<p>
<pre><a name="NW14HCqf-koHWU-2" href="#NWD2D"><dfn>&lt;<code>MachineContext</code> printer methods&gt;+=</dfn></a> <b>(<a href="#NWD2A">&lt;-U</a>)</b> <b>[<a href="#NWD2D">&lt;-</a>D]</b>
    virtual CPrinter* target_c_printer() const = 0;
</pre><p>

<a name="NWD2F">The target's </a><code>CodeFin</code> generator, which corresponds to global function
<code>target_code_fin</code> (Section&nbsp;<a href="#sec:CodeFin">[&lt;-]</a>), is fetched by the method:
<p>
<pre><a name="NW14HCqf-f0oum-1" href="#NWD2F"><dfn>&lt;<code>MachineContext</code> code-finalizer method&gt;=</dfn></a> <b>(<a href="#NWD2A">&lt;-U</a>)</b>
    virtual CodeFin* target_code_fin() const = 0;
</pre><p>

<a name="NWD2G">The target-specific instruction predicates described in</a>
Section&nbsp;<a href="#sec:machine-instr-predicates">[&lt;-]</a> are implemented by like-named
methods of <code>MachineContext</code>.
<p>
<pre><a name="NW14HCqf-48lOfA-1" href="#NWD2G"><dfn>&lt;<code>MachineContext</code> instruction-predicate methods&gt;=</dfn></a> <b>(<a href="#NWD2A">&lt;-U</a>)</b>
    virtual bool is_ldc(Instr*) const = 0;
    virtual bool is_move(Instr*) const = 0;
    virtual bool is_cmove(Instr*) const = 0;
    virtual bool is_predicated(Instr*) const { return false; }
    virtual bool is_line(Instr*) const = 0;
    virtual bool is_ubr(Instr*) const = 0;
    virtual bool is_cbr(Instr*) const = 0;
    virtual bool is_call(Instr*) const = 0;
    virtual bool is_return(Instr*) const = 0;
    virtual bool is_binary_exp(Instr*) const = 0;
    virtual bool is_unary_exp(Instr*) const = 0;
    virtual bool is_commutative(Instr*) const = 0;
    virtual bool is_two_opnd(Instr*) const = 0;
    virtual bool reads_memory(Instr*) const = 0;
    virtual bool writes_memory(Instr*) const = 0;
    virtual bool is_builtin(Instr*) const = 0;
</pre><p>

<a name="NWD2H">The target-specific opcode generators described in</a>
Section&nbsp;<a href="#sec:machine-opcodes">[&lt;-]</a> are implemented by like-named methods of
<code>MachineContext</code>.
<p>
<pre><a name="NW14HCqf-4gGpPT-1" href="#NWD2H"><dfn>&lt;<code>MachineContext</code> opcode-generator methods&gt;=</dfn></a> <b>(<a href="#NWD2A">&lt;-U</a>)</b>
    virtual int opcode_line() const = 0;
    virtual int opcode_ubr() const = 0;
    virtual int opcode_move(TypeId) const = 0;
    virtual int opcode_load(TypeId) const = 0;
    virtual int opcode_store(TypeId) const = 0;
    virtual int opcode_cbr_inverse(int cbr_opcode) const = 0;
</pre><p>

<a name="NWD2I">Likewise for the functions that ask target-specific questions about</a>
opcodes.
<p>
<pre><a name="NW14HCqf-33M5lU-1" href="#NWD2I"><dfn>&lt;<code>MachineContext</code> opcode query methods&gt;=</dfn></a> <b>(<a href="#NWD2A">&lt;-U</a>)</b>
    virtual bool target_implements(int opcode) const = 0;
    virtual char* opcode_name(int opcode) const = 0;
</pre><p>


<h5><a name=toc145><a name="NWD2J">Protected fields.</a></a></h5>
<a name="sec:context-implementation"><b>[*]</b></a>
<p>
Class <code>MachineContext</code> is not quite a pure abstract interface.  For the
convenience of target-library implementors, it contains fields for caching
the heap-allocated data objects that may be produced through the interface.
These are owned by the context and are deleted when it is destructed.
<p>
<pre><a name="NW14HCqf-21uIox-1" href="#NWD2J"><dfn>&lt;<code>MachineContext</code> protected matter&gt;=</dfn></a> <b>(<a href="#NWD2A">&lt;-U</a>)</b>
    mutable Printer *cached_printer;
    mutable CPrinter *cached_c_printer;
    mutable CodeFin *cached_code_fin;
</pre><p>


<h3><a name=toc146><a name="NWD2K">Header file </a><code>contexts.h</code></a></h3>
<p>
The header file for contexts has the following outline:
<p>
<pre><a name="NW14HCqf-1e46Vq-1" href="#NWD2K"><dfn>&lt;machine/contexts.h&gt;=</dfn></a>
/* file &quot;machine/contexts.h&quot; */

<a name="NW14HCqf-1e46Vq-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_CONTEXT_H
#define MACHINE_CONTEXT_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/contexts.h&quot;
#endif

#include &lt;machine/substrate.h&gt;
#include &lt;machine/problems.h&gt;
#include &lt;machine/opnd.h&gt;
#include &lt;machine/instr.h&gt;
#include &lt;machine/reg_info.h&gt;
#include &lt;machine/code_fin.h&gt;
#include &lt;machine/printer.h&gt;
#include &lt;machine/c_printer.h&gt;

<a name="NW14HCqf-1e46Vq-1-u2" href="#NWD29"><i>&lt;class <code>Context</code>&gt;</i></a>

<a name="NW14HCqf-1e46Vq-1-u3" href="#NWD2A"><i>&lt;class <code>MachineContext</code>&gt;</i></a>

<a name="NW14HCqf-1e46Vq-1-u4" href="#NWD27"><i>&lt;context creation&gt;</i></a>

<a name="NW14HCqf-1e46Vq-1-u5" href="#NWD28"><i>&lt;context-creator registry&gt;</i></a>

#endif /* MACHINE_CONTEXT_H */
</pre><p>
<h2><a name=toc147>Substrate Encapsulation</a></h2>
<a name="sec:substrate-encapsulation"><b>[*]</b></a>
<p>
As has mentioned earlier, Machine SUIF can be viewed as an implementation
of the OPI on a substrate consisting of C++ library facilities and the core
of the Stanford SUIF infrastructure.  The <code>machine</code> library serves as the
layer that encapsulates the substrate for the rest of Machine SUIF, so that
libraries and passes are easy to move to OPI implementations that are based
on different substrates.
<p>
This section collects a number of declarations that help with substrate
encapsulation.  The header file (<code>substrate.h</code>) that it generates doesn't
depend on any OPI types defined elsewhere.  It is meant to be included by
other modules in the <code>machine</code> library, including the hoof-generated
module that defines many of the IR types in the OPI.
<p>
The <code>substrate.h</code> header file is also included by <code>machine.h</code>, which
<a name="NWD2L">collects the exports of the </a><code>machine</code> library.  Clients of the library
therefore see these declarations when they include <code>machine.h</code>.
<p>

<h3><a name=toc148>OPI Types</a></h3>
<p>
Several OPI types are implemented in Machine SUIF as synonyms for SUIF
types.
<p>
<pre><a name="NWHV9l7-3Ohl4Y-1" href="#NWD2L"><dfn>&lt;renamed types&gt;=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b>
typedef AnnotableObject IrObject;
typedef ProcedureSymbol ProcSym;
typedef ProcedureDefinition ProcDef;
typedef ProcedureDefinition OptUnit;
typedef PointerType PtrType;
typedef Symbol Sym;
typedef SymbolTable SymTable;
typedef SymbolTable ScopeTable;
typedef VariableSymbol VarSym;
typedef VariableDefinition VarDef;
typedef CodeLabelSymbol LabelSym;
</pre><p>

<a name="NWD2M">Since the OPI's type abstraction, </a><code>TypeId</code>, is used without an explicit
level of indirection, we make it a synonym for <code>Type*</code> instead of
<code>Type</code>.
<p>
<pre><a name="NWHV9l7-1tShze-1" href="#NWD2M"><dfn>&lt;type <code>TypeId</code>&gt;=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b>
typedef Type* TypeId;
</pre><p>

<h3><a name=toc149><a name="NWD2N">Class </a><code>Integer</code></a></h3>
<p>
In order to support cross-compilation without being limited by the host's
numeric characteristics, the OPI makes use of extended-precision integers.
The implementation of OPI-class <code>Integer</code> derives from SUIF's
infinite-integer class.
<p>
<pre><a name="NWHV9l7-3kMQe4-1" href="#NWD2N"><dfn>&lt;class <code>Integer</code>&gt;=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b>
class Integer : public IInteger {
  public:
    Integer() { }                               // returns the empty string
    Integer(const char *chars)                  : IInteger(chars) { }
    Integer(const IInteger &amp;i_integer)          : IInteger(i_integer) { }

    Integer(signed char integral)               : IInteger(integral) { }
    Integer(unsigned char integral)             : IInteger(integral) { }
    Integer(short integral)                     : IInteger(integral) { }
    Integer(unsigned short integral)            : IInteger(integral) { }
    Integer(int integral)                       : IInteger(integral) { }
    Integer(unsigned int integral)              : IInteger(integral) { }
    Integer(long integral)                      : IInteger(integral) { }
    Integer(unsigned long integral)             : IInteger(integral) { }
#ifdef LONGLONG
    Integer(LONGLONG integral)                  : IInteger(integral) { }
    Integer(unsigned LONGLONG integral)         : IInteger(integral) { }
#endif
    Integer(const char *initial_string, int base = 10);

    const char* chars() const { return c_string_int(); }
};
</pre><p>


<h3><a name=toc150><a name="NWD2O">Class </a><code>IdString</code></a></h3>
<p>
The OPI class <code>IdString</code> derived directly from SUIF's ``lexicon string''
class.  Values are hashed into a global lexicon, so that comparison for
equality takes place in constant time.
<p>
<pre><a name="NWHV9l7-3VI5TO-1" href="#NWD2O"><dfn>&lt;class <code>IdString</code>&gt;=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b>

class IdString : public LString {
  public:
    IdString() { }                              // returns the empty string
    IdString(const IdString &amp;id_string) : LString(id_string) { }
    IdString(const LString &amp;l_string)   : LString(l_string) { }
    IdString(const String &amp;string)      : LString(string) { }
    IdString(const char *chars)         : LString(chars) { }

    const char* chars() const { return c_str(); }
    bool is_empty()     const { return length() == 0; }
};

extern const IdString empty_id_string;
</pre><p>

<a name="NWD2P">We provide a less-than operator on </a><code>IdString</code> values in a manner that
allows them to be used in STL sets and maps.
<p>
<pre><a name="NWHV9l7-49oQed-1" href="#NWD2P"><dfn>&lt;string function&gt;=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b>
namespace std {
class less&lt;IdString&gt; : public binary_function&lt;IdString, IdString, bool&gt; {
  public:
    bool operator()(const IdString &amp;s1, const IdString &amp;s2) const
        { return s1.get_ordinal() &lt; s2.get_ordinal(); }
};
}
</pre><p>



<h3><a name=toc151><a name="NWD2Q">Living with C++ Container Classes</a></a></h3>
<p>
<h5><a name=toc152>SUIF's STL substitutes.</a></h5>
<p>
To counteract the vagaries of C++ implementations, SUIF has its own
STL-like container classes.  In order to be free to switch between the
native STL classes and SUIF's substitutes, Machine SUIF uses its own
container names.
<p>
<pre><a name="NWHV9l7-1Iw1Ig-1" href="#NWD2Q"><dfn>&lt;container-class defines&gt;=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b>
#define List list
#define Vector vector
#define Set set
#define Map map
#define HashMap suif_hash_map
</pre><p>


<h5><a name=toc153><a name="NWD2R">Iterator arithmetic.</a></a></h5>
<p>
A certain kind of C++ container-class ``iterator'' can be incremented or
decremented but can't be used in other pointer arithmetic.  The following
functions can be applied to such an iterator (which in OPI jargon we call a
<em>handle</em>) to produce a handle on the preceding or following element
without side-affecting the argument.
<p>
<pre><a name="NWHV9l7-1Ez0T9-1" href="#NWD2R"><dfn>&lt;iterator helpers&gt;=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b>
template &lt;class Iterator&gt;
Iterator
before(Iterator iterator)
{
    return --iterator;
}

template &lt;class Iterator&gt;
Iterator
after(Iterator iterator)
{
    return ++iterator;
}
</pre><p>




<h3><a name=toc154><a name="NWD2S">C++ and Base SUIF Header Files</a></a></h3>
<p>
This module takes care of including header C++ and base SUIF header files
that are widely used in Machine SUIF.  When adding a new C++ module to the
system, it is usually not necessary to worry about its dependence any
specific substrate header files, since they come in via inclusion of
<code>&lt;machine/machine.h&gt;</code>.
<p>
<pre><a name="NWHV9l7-1faL2S-1" href="#NWD2S"><dfn>&lt;substrate header includes&gt;=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b>
#include &lt;stdlib.h&gt;
#include &lt;set.h&gt;
#include &lt;map.h&gt;
#include &lt;functional&gt;
                                // Following suppresses inclusion of &lt;vector&gt;
                                // under SGI STL, which defines bit_vector,
                                // which conflicts with a basesuif typedef.
#define __SGI_STL_VECTOR
#include &lt;vector.h&gt;

#include &lt;common/i_integer.h&gt;
#include &lt;common/formatted.h&gt;
#include &lt;common/suif_vector.h&gt;
#include &lt;common/suif_list.h&gt;
#include &lt;common/suif_map.h&gt;
#include &lt;common/suif_indexed_list.h&gt;
#include &lt;bit_vector/bit_vector.h&gt;
#include &lt;utils/type_utils.h&gt;
#include &lt;utils/symbol_utils.h&gt;
#include &lt;utils/expression_utils.h&gt;
extern &quot;C&quot; void init_utils(SuifEnv*);

#include &lt;suifkernel/suif_env.h&gt;
#include &lt;suifkernel/dll_subsystem.h&gt;
#include &lt;suifkernel/command_line_parsing.h&gt;
#include &lt;basicnodes/basic.h&gt;
#include &lt;basicnodes/basic_constants.h&gt;
#include &lt;suifnodes/suif.h&gt;
#include &lt;typebuilder/type_builder.h&gt;
#include &lt;suifcloning/cloner.h&gt;

#include &lt;basicnodes/basic_factory.h&gt;
#include &lt;suifnodes/suif_factory.h&gt;
</pre><p>



<h3><a name=toc155>Accessing SUIF Value Descriptors</a></h3>
<p>
SUIF has a number of IR classes devoted to describing static data values
such as those that appear in C initializers.  These are rarely used in
Machine SUIF, and they ought to be better encapsulated than they are at
present.  Meanwhile, here are some functions used for access SUIF's value
<a name="NWD2T">descriptors.  The important classes are </a><code>ValueBlock</code>, which is the root
class for value descriptions, and <code>VarDef</code> which connects a variable
symbol with its statically-defined value (if it has one).  A
<code>MultiValueBlock</code> describes an aggregate of values, while a
<code>RepeatValueBlock</code> represents a series of copies of the same value.
An <code>ExpressionValueBlock</code> used an expression to describe an initial
value.  In this case, the easiest way to extract a description of the value
is to use a Machine SUIF operand.
<p>
<pre><a name="NWHV9l7-2jjv5g-1" href="#NWD2T"><dfn>&lt;accessing value descriptors&gt;=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b>
VarDef* get_def(VarSym*);
ProcSym* get_proc_sym(ProcDef*); 

ValueBlock* get_init(VarDef* d);
int get_bit_alignment(VarDef* d);

int subblocks_size(MultiValueBlock *mvb);

ValueBlock* get_subblock(MultiValueBlock *mvb, int i);

Integer get_subblock_offset(MultiValueBlock *mvb, int i);

int get_repetition_count(RepeatValueBlock *rvb);

ValueBlock* get_subblock(RepeatValueBlock *rvb);

TypeId get_type(ValueBlock *vb);

class Opnd;
Opnd get_value(ExpressionValueBlock *svb);
</pre><p>


<h3><a name=toc156><a name="NWD2U">Miscellany</a></a></h3>
<p>
<h5><a name=toc157>Current compilation environment.</a></h5>
<p>
The following global variable connects to the substrate by recording the
current ``SUIF environment'', which holds the current file set, modules
loaded, object factories, and so on.
<p>
<pre><a name="NWHV9l7-Nkhli-1" href="#NWD2U"><dfn>&lt;SUIF environment&gt;=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b>
extern SuifEnv* the_suif_env;
</pre><p>

<h5><a name=toc158><a name="NWD2V">Extracting the name of a named object.</a></a></h5>
<p>
The overloaded function <code>get_name</code> provides a uniform way to extract the
name of a source file or procedure or to get the name of a symbol or type.
(Symbols and types are instances of SUIF's <code>SymbolTableObject</code> class.)
<p>
<pre><a name="NWHV9l7-1vUb8n-1" href="#NWD2V"><dfn>&lt;function <code>get_name</code>&gt;=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b>
IdString get_name(FileBlock*);
IdString get_name(ProcDef*);
IdString get_name(SymbolTableObject*);
</pre><p>

<h5><a name=toc159><a name="NWD2W">SUIF object-class identification.</a></a></h5>
<p>
SUIF objects are built on a reflection system that allows easy run-time
identification of their classes.  It is useful during debugging to the able
to print the class name of a SUIF object.
<p>
<pre><a name="NWHV9l7-2FHXM2-1" href="#NWD2W"><dfn>&lt;class identification&gt;=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b>
const char* get_class_name(SuifObject*);
</pre><p>


<h5><a name=toc160><a name="NWD2X">An IR-class forward reference.</a></a></h5>
<p>
Class <code>AnyBody</code> requires a forward reference to <code>InstrList</code>.  Since
<code>substrate.h</code> is one of the few headers included before the
hoof-generated OPI types are defined, we include this forward reference
here.
<p>
<pre><a name="NWHV9l7-2S0hfA-1" href="#NWD2X"><dfn>&lt;forward reference&gt;=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b>
class InstrList;
</pre><p>

<h5><a name=toc161><a name="NWD2Y">Command-line option helpers.</a></a></h5>
<p>
Fetching the strings accumulated in an <code>OptionString</code> (one of the
non-terminal descriptor in a SUIF command-line grammar) is a bit clumsy.
This helper abbreviates the procedure a bit.
<p>
<pre><a name="NWHV9l7-3NSjqt-1" href="#NWD2Y"><dfn>&lt;command-line-option helpers&gt;=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b> <b>[D<a href="#NWD2Z">-&gt;</a>]</b>
IdString get_option_string_value(OptionString*, int pos = 0);
</pre><p>

<a name="NWD2Z">The next helper processes zero, one or two files names from a command line.</a>
It uses <code>the_suif_env</code> to decide whether an input file is appropriate and
behaves accordingly.  If no input is in the environment already and there
is at least one name given, it reads the SUIF file into the environment.
If an output file is provided, it returns its name.  Otherwise, it returns
the empty string.
<p>
<pre><a name="NWHV9l7-3NSjqt-2" href="#NWD2Y"><dfn>&lt;command-line-option helpers&gt;+=</dfn></a> <b>(<a href="#NWD2a">U-&gt;</a>)</b> <b>[<a href="#NWD2Y">&lt;-</a>D]</b>

IdString process_file_names(OptionString *file_names);
</pre><p>


<h3><a name=toc162><a name="NWD2a">Header file </a><code>substrate.h</code></a></h3>
<p>
The substrate header file has the following outline:
<p>
<pre><a name="NWHV9l7-3e5Uui-1" href="#NWD2a"><dfn>&lt;machine/substrate.h&gt;=</dfn></a>
/* file &quot;machine/substrate.h&quot; */

<a name="NWHV9l7-3e5Uui-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_SUBSTRATE_H
#define MACHINE_SUBSTRATE_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/substrate.h&quot;
#endif

<a name="NWHV9l7-3e5Uui-1-u2" href="#NWD2S"><i>&lt;substrate header includes&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u3" href="#NWD2X"><i>&lt;forward reference&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u4" href="#NWD2R"><i>&lt;iterator helpers&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u5" href="#NWD2L"><i>&lt;renamed types&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u6" href="#NWD2M"><i>&lt;type <code>TypeId</code>&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u7" href="#NWD2N"><i>&lt;class <code>Integer</code>&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u8" href="#NWD2O"><i>&lt;class <code>IdString</code>&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u9" href="#NWD2P"><i>&lt;string function&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u10" href="#NWD2T"><i>&lt;accessing value descriptors&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u11" href="#NWD2U"><i>&lt;SUIF environment&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u12" href="#NWD2V"><i>&lt;function <code>get_name</code>&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u13" href="#NWD2W"><i>&lt;class identification&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u14" href="#NWD2Y"><i>&lt;command-line-option helpers&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u15" href="#NWD2Q"><i>&lt;container-class defines&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u16" href="#NWD2U"><i>&lt;SUIF environment&gt;</i></a>

<a name="NWHV9l7-3e5Uui-1-u17" href="#NWD2W"><i>&lt;class identification&gt;</i></a>

#endif /* MACHINE_SUBSTRATE_H */
</pre><p>
<h2><a name=toc163><a name="NWD2b">Library initialization</a></a></h2>
<p>
Before you can start using the facilities of the <code>machine</code> library,
the library must initialize some parts of itself.  In SUIF, this is
performed by defining an <code>init_</code><em>libname</em> routine.
<p>
<pre><a name="NW1wzDzq-3mj1NG-1" href="#NWD2b"><dfn>&lt;machine library initialization&gt;=</dfn></a> <b>(<a href="#NWD2d">U-&gt;</a>)</b>
extern &quot;C&quot; void init_machine(SuifEnv* suif_env);
</pre><p>


<a name="NWD2c">We also use the initialization header file as a gathering place for</a>
defining string constants used in Machine SUIF.  These string constants
include those used as the names for annotations.  You should consult the
indicated section, when appropriate, to learn about the meaning and use
of these string constants.
<p>
<pre><a name="NW1wzDzq-1czOWa-1" href="#NWD2c"><dfn>&lt;machine string constants&gt;=</dfn></a> <b>(<a href="#NWD2d">U-&gt;</a>)</b>
extern IdString k_target_lib;           // see contexts.h.nw
extern IdString k_target_type_ptr;      // see types.h.nw
extern IdString k_generic_types;        // see types.h.nw
extern IdString k_enable_exceptions;    // see codegen.cc
extern IdString k_stack_frame_info;     // see codegen.h.nw

extern IdString k_empty_string;         // I.e. &quot;&quot; (used for defaults)

extern IdString k_history;              // Note listing compilation history
extern IdString k_line;                 // Note flagging .line directive

extern IdString k_comment;              // Note containing comment text
extern IdString k_mbr_target_def;       //   &quot;   marking mbr target calculation
extern IdString k_mbr_index_def;        //   &quot;   (deprecated: use preceding key)
extern IdString k_mbr_table_use;        //   &quot;   marking mbr dispatch table use
extern IdString k_instr_mbr_tgts;       //   &quot;   giving mbr case values/labels
extern IdString k_instr_opcode;         //   &quot;   for generic-instr opcode_name
extern IdString k_instr_opcode_exts;    //   &quot;   for opcode extensions
extern IdString k_proc_entry;           //   &quot;   marking procedure entry pt.
extern IdString k_regs_used;            //   &quot;   giving regs used at call
extern IdString k_regs_defd;            //   &quot;   giving regs def'd at call
extern IdString k_instr_ret;            //   &quot;   marking return instruction
extern IdString k_incomplete_proc_exit; //   &quot;   marking incomplete proc exit
extern IdString k_header_trailer;       //   &quot;   on instruction added by fin
extern IdString k_builtin_args;         //   &quot;   giving args for builtin &quot;call&quot;
extern IdString k_param_reg;            //   &quot;   giving hard reg for parameter
extern IdString k_vr_count;             //   &quot;   giving unit's virtual-reg count
extern IdString k_stdarg_offset;        //   &quot;   giving unnamed-arg frame offset

extern IdString k_const;                // keyword &quot;const&quot;

extern IdString k_dense;                // NatSetNote tag
extern IdString k_dense_inverse;        //     &quot;       &quot;
extern IdString k_sparse;               //     &quot;       &quot;
extern IdString k_sparse_inverse;       //     &quot;       &quot;

extern IdString k_call_target;          // Note attaching target symbol to call
extern IdString k_param_init;           //   &quot;  marking instr to init proc param
</pre><p>

<a name="NWD2d">The </a><code>machine</code> library initialization header has the following
layout:
<p>
<pre><a name="NW1wzDzq-2XxT9d-1" href="#NWD2d"><dfn>&lt;machine/init.h&gt;=</dfn></a>
/* file &quot;machine/init.h&quot; */

<a name="NW1wzDzq-2XxT9d-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_INIT_H
#define MACHINE_INIT_H

#include &lt;machine/copyright.h&gt;

#ifdef USE_PRAGMA_INTERFACE
#pragma interface &quot;machine/init.h&quot;
#endif

#include &lt;machine/substrate.h&gt;

<a name="NW1wzDzq-2XxT9d-1-u2" href="#NWD2b"><i>&lt;machine library initialization&gt;</i></a>

<a name="NW1wzDzq-2XxT9d-1-u3" href="#NWD2c"><i>&lt;machine string constants&gt;</i></a>

#endif /* MACHINE_INIT_H */
</pre><p>
<h2><a name=toc164><a name="NWD2e">Header file for the </a><code>machine</code> library</a></h2>
<p>
The following is the header file is for use by other libraries
and passes that depend upon the <code>machine</code> library.  It is
never included in any implementation file within the 
<code>machsuif/machine</code> directory.
<p>
<pre><a name="NWSuH5y-3UwYe4-1" href="#NWD2e"><dfn>&lt;machine/machine.h&gt;=</dfn></a>
/* file &quot;machine/machine.h&quot; */

<a name="NWSuH5y-3UwYe4-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_MACHINE_H
#define MACHINE_MACHINE_H

#include &lt;machine/copyright.h&gt;

#include &lt;machine/substrate.h&gt;
#include &lt;machine/problems.h&gt;
#include &lt;machine/opnd.h&gt;
#include &lt;machine/machine_ir.h&gt;
#include &lt;machine/machine_ir_factory.h&gt;
#include &lt;machine/init.h&gt;
#include &lt;machine/nat_set.h&gt;
#include &lt;machine/note.h&gt;
#include &lt;machine/util.h&gt;
#include &lt;machine/c_printer.h&gt;
#include &lt;machine/instr.h&gt;
#include &lt;machine/reg_info.h&gt;
#include &lt;machine/opcodes.h&gt;
#include &lt;machine/types.h&gt;
#include &lt;machine/printer.h&gt;
#include &lt;machine/code_fin.h&gt;
#include &lt;machine/contexts.h&gt;

#endif /* MACHINE_MACHINE_H */
</pre><p><h2><a name=toc165>Connection to the Base SUIF Pass Mechanism</a></h2>
<p>
<a name="NWD2f">As described in Appendix A of the </a><em>OPI User's Guide</em>, Machine SUIF
passes wrap OPI passes in a layer that connects them to the base SUIF pass
management machinery.
<p>
Header file <code>pass.h</code> is for inclusion by the <code>suif_pass</code> module
associated with each Machine-SUIF pass.  It imports aspects of base SUIF
that are only needed in the pass-wrapping modules, so we put it in a header
file of its own.
<p>
<pre><a name="NWSr0tA-326oYO-1" href="#NWD2f"><dfn>&lt;machine/pass.h&gt;=</dfn></a>
/* file &quot;machine/pass.h&quot; */

<a name="NWSr0tA-326oYO-1-u1" href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>

#ifndef MACHINE_PASS_H
#define MACHINE_PASS_H

#include &lt;machine/copyright.h&gt;

#include &lt;common/suif_vector.h&gt;         // needed by command_line_parsing.h

// Header files for pass construction under SUIF
#include &lt;suifkernel/command_line_parsing.h&gt;
#include &lt;suifkernel/module_subsystem.h&gt;
#include &lt;suifkernel/token_stream.h&gt;
#include &lt;suifpasses/suifpasses.h&gt;

#endif /* MACHINE_PASS_H */
</pre><p><h2><a name=toc166>Hoof Specification of Machine-SUIF IR Classes</a></h2>
<p>
The Machine-SUIF realization of the IR classes in the OPI is expressed
using SUIF's hoof specification language.  Here, we provide only the barest
details of our implementation.  Please see the documentation of SUIF for a
detailed explanation of hoof and its syntax.
<p>

<h3><a name=toc167>Class <code>Instr</code></a></h3>
<p>
Recall the categorization of machine instructions given in
Section&nbsp;<a href="#sec:machine-instructions">[&lt;-]</a>:
<p>
<ul>
<li>Active instructions (real machine operations)
<ul>
<li>(<code>alm</code>) Arithmetic, logical, and memory instructions
<ul>
<li>(<code>alu</code>) Arithmetic and logical
<li>(<code>mem</code>) Load and store
</ul>
<li>(<code>cti</code>) Control-transfer instructions
</ul>
<li>Inactive instructions
<ul>
<li>(<code>label</code>) Label instructions
<li>(<code>dot</code>) Assembler pseudo-operations <b>[</b>
Many assemblers use a leading period (``<code>.</code>'') to
<a name="NWD2g">identify non-code directives.</a><b>]</b> 
</ul>
</ul>
<p>
The implementation classes for machine instructions follow the above
outline and adhere closely to the explanation in
Section&nbsp;<a href="#sec:machine-instructions">[&lt;-]</a>.  As noted there, the only
instruction class that the OPI user sees is <code>Instr</code>.
<p>
<pre><a name="NW3HxCBy-43CFDT-1" href="#NWD2g"><dfn>&lt;class <code>Instr</code> and subclasses&gt;=</dfn></a> <b>(<a href="#NWD2k">U-&gt;</a>)</b>
    abstract Instr : ScopedObject {
        int opcode;
    };

    concrete InstrAlm : Instr {
        vector&lt;IrOpnd* definer&gt; srcs;
        vector&lt;IrOpnd* definer&gt; dsts;
    CPP_DECLARE
      public:
        suif_vector&lt;IrOpnd*&gt;&amp; srcs() { return _srcs; }
        suif_vector&lt;IrOpnd*&gt;&amp; dsts() { return _dsts; }
    CPP_DECLARE
    };

    concrete InstrCti : InstrAlm {
        Symbol* reference target;
    };

    concrete InstrLabel : Instr {
        CodeLabelSymbol* definer label in defined_labels;
    };

    concrete InstrDot : Instr {
        vector&lt;IrOpnd* definer&gt; srcs;
    CPP_DECLARE
      public:
        suif_vector&lt;IrOpnd*&gt;&amp; srcs() { return _srcs; }
    CPP_DECLARE
    };
</pre><p>

Note that operand vectors within an instruction are treated as defining
points for their contents, not as ordinary references.  This ensures that
operands are cloned when the instruction that contains them is cloned.
That is important for mutable operands (currently just address
expressions), which must not be left shared between an original instruction
and its clone.
<p>

<h3><a name=toc168>Class <code>IrOpnd</code></a></h3>
<a name="sec:ir-opnd"><b>[*]</b></a>
<p>
As shown in Section&nbsp;<a href="#sec:opnd-implementation">[&lt;-]</a>, the OPI class <code>Opnd</code>
is implemented in Machine SUIF using a SUIF-like object class called
<code>IrOpnd</code>.  Specifically, the only instance field in an <code>Opnd</code> value is
a pointer to an <code>IrOpnd</code> object.
<p>
<a name="NWD2h">Class </a><code>IrOpnd</code> is hoof-generated.  It has a subclass for each kind of
<code>Opnd</code>.  Each of these subclasses has methods supporting the
implementation of the <code>get_kind</code>, <code>get_type</code>, and equality-testing
functions on operands.  The subclass for address expressions,
<code>OpndAddrExp</code> also provides a cloning method.  (Since these are the only
mutable operands at present, they are the only ones for which cloning is
non-trivial.)
<p>
<pre><a name="NW3HxCBy-1dYjMK-1" href="#NWD2h"><dfn>&lt;class <code>IrOpnd</code>&gt;=</dfn></a> <b>(<a href="#NWD2k">U-&gt;</a>)</b>
    abstract IrOpnd : SymbolTableObject {
        virtual int kind;
        virtual Type* reference type;

    CPP_DECLARE
      public:
        friend class Opnd;
        virtual bool operator==(const IrOpnd &amp;other) const
            { suif_assert(false); return false; }
    CPP_DECLARE
    };
</pre><p>

<pre><a name="NW3HxCBy-zsRrM-1" href="#NW3HxCBy-zsRrM-1"><dfn>&lt;class <code>OpndReg</code>&gt;=</dfn></a> <b>(<a href="#NWD2k">U-&gt;</a>)</b>
    concrete OpndReg : IrOpnd {
        Type* reference type implements type;
        int reg;
    CPP_DECLARE
      public:
        int get_kind() const
            { return (_reg &lt; 0) ? opnd::REG_VIRTUAL : opnd::REG_HARD; }
        virtual bool operator==(const IrOpnd &amp;other) const
            { suif_assert(is_kind_of&lt;OpndReg&gt;(&amp;other));
              return _reg == ((const OpndReg&amp;)other)._reg; }
    CPP_DECLARE
    };
</pre><p>

<pre><a name="NW3HxCBy-4JbUHt-1" href="#NW3HxCBy-4JbUHt-1"><dfn>&lt;class <code>OpndVar</code>&gt;=</dfn></a> <b>(<a href="#NWD2k">U-&gt;</a>)</b>
    concrete OpndVar : IrOpnd {
        VariableSymbol* reference var;
    CPP_DECLARE
      public:
        int   get_kind() const { return opnd::VAR; }
        Type* get_type() const { return _var-&gt;get_type(); }
        virtual bool operator==(const IrOpnd &amp;other) const
            { suif_assert(is_kind_of&lt;OpndVar&gt;(&amp;other));
              return _var == ((const OpndVar&amp;)other)._var; }
    CPP_DECLARE
    };
</pre><p>

<pre><a name="NW3HxCBy-4DGIEv-1" href="#NW3HxCBy-4DGIEv-1"><dfn>&lt;class <code>OpndImmedInteger</code>&gt;=</dfn></a> <b>(<a href="#NWD2k">U-&gt;</a>)</b>
    concrete OpndImmedInteger : IrOpnd {
        Type* reference type implements type;
        IInteger immed;
    CPP_DECLARE
      public:
        int get_kind() const { return opnd::IMMED_INTEGER; }
        virtual bool operator==(const IrOpnd &amp;other) const
            { suif_assert(is_kind_of&lt;OpndImmedInteger&gt;(&amp;other));
              return _immed == ((const OpndImmedInteger&amp;)other)._immed; }
    CPP_DECLARE
    };
</pre><p>

<pre><a name="NW3HxCBy-3X57pL-1" href="#NW3HxCBy-3X57pL-1"><dfn>&lt;class <code>OpndImmedString</code>&gt;=</dfn></a> <b>(<a href="#NWD2k">U-&gt;</a>)</b>
    concrete OpndImmedString : IrOpnd {
        Type* reference type implements type;
        LString immed;
    CPP_DECLARE
      public:
        int get_kind() const { return opnd::IMMED_STRING; }
        virtual bool operator==(const IrOpnd &amp;other) const
            { suif_assert(is_kind_of&lt;OpndImmedString&gt;(&amp;other));
              return _immed == ((const OpndImmedString&amp;)other)._immed; }
    CPP_DECLARE
    };
</pre><p>

<pre><a name="NW3HxCBy-2wVG7U-1" href="#NW3HxCBy-2wVG7U-1"><dfn>&lt;class <code>OpndAddrSym</code>&gt;=</dfn></a> <b>(<a href="#NWD2k">U-&gt;</a>)</b>
    concrete OpndAddrSym : IrOpnd {
        Symbol* reference sym;
    CPP_DECLARE
      public:
        int   get_kind() const { return opnd::ADDR_SYM; }
        Type* get_type() const { return type_addr(); }
        virtual bool operator==(const IrOpnd &amp;other) const
            { suif_assert(is_kind_of&lt;OpndAddrSym&gt;(&amp;other));
              return _sym == ((const OpndAddrSym&amp;)other)._sym; }
    CPP_DECLARE
    };
</pre><p>

<pre><a name="NW3HxCBy-1BJMjK-1" href="#NW3HxCBy-1BJMjK-1"><dfn>&lt;class <code>OpndAddrExp</code> and subclasses&gt;=</dfn></a> <b>(<a href="#NWD2k">U-&gt;</a>)</b>
    abstract OpndAddrExp : IrOpnd {
        int kind implements kind;
        Type* reference deref_type;
        vector&lt;IrOpnd* reference&gt; srcs;
    CPP_DECLARE
      public:
        suif_vector&lt;IrOpnd*&gt;&amp; srcs() { return _srcs; }
        virtual bool operator==(const IrOpnd &amp;) const;
        OpndAddrExp* clone() const;
        Type* get_type() const { return type_addr(); }
    CPP_DECLARE
    CPP_BODY
        bool
        OpndAddrExp::operator==(const IrOpnd &amp;other) const
        {
            suif_assert(get_kind() == other.get_kind());
            const OpndAddrExp &amp;aeo = (const OpndAddrExp&amp;)other;
            if (get_deref_type() != aeo.get_deref_type())
                return false;
            suif_assert(_srcs.size() == aeo._srcs.size());
            suif_vector&lt;IrOpnd*&gt;::const_iterator sit =     _srcs.begin();
            suif_vector&lt;IrOpnd*&gt;::const_iterator oit = aeo._srcs.begin();
            for ( ; sit != _srcs.end(); sit++, oit++)
                if (!(*sit == *oit))
                    return false;
            return true;
        }
        OpndAddrExp* OpndAddrExp::clone() const
        {
            OpndAddrExp *clone = create_opnd_addr_exp(the_suif_env, 0, NULL);
            clone-&gt;set_kind(get_kind());
            clone-&gt;set_deref_type(get_deref_type());
            for (unsigned i = 0; i &lt; get_src_count(); i++)
                clone-&gt;append_src(get_src(i));
            return clone;
        }
    CPP_BODY
    };
</pre><p>


<h3><a name=toc169><a name="NWD2i">Class </a><code>AnyBody</code></a></h3>
<p>
Class <code>AnyBody</code> is the generic type for procedure bodies in Machine SUIF.
Here is how the class is built on top of SUIF.
<p>
<pre><a name="NW3HxCBy-2mj8RO-1" href="#NWD2i"><dfn>&lt;class <code>AnyBody</code>&gt;=</dfn></a> <b>(<a href="#NWD2k">U-&gt;</a>)</b>
concrete AnyBody : ExecutionObject {
    CPP_DECLARE
      public:
        virtual InstrList* to_instr_list() { suif_assert(false); return NULL; }
    CPP_DECLARE
};
</pre><p>


<h3><a name=toc170><a name="NWD2j">Class </a><code>InstrList</code></a></h3>
<p>
The most basic subclass of <code>AnyBody</code> is <code>InstrList</code>, which represents a
simple instruction list.
<p>
<pre><a name="NW3HxCBy-3y4RRX-1" href="#NWD2j"><dfn>&lt;class <code>InstrList</code>&gt;=</dfn></a> <b>(<a href="#NWD2k">U-&gt;</a>)</b>
concrete InstrList : AnyBody {
    list&lt;Instr* owner&gt; instrs;
    CPP_DECLARE
      public:
        list&lt;Instr*&gt;&amp; instrs() { return _instrs; }
        InstrList* to_instr_list();
    CPP_DECLARE
    CPP_BODY
        extern InstrList* instr_list_to_instr_list(InstrList*);
        InstrList*
        InstrList::to_instr_list()
        {
            return instr_list_to_instr_list(this);
        }
    CPP_BODY
};
</pre><p>


<h3><a name=toc171><a name="NWD2k">Overall hoof specification for module </a><code>machine</code></a></h3>
<p>
The combined hoof grammar for the <code>machine</code> module has the following
layout.  (The inclusion of <code>suifnodes/suif.h</code> near the start of module
<code>machine_ir</code> is just for the benefit of <code>machine/substrate.h</code>.)
<p>
<pre><a name="NW3HxCBy-4U4La-1" href="#NWD2k"><dfn>&lt;machine/machine_ir.hoof&gt;=</dfn></a>
# file &quot;machine_ir.hoof&quot;
#
#    Copyright (c) 2000 The President and Fellows of Harvard College
#
#    All rights reserved.
#
#    This software is provided under the ter described in
#    the &quot;machine/copyright.h&quot; include file.


#include &quot;basicnodes/basic.hoof&quot;

module machine_ir {

    include &lt;functional&gt;;
    include &lt;basicnodes/basic.h&gt;;
    include &lt;suifnodes/suif.h&gt;;
    include &lt;machine/substrate.h&gt;;
    include &lt;machine/types.h&gt;;
    include &lt;machine/opnd.h&gt;;

    import basicnodes;

# Universal machine-level ExecutionObject

<a name="NW3HxCBy-4U4La-1-u1" href="#NWD2i"><i>&lt;class <code>AnyBody</code>&gt;</i></a>

# Instruction-list class

<a name="NW3HxCBy-4U4La-1-u2" href="#NWD2j"><i>&lt;class <code>InstrList</code>&gt;</i></a>

# Instruction classes

<a name="NW3HxCBy-4U4La-1-u3" href="#NWD2g"><i>&lt;class <code>Instr</code> and subclasses&gt;</i></a>

# Operand classes

<a name="NW3HxCBy-4U4La-1-u4" href="#NWD2h"><i>&lt;class <code>IrOpnd</code>&gt;</i></a>
<a name="NW3HxCBy-4U4La-1-u5" href="#NW3HxCBy-4JbUHt-1"><i>&lt;class <code>OpndVar</code>&gt;</i></a>
<a name="NW3HxCBy-4U4La-1-u6" href="#NW3HxCBy-zsRrM-1"><i>&lt;class <code>OpndReg</code>&gt;</i></a>
<a name="NW3HxCBy-4U4La-1-u7" href="#NW3HxCBy-4DGIEv-1"><i>&lt;class <code>OpndImmedInteger</code>&gt;</i></a>
<a name="NW3HxCBy-4U4La-1-u8" href="#NW3HxCBy-3X57pL-1"><i>&lt;class <code>OpndImmedString</code>&gt;</i></a>
<a name="NW3HxCBy-4U4La-1-u9" href="#NW3HxCBy-2wVG7U-1"><i>&lt;class <code>OpndAddrSym</code>&gt;</i></a>
<a name="NW3HxCBy-4U4La-1-u10" href="#NW3HxCBy-1BJMjK-1"><i>&lt;class <code>OpndAddrExp</code> and subclasses&gt;</i></a>
}
</pre><p>
<h2><a name=toc172><a name="NWD2l">Copyright</a></a></h2>
All of the code is protected by the following copyright notice.
<p>
<pre><a name="NW4NUaGr-23xQrt-1" href="#NWD2l"><dfn>&lt;Machine-SUIF copyright&gt;=</dfn></a> <b>(<a href="#NWDC">&lt;-U</a> <a href="#NWDe">&lt;-U</a> <a href="#NWDh">&lt;-U</a> <a href="#NWDo">&lt;-U</a> <a href="#NWDx">&lt;-U</a> <a href="#NWD12">&lt;-U</a> <a href="#NWD16">&lt;-U</a> <a href="#NWD1B">&lt;-U</a> <a href="#NWD1J">&lt;-U</a> <a href="#NWD1U">&lt;-U</a> <a href="#NWD1Z">&lt;-U</a> <a href="#NWD26">&lt;-U</a> <a href="#NWD2K">&lt;-U</a> <a href="#NWD2a">&lt;-U</a> <a href="#NWD2d">&lt;-U</a> <a href="#NWD2e">&lt;-U</a> <a href="#NWD2f">&lt;-U</a>)</b>
/*
    Copyright (c) 2000 The President and Fellows of Harvard College

    All rights reserved.

    This software is provided under the terms described in
    the &quot;machine/copyright.h&quot; include file.
*/
</pre><p>


<h2><a name=toc173>Acknowledgments</a></h2>
<p>
This work was supported in part by an DARPA/NSF infrastructure grant
(NDA904-97-C-0225), a NSF Young Investigator award (CCR-9457779), and
a NSF Research Infrastructure award (CDA-9401024).  We also gratefully
acknowledge the generous support of this research by Advanced Micro
Devices, Compaq, Digital Equipment, Hewlett-Packard, International
Business Machines, Intel, and Microsoft.
<p>
<h2><a name=toc174>References</a></h2>
<p>
<a name="NWcite-bibsparseset"><b>[1]</b></a>  P. Briggs and L. Torczon.  An efficient
representation of sparse sets.  <em>ACM Letters on Programming
Languages and Systems</em>, 2(1-4), March-December 1993, pp. 59-70
<p>
<a name="NWcite-bibbvd"><b>[2]</b></a>  G. Holloway and A Dimock.
<em>The Machine-SUIF Bit-vector Data-flow Analysis Library.</em>
The Machine SUIF documentation set, Harvard University,
2002.
<p>
<a name="NWcite-bibcfg"><b>[3]</b></a>  G. Holloway and M. D. Smith.
<em>The Machine-SUIF Control Flow Graph Library</em>
The Machine SUIF documentation set, Harvard University,
2002.
<p>
<a name="NWcite-bibext"><b>[4]</b></a>  G. Holloway and M. D. Smith.  <em>An Extender's
Guide to the Optimization Programming Interface and Target
Descriptions.</em>  The Machine-SUIF documentation set, Harvard
University, 2002.
<p>
<a name="NWcite-bibopiusr"><b><a name="NWD2m">[5]</a></b></a>  G. Holloway and M. D. Smith.  <em>A User's Guide
to the Optimization Programming Interface.</em>  The Machine-SUIF
documentation set, Harvard University, 2002.
<p>



<!-- Make \end{document} a chunk by itself to allow cross-reference info-->
<!-- to be dumped in before it (noweave -delay).-->




<ul>
<li><a href="#NWD1A"><i>&lt;<code>CodeFin</code> protected parts&gt;</i></a>: <a href="#NWD17">U1</a>, <a href="#NWD1A">D2</a>
<li><a href="#NWD14"><i>&lt;<code>CPrinter</code> protected part&gt;</i></a>: <a href="#NWD13">U1</a>, <a href="#NWD14">D2</a>
<li><a href="#NWD4"><i>&lt;<code>Instr</code> creation functions&gt;</i></a>: <a href="#NWD4">D1</a>, <a href="#NWDC">U2</a>
<li><a href="#NWD6"><i>&lt;<code>Instr</code> field accessors&gt;</i></a>: <a href="#NWD6">D1</a>, <a href="#NWDC">U2</a>
<li><a href="#NWD3"><i>&lt;<code>Instr</code> operand accessors and mutators&gt;</i></a>: <a href="#NWD3">D1</a>, <a href="#NWDC">U2</a>
<li><a href="#NWD5"><i>&lt;<code>Instr</code> predicates&gt;</i></a>: <a href="#NWD5">D1</a>, <a href="#NWDC">U2</a>
<li><a href="#NWD7"><i>&lt;<code>Instr</code> print function&gt;</i></a>: <a href="#NWD7">D1</a>, <a href="#NWDC">U2</a>
<li><a href="#NWD9"><i>&lt;<code>InstrHandle</code> definition&gt;</i></a>: <a href="#NWD9">D1</a>, <a href="#NWDC">U2</a>
<li><a href="#NWDA"><i>&lt;<code>InstrList</code> function nicknames&gt;</i></a>: <a href="#NWDA">D1</a>, <a href="#NWDC">U2</a>
<li><a href="#NWD8"><i>&lt;<code>InstrList</code> functions&gt;</i></a>: <a href="#NWD8">D1</a>, <a href="#NWDC">U2</a>
<li><a href="#NWDB"><i>&lt;<code>InstrList</code> print function&gt;</i></a>: <a href="#NWDB">D1</a>, <a href="#NWDC">U2</a>
<li><a href="#NWD2F"><i>&lt;<code>MachineContext</code> code-finalizer method&gt;</i></a>: <a href="#NWD2A">U1</a>, <a href="#NWD2F">D2</a>
<li><a href="#NWD2B"><i>&lt;<code>MachineContext</code> generic-pointer method&gt;</i></a>: <a href="#NWD2A">U1</a>, <a href="#NWD2B">D2</a>
<li><a href="#NWD2G"><i>&lt;<code>MachineContext</code> instruction-predicate methods&gt;</i></a>: <a href="#NWD2A">U1</a>, <a href="#NWD2G">D2</a>
<li><a href="#NWD2I"><i>&lt;<code>MachineContext</code> opcode query methods&gt;</i></a>: <a href="#NWD2A">U1</a>, <a href="#NWD2I">D2</a>
<li><a href="#NWD2H"><i>&lt;<code>MachineContext</code> opcode-generator methods&gt;</i></a>: <a href="#NWD2A">U1</a>, <a href="#NWD2H">D2</a>
<li><a href="#NWD2D"><i>&lt;<code>MachineContext</code> printer methods&gt;</i></a>: <a href="#NWD2A">U1</a>, <a href="#NWD2D">D2</a>, <a href="#NWD2E">D3</a>
<li><a href="#NWD2J"><i>&lt;<code>MachineContext</code> protected matter&gt;</i></a>: <a href="#NWD2A">U1</a>, <a href="#NWD2J">D2</a>
<li><a href="#NWD2C"><i>&lt;<code>MachineContext</code> register-info methods&gt;</i></a>: <a href="#NWD2A">U1</a>, <a href="#NWD2C">D2</a>
<li><a href="#NWD1F"><i>&lt;<code>NatSet</code> extender's interface&gt;</i></a>: <a href="#NWD1E">U1</a>, <a href="#NWD1F">D2</a>
<li><a href="#NWDD"><i>&lt;<code>Opnd</code> common functions&gt;</i></a>: <a href="#NWDD">D1</a>, <a href="#NWDE">D2</a>, <a href="#NWDF">D3</a>, <a href="#NWDG">D4</a>, <a href="#NWDH">D5</a>, <a href="#NWDe">U6</a>
<li><a href="#NWDZ"><i>&lt;<code>Opnd</code> definition&gt;</i></a>: <a href="#NWDZ">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWDc"><i>&lt;<code>OpndCatalog</code> protected parts&gt;</i></a>: <a href="#NWDY">U1</a>, <a href="#NWDc">D2</a>
<li><a href="#NWDa"><i>&lt;<code>OpndHandle</code> definition&gt;</i></a>: <a href="#NWDa">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWD10"><i>&lt;<code>Printer</code> protected part&gt;</i></a>: <a href="#NWDz">U1</a>, <a href="#NWD10">D2</a>
<li><a href="#NWD2T"><i>&lt;accessing value descriptors&gt;</i></a>: <a href="#NWD2T">D1</a>, <a href="#NWD2a">U2</a>
<li><a href="#NWDP"><i>&lt;address-expression-operand functions&gt;</i></a>: <a href="#NWDP">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWDM"><i>&lt;address-operand functions&gt;</i></a>: <a href="#NWDM">D1</a>, <a href="#NWDN">D2</a>, <a href="#NWDe">U3</a>
<li><a href="#NWDO"><i>&lt;address-symbol-operand functions&gt;</i></a>: <a href="#NWDO">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWDu"><i>&lt;allocator support functions&gt;</i></a>: <a href="#NWDu">D1</a>, <a href="#NWDv">D2</a>, <a href="#NWDw">D3</a>, <a href="#NWDx">U4</a>
<li><a href="#NWDQ"><i>&lt;class <code>AddrExpOpnd</code>&gt;</i></a>: <a href="#NWDQ">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWD2i"><i>&lt;class <code>AnyBody</code>&gt;</i></a>: <a href="#NWD2i">D1</a>, <a href="#NWD2k">U2</a>
<li><a href="#NWDT"><i>&lt;class <code>BaseDispOpnd</code>&gt;</i></a>: <a href="#NWDT">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWDV"><i>&lt;class <code>BaseIndexDispOpnd</code>&gt;</i></a>: <a href="#NWDV">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWDU"><i>&lt;class <code>BaseIndexOpnd</code>&gt;</i></a>: <a href="#NWDU">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWDX"><i>&lt;class <code>BaseIndexScaleDispOpnd</code>&gt;</i></a>: <a href="#NWDX">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWD17"><i>&lt;class <code>CodeFin</code>&gt;</i></a>: <a href="#NWD17">D1</a>, <a href="#NWD1B">U2</a>
<li><a href="#NWD29"><i>&lt;class <code>Context</code>&gt;</i></a>: <a href="#NWD29">D1</a>, <a href="#NWD2K">U2</a>
<li><a href="#NWD13"><i>&lt;class <code>CPrinter</code>&gt;</i></a>: <a href="#NWD13">D1</a>, <a href="#NWD16">U2</a>
<li><a href="#NWD2O"><i>&lt;class <code>IdString</code>&gt;</i></a>: <a href="#NWD2O">D1</a>, <a href="#NWD2a">U2</a>
<li><a href="#NWDW"><i>&lt;class <code>IndexScaleDispOpnd</code>&gt;</i></a>: <a href="#NWDW">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWDS"><i>&lt;class <code>IndexSymDispOpnd</code>&gt;</i></a>: <a href="#NWDS">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWD2g"><i>&lt;class <code>Instr</code> and subclasses&gt;</i></a>: <a href="#NWD2g">D1</a>, <a href="#NWD2k">U2</a>
<li><a href="#NWD2j"><i>&lt;class <code>InstrList</code>&gt;</i></a>: <a href="#NWD2j">D1</a>, <a href="#NWD2k">U2</a>
<li><a href="#NWD2N"><i>&lt;class <code>Integer</code>&gt;</i></a>: <a href="#NWD2N">D1</a>, <a href="#NWD2a">U2</a>
<li><a href="#NWD2h"><i>&lt;class <code>IrOpnd</code>&gt;</i></a>: <a href="#NWD2h">D1</a>, <a href="#NWD2k">U2</a>
<li><a href="#NWD1R"><i>&lt;class <code>LineNote</code>&gt;</i></a>: <a href="#NWD1R">D1</a>, <a href="#NWD1U">U2</a>
<li><a href="#NWD1Q"><i>&lt;class <code>ListNote</code>&gt;</i></a>: <a href="#NWD1Q">D1</a>, <a href="#NWD1U">U2</a>
<li><a href="#NWD2A"><i>&lt;class <code>MachineContext</code>&gt;</i></a>: <a href="#NWD2A">D1</a>, <a href="#NWD2K">U2</a>
<li><a href="#NWD1S"><i>&lt;class <code>MbrNote</code>&gt;</i></a>: <a href="#NWD1S">D1</a>, <a href="#NWD1U">U2</a>
<li><a href="#NWD1E"><i>&lt;class <code>NatSet</code>&gt;</i></a>: <a href="#NWD1E">D1</a>, <a href="#NWD1J">U2</a>
<li><a href="#NWD1I"><i>&lt;class <code>NatSetCopy</code>&gt;</i></a>: <a href="#NWD1I">D1</a>, <a href="#NWD1J">U2</a>
<li><a href="#NWD1G"><i>&lt;class <code>NatSetDense</code>&gt;</i></a>: <a href="#NWD1G">D1</a>, <a href="#NWD1J">U2</a>
<li><a href="#NWD1D"><i>&lt;class <code>NatSetIter</code>&gt;</i></a>: <a href="#NWD1D">D1</a>, <a href="#NWD1J">U2</a>
<li><a href="#NWD1C"><i>&lt;class <code>NatSetIterPure</code>&gt;</i></a>: <a href="#NWD1C">D1</a>, <a href="#NWD1J">U2</a>
<li><a href="#NWD1T"><i>&lt;class <code>NatSetNote</code>&gt;</i></a>: <a href="#NWD1T">D1</a>, <a href="#NWD1U">U2</a>
<li><a href="#NWD1H"><i>&lt;class <code>NatSetSparse</code>&gt;</i></a>: <a href="#NWD1H">D1</a>, <a href="#NWD1J">U2</a>
<li><a href="#NWD1L"><i>&lt;class <code>Note</code>&gt;</i></a>: <a href="#NWD1L">D1</a>, <a href="#NWD1U">U2</a>
<li><a href="#NWD1P"><i>&lt;class <code>OneNote</code>&gt;</i></a>: <a href="#NWD1P">D1</a>, <a href="#NWD1U">U2</a>
<li><a href="#NW3HxCBy-1BJMjK-1"><i>&lt;class <code>OpndAddrExp</code> and subclasses&gt;</i></a>: <a href="#NW3HxCBy-1BJMjK-1">D1</a>, <a href="#NWD2k">U2</a>
<li><a href="#NW3HxCBy-2wVG7U-1"><i>&lt;class <code>OpndAddrSym</code>&gt;</i></a>: <a href="#NW3HxCBy-2wVG7U-1">D1</a>, <a href="#NWD2k">U2</a>
<li><a href="#NWDY"><i>&lt;class <code>OpndCatalog</code>&gt;</i></a>: <a href="#NWDY">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWD1a"><i>&lt;class <code>OpndFilter</code>&gt;</i></a>: <a href="#NWD1a">D1</a>, <a href="#NWD26">U2</a>
<li><a href="#NW3HxCBy-4DGIEv-1"><i>&lt;class <code>OpndImmedInteger</code>&gt;</i></a>: <a href="#NW3HxCBy-4DGIEv-1">D1</a>, <a href="#NWD2k">U2</a>
<li><a href="#NW3HxCBy-3X57pL-1"><i>&lt;class <code>OpndImmedString</code>&gt;</i></a>: <a href="#NW3HxCBy-3X57pL-1">D1</a>, <a href="#NWD2k">U2</a>
<li><a href="#NW3HxCBy-zsRrM-1"><i>&lt;class <code>OpndReg</code>&gt;</i></a>: <a href="#NW3HxCBy-zsRrM-1">D1</a>, <a href="#NWD2k">U2</a>
<li><a href="#NW3HxCBy-4JbUHt-1"><i>&lt;class <code>OpndVar</code>&gt;</i></a>: <a href="#NW3HxCBy-4JbUHt-1">D1</a>, <a href="#NWD2k">U2</a>
<li><a href="#NWDz"><i>&lt;class <code>Printer</code>&gt;</i></a>: <a href="#NWDz">D1</a>, <a href="#NWD12">U2</a>
<li><a href="#NWD19"><i>&lt;class <code>StackFrameInfoNote</code>&gt;</i></a>: <a href="#NWD19">D1</a>, <a href="#NWD1B">U2</a>
<li><a href="#NWDR"><i>&lt;class <code>SymDispOpnd</code>&gt;</i></a>: <a href="#NWDR">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWD2W"><i>&lt;class identification&gt;</i></a>: <a href="#NWD2W">D1</a>, <a href="#NWD2a">U2</a>
<li><a href="#NWD1x"><i>&lt;cloning function&gt;</i></a>: <a href="#NWD1x">D1</a>
<li><a href="#NWD1w"><i>&lt;cloning functions&gt;</i></a>: <a href="#NWD1w">D1</a>, <a href="#NWD26">U2</a>
<li><a href="#NWD2Y"><i>&lt;command-line-option helpers&gt;</i></a>: <a href="#NWD2Y">D1</a>, <a href="#NWD2Z">D2</a>, <a href="#NWD2a">U3</a>
<li><a href="#NWD2Q"><i>&lt;container-class defines&gt;</i></a>: <a href="#NWD2Q">D1</a>, <a href="#NWD2a">U2</a>
<li><a href="#NWD27"><i>&lt;context creation&gt;</i></a>: <a href="#NWD27">D1</a>, <a href="#NWD2K">U2</a>
<li><a href="#NWD28"><i>&lt;context-creator registry&gt;</i></a>: <a href="#NWD28">D1</a>, <a href="#NWD2K">U2</a>
<li><a href="#NWD1N"><i>&lt;creator for non-atomic notes&gt;</i></a>: <a href="#NWD1N">D1</a>, <a href="#NWD1U">U2</a>
<li><a href="#NWDr"><i>&lt;distinguished class identifiers&gt;</i></a>: <a href="#NWDr">D1</a>, <a href="#NWDx">U2</a>
<li><a href="#NWDb"><i>&lt;focus functions&gt;</i></a>: <a href="#NWDb">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWD1n"><i>&lt;formal parameter helpers&gt;</i></a>: <a href="#NWD1n">D1</a>, <a href="#NWD26">U2</a>
<li><a href="#NWD2X"><i>&lt;forward reference&gt;</i></a>: <a href="#NWD2X">D1</a>, <a href="#NWD2a">U2</a>
<li><a href="#NWD1Y"><i>&lt;function <code>claim</code>&gt;</i></a>: <a href="#NWD1Y">D1</a>, <a href="#NWD1Z">U2</a>
<li><a href="#NWD1V"><i>&lt;function <code>debug</code>&gt;</i></a>: <a href="#NWD1V">D1</a>, <a href="#NWD1Z">U2</a>
<li><a href="#NWD2V"><i>&lt;function <code>get_name</code>&gt;</i></a>: <a href="#NWD2V">D1</a>, <a href="#NWD2a">U2</a>
<li><a href="#NWD1b"><i>&lt;function <code>map_opnds</code>&gt;</i></a>: <a href="#NWD1b">D1</a>, <a href="#NWD26">U2</a>
<li><a href="#NWD1y"><i>&lt;function <code>strdupe</code>&gt;</i></a>: <a href="#NWD1y">D1</a>
<li><a href="#NWD15"><i>&lt;function <code>target_c_printer</code>&gt;</i></a>: <a href="#NWD15">D1</a>, <a href="#NWD16">U2</a>
<li><a href="#NWD18"><i>&lt;function <code>target_code_fin</code>&gt;</i></a>: <a href="#NWD18">D1</a>, <a href="#NWD1B">U2</a>
<li><a href="#NWD11"><i>&lt;function <code>target_printer</code>&gt;</i></a>: <a href="#NWD11">D1</a>, <a href="#NWD12">U2</a>
<li><a href="#NWD1W"><i>&lt;function <code>warn</code>&gt;</i></a>: <a href="#NWD1W">D1</a>, <a href="#NWD1Z">U2</a>
<li><a href="#NWD1M"><i>&lt;functions for atomic notes&gt;</i></a>: <a href="#NWD1M">D1</a>, <a href="#NWD1U">U2</a>
<li><a href="#NWD1z"><i>&lt;hashing helpers&gt;</i></a>: <a href="#NWD1z">D1</a>, <a href="#NWD26">U2</a>
<li><a href="#NWDL"><i>&lt;immediate-operand functions&gt;</i></a>: <a href="#NWDL">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWD2R"><i>&lt;iterator helpers&gt;</i></a>: <a href="#NWD2R">D1</a>, <a href="#NWD2a">U2</a>
<li><a href="#NWD2b"><i>&lt;machine library initialization&gt;</i></a>: <a href="#NWD2b">D1</a>, <a href="#NWD2d">U2</a>
<li><a href="#NWD2c"><i>&lt;machine string constants&gt;</i></a>: <a href="#NWD2c">D1</a>, <a href="#NWD2d">U2</a>
<li><a href="#NWD2l"><i>&lt;Machine-SUIF copyright&gt;</i></a>: <a href="#NWDC">U1</a>, <a href="#NWDe">U2</a>, <a href="#NWDh">U3</a>, <a href="#NWDo">U4</a>, <a href="#NWDx">U5</a>, <a href="#NWD12">U6</a>, <a href="#NWD16">U7</a>, <a href="#NWD1B">U8</a>, <a href="#NWD1J">U9</a>, <a href="#NWD1U">U10</a>, <a href="#NWD1Z">U11</a>, <a href="#NWD26">U12</a>, <a href="#NWD2K">U13</a>, <a href="#NWD2a">U14</a>, <a href="#NWD2d">U15</a>, <a href="#NWD2e">U16</a>, <a href="#NWD2f">U17</a>, <a href="#NWD2l">D18</a>
<li><a href="#NWD16"><i>&lt;machine/c_printer.h&gt;</i></a>: <a href="#NWD16">D1</a>
<li><a href="#NWD1B"><i>&lt;machine/code_fin.h&gt;</i></a>: <a href="#NWD1B">D1</a>
<li><a href="#NWD2K"><i>&lt;machine/contexts.h&gt;</i></a>: <a href="#NWD2K">D1</a>
<li><a href="#NWD2d"><i>&lt;machine/init.h&gt;</i></a>: <a href="#NWD2d">D1</a>
<li><a href="#NWDC"><i>&lt;machine/instr.h&gt;</i></a>: <a href="#NWDC">D1</a>
<li><a href="#NWD2e"><i>&lt;machine/machine.h&gt;</i></a>: <a href="#NWD2e">D1</a>
<li><a href="#NWD2k"><i>&lt;machine/machine_ir.hoof&gt;</i></a>: <a href="#NWD2k">D1</a>
<li><a href="#NWD1J"><i>&lt;machine/nat_set.h&gt;</i></a>: <a href="#NWD1J">D1</a>
<li><a href="#NWD1U"><i>&lt;machine/note.h&gt;</i></a>: <a href="#NWD1U">D1</a>
<li><a href="#NWDo"><i>&lt;machine/opcodes.h&gt;</i></a>: <a href="#NWDo">D1</a>
<li><a href="#NWDe"><i>&lt;machine/opnd.h&gt;</i></a>: <a href="#NWDe">D1</a>
<li><a href="#NWD2f"><i>&lt;machine/pass.h&gt;</i></a>: <a href="#NWD2f">D1</a>
<li><a href="#NWD12"><i>&lt;machine/printer.h&gt;</i></a>: <a href="#NWD12">D1</a>
<li><a href="#NWD1Z"><i>&lt;machine/problems.h&gt;</i></a>: <a href="#NWD1Z">D1</a>
<li><a href="#NWDx"><i>&lt;machine/reg_info.h&gt;</i></a>: <a href="#NWDx">D1</a>
<li><a href="#NWD2a"><i>&lt;machine/substrate.h&gt;</i></a>: <a href="#NWD2a">D1</a>
<li><a href="#NWDh"><i>&lt;machine/types.h&gt;</i></a>: <a href="#NWDh">D1</a>
<li><a href="#NWD26"><i>&lt;machine/util.h&gt;</i></a>: <a href="#NWD26">D1</a>
<li><a href="#NWD1X"><i>&lt;macro <code>if_debug</code>&gt;</i></a>: <a href="#NWD1X">D1</a>, <a href="#NWD1Z">U2</a>
<li><a href="#NWD1e"><i>&lt;non-printing-note keys&gt;</i></a>: <a href="#NWD1e">D1</a>, <a href="#NWD26">U2</a>
<li><a href="#NWD1O"><i>&lt;note-object association functions&gt;</i></a>: <a href="#NWD1O">D1</a>, <a href="#NWD1U">U2</a>
<li><a href="#NWD1d"><i>&lt;note-transfer functions&gt;</i></a>: <a href="#NWD1d">D1</a>, <a href="#NWD26">U2</a>
<li><a href="#NWDI"><i>&lt;null-operand functions&gt;</i></a>: <a href="#NWDI">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWDi"><i>&lt;opcode OPI&gt;</i></a>: <a href="#NWDi">D1</a>, <a href="#NWDj">D2</a>, <a href="#NWDk">D3</a>, <a href="#NWDl">D4</a>, <a href="#NWDm">D5</a>, <a href="#NWDn">D6</a>, <a href="#NWDo">U7</a>
<li><a href="#NWD25"><i>&lt;optimization-unit body functions&gt;</i></a>: <a href="#NWD25">D1</a>, <a href="#NWD26">U2</a>
<li><a href="#NWD1c"><i>&lt;parameter-register utilities&gt;</i></a>: <a href="#NWD1c">D1</a>, <a href="#NWD26">U2</a>
<li><a href="#NWD20"><i>&lt;printing utilities&gt;</i></a>: <a href="#NWD20">D1</a>, <a href="#NWD26">U2</a>
<li><a href="#NWDs"><i>&lt;register class description functions&gt;</i></a>: <a href="#NWDs">D1</a>, <a href="#NWDx">U2</a>
<li><a href="#NWDp"><i>&lt;register description functions&gt;</i></a>: <a href="#NWDp">D1</a>, <a href="#NWDx">U2</a>
<li><a href="#NWDK"><i>&lt;register-operand functions&gt;</i></a>: <a href="#NWDK">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWD2L"><i>&lt;renamed types&gt;</i></a>: <a href="#NWD2L">D1</a>, <a href="#NWD2a">U2</a>
<li><a href="#NW4F8FIv-1e7pV1-1"><i>&lt;scope management&gt;</i></a>: <a href="#NW4F8FIv-1e7pV1-1">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWD21"><i>&lt;sequence utilities&gt;</i></a>: <a href="#NWD21">D1</a>, <a href="#NWD22">D2</a>, <a href="#NW4MGyWr-24BKoL-3">D3</a>, <a href="#NW4MGyWr-24BKoL-4">D4</a>, <a href="#NWD23">D5</a>, <a href="#NWD24">D6</a>, <a href="#NWD26">U7</a>
<li><a href="#NWDd"><i>&lt;storage measurement&gt;</i></a>: <a href="#NWDd">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NWD2P"><i>&lt;string function&gt;</i></a>: <a href="#NWD2P">D1</a>, <a href="#NWD2a">U2</a>
<li><a href="#NWD2S"><i>&lt;substrate header includes&gt;</i></a>: <a href="#NWD2S">D1</a>, <a href="#NWD2a">U2</a>
<li><a href="#NWD2U"><i>&lt;SUIF environment&gt;</i></a>: <a href="#NWD2U">D1</a>, <a href="#NWD2a">U2</a>
<li><a href="#NWD1h"><i>&lt;symbol creators&gt;</i></a>: <a href="#NWD1h">D1</a>, <a href="#NWD1i">D2</a>, <a href="#NWD26">U3</a>
<li><a href="#NWD1g"><i>&lt;symbol finders&gt;</i></a>: <a href="#NWD1g">D1</a>, <a href="#NWD26">U2</a>
<li><a href="#NWD1f"><i>&lt;symbol predicates&gt;</i></a>: <a href="#NWD1f">D1</a>, <a href="#NWD26">U2</a>
<li><a href="#NWD1j"><i>&lt;symbol-property functions&gt;</i></a>: <a href="#NWD1j">D1</a>, <a href="#NWD1k">D2</a>, <a href="#NWD1l">D3</a>, <a href="#NWD1m">D4</a>, <a href="#NWD26">U5</a>
<li><a href="#NWD1o"><i>&lt;symbol-table accessors&gt;</i></a>: <a href="#NWD1o">D1</a>, <a href="#NWD26">U2</a>
<li><a href="#NWD1p"><i>&lt;symbol-table predicates&gt;</i></a>: <a href="#NWD1p">D1</a>, <a href="#NWD26">U2</a>
<li><a href="#NWDg"><i>&lt;target-dependent type&gt;</i></a>: <a href="#NWDg">D1</a>, <a href="#NWDh">U2</a>
<li><a href="#NWDf"><i>&lt;target-independent types&gt;</i></a>: <a href="#NWDf">D1</a>, <a href="#NWDh">U2</a>
<li><a href="#NWDq"><i>&lt;type <code>RegClassId</code>&gt;</i></a>: <a href="#NWDq">D1</a>, <a href="#NWDx">U2</a>
<li><a href="#NWDt"><i>&lt;type <code>RegClassMap</code>&gt;</i></a>: <a href="#NWDt">D1</a>, <a href="#NWDx">U2</a>
<li><a href="#NWD2M"><i>&lt;type <code>TypeId</code>&gt;</i></a>: <a href="#NWD2M">D1</a>, <a href="#NWD2a">U2</a>
<li><a href="#NWD1q"><i>&lt;type helpers&gt;</i></a>: <a href="#NWD1q">D1</a>, <a href="#NWD1r">D2</a>, <a href="#NWD1s">D3</a>, <a href="#NWD1t">D4</a>, <a href="#NWD1u">D5</a>, <a href="#NWD1v">D6</a>, <a href="#NWD26">U7</a>
<li><a href="#NWD1K"><i>&lt;typedef <code>NoteKey</code>&gt;</i></a>: <a href="#NWD1K">D1</a>, <a href="#NWD1U">U2</a>
<li><a href="#NWDJ"><i>&lt;variable-symbol-operand functions&gt;</i></a>: <a href="#NWDJ">D1</a>, <a href="#NWDe">U2</a>
<li><a href="#NW4F8FIv-1BNo5Y-1"><i>&lt;virtual-register management&gt;</i></a>: <a href="#NW4F8FIv-1BNo5Y-1">D1</a>, <a href="#NWDe">U2</a>
</ul>
</body></html>

