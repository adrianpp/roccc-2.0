<!-- this file was generated automatically by noweave; better not edit it-->
<html><head><title>A User's Guide to the </title></head><body>

<p>
<!-- Give the l2h (LaTeX to HTML) filter some hints-->





<!-- Adjust dimensions before setting \pagestyle: it looks at-->
<!-- some of them-->










<p>
<!-- Replace some noweb.sty definitions to improve page breaks-->


           <!-- Omit \clearpage for new source file-->
<p>
<!-- Was =\@highpenalty (>9999 disallows-->
<!-- ... _any_ break in code)-->
<!-- Use \nwcodepenalty ...--><!-- ... instead of \@highpenalty-->
    <!-- Use \goodbreak ...-->
               <!-- ... instead of \filbreak-->
<p>

<h1><a name=toc1>A User's Guide to the <br>Optimization Programming Interface</a></h1>
<address><em>Release version 2.02.07.15</em> <br><br>Glenn Holloway and Michael D. Smith<br>{holloway,smith}@eecs.harvard.edu <br>Division of Engineering and Applied Sciences <br>Harvard University</address>
<p>

<!--title goes here-->

<p>
<h2><a name=toc2>Abstract</a></h2><blockquote>

The optimization programming interface (OPI) is a programming
interface for use in writing portable analyses and optimizations that
work on code represented at or near the machine level.  It provides
you with a standardized view of the data structures in the
intermediate representation (IR) and of the functions used to create,
inspect, and manipulate these data structures.  Since optimizations
expressed using the OPI do not directly reference constructs of any
particular compiler substrate or embed constants from any specific
target machine, you can write ``textbook-like'' code that can be used and
reused, even though the compiler substrate changes or is extended.  In
this document, we take an in-depth look at the OPI from the
perspective of someone who wants to use it to write optimizations.
<p>
</blockquote>

<hr><p>
<tableofcontents>
<ul compact>
<li><a href="#toc2">Abstract</a></li>
<li><a href="#toc3">Introduction</a></li>
<li><a href="#toc4">Structure of an OPI Pass</a></li>
  <ul compact>
    <ul compact>
      <ul compact>
      <li><a href="#toc5">Substrate-independent interface.</a></li>
      <li><a href="#toc6">Binding the OPI</a></li>
      </ul>
    </ul>
  </ul>
<li><a href="#toc7">Overview of Data Types in the OPI</a></li>
  <ul compact>
  <li><a href="#toc8">Reference or Value Semantics</a></li>
  <li><a href="#toc9">Representing Machine Code</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc10">Constant values, symbols, and types.</a></li>
      <li><a href="#toc11">Instructions and operands.</a></li>
      <li><a href="#toc12">Optimization-unit bodies.</a></li>
      <li><a href="#toc13">Annotations.</a></li>
      </ul>
    </ul>
  <li><a href="#toc14">Representing Target-Specific Information</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc15">Machine-specific functions.</a></li>
      <li><a href="#toc16">Machine-description records.</a></li>
      <li><a href="#toc17">Pass-specialization classes.</a></li>
      </ul>
    </ul>
  </ul>
<li><a href="#toc18">OPI Conventions</a></li>
  <ul compact>
    <ul compact>
      <ul compact>
      <li><a href="#toc19">Abbreviations.</a></li>
      <li><a href="#toc20">Identifier formation.</a></li>
      <li><a href="#toc21">Function names.</a></li>
      <li><a href="#toc22">Argument order.</a></li>
      <li><a href="#toc23">Use of explicit pointer types.</a></li>
      <li><a href="#toc24">Storage management.</a></li>
      <li><a href="#toc25">Type resolution and casting.</a></li>
      </ul>
    </ul>
  </ul>
<li><a href="#toc26">Building and Manipulating the Intermediate Representation</a></li>
  <ul compact>
  <li><a href="#toc27">Symbols and Scopes</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc28">Symbol creation.</a></li>
      <li><a href="#toc29">Symbol properties.</a></li>
      </ul>
    </ul>
  <li><a href="#toc30">Instructions and Instruction Lists</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc31">Instruction lists.</a></li>
      <li><a href="#toc32">Instructions.</a></li>
      </ul>
    </ul>
  <li><a href="#toc33">Operands</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc34">Atomic operands.</a></li>
      <li><a href="#toc35">Address expressions.</a></li>
      </ul>
    <li><a href="#toc36">Common operations on all operands</a></li>
      <ul compact>
      <li><a href="#toc37">Operand type.</a></li>
      <li><a href="#toc38">Operand kind.</a></li>
      <li><a href="#toc39">Operand copying.</a></li>
      <li><a href="#toc40">Operand equality.</a></li>
      <li><a href="#toc41">Operand hashing.</a></li>
      <li><a href="#toc42">Operand printing.</a></li>
      </ul>
    <li><a href="#toc43">Features and examples of atomic operands</a></li>
    <li><a href="#toc49">Features and examples of address-expression operands</a></li>
      <ul compact>
      <li><a href="#toc50">Address-expression type.</a></li>
      <li><a href="#toc51">Address-expression kind.</a></li>
      <li><a href="#toc52">Address-expression equality.</a></li>
      <li><a href="#toc53">Base-plus-displacement operands.</a></li>
      <li><a href="#toc54">Symbol-plus-displacement operands.</a></li>
      </ul>
    </ul>
  <li><a href="#toc55">Control Flow Graphs</a></li>
    <ul compact>
    <li><a href="#toc56">Properties of Cfg Objects</a></li>
    <li><a href="#toc57">Properties of CfgNode Objects</a></li>
      <ul compact>
      <li><a href="#toc58">Checking a node's identity.</a></li>
      <li><a href="#toc59">Manipulating the instruction sequence.</a></li>
      <li><a href="#toc60">Accessing successors and predecessors.</a></li>
      <li><a href="#toc61">Inspecting and testing the CTI.</a></li>
      <li><a href="#toc62">Finding a node's boundary instructions.</a></li>
      <li><a href="#toc63">Inspecting the layout constraints.</a></li>
      </ul>
    <li><a href="#toc64">Graph Construction and Deconstruction</a></li>
    <li><a href="#toc65">Control-Flow Relations</a></li>
      <ul compact>
      <li><a href="#toc66">Normal edges.</a></li>
      <li><a href="#toc67">Abnormal edges.</a></li>
      <li><a href="#toc68">Making new neighbors.</a></li>
      <li><a href="#toc69">Creating abnormal edges.</a></li>
      <li><a href="#toc70">Testing for abnormal edges.</a></li>
      <li><a href="#toc71">Replacing the control-transfer instruction.</a></li>
      </ul>
    <li><a href="#toc72">Layout relations</a></li>
      <ul compact>
      <li><a href="#toc73">Changing layout constraints.</a></li>
      <li><a href="#toc74">Effects of layout constraints on code.</a></li>
      </ul>
    <li><a href="#toc75">Adding New Nodes</a></li>
    <li><a href="#toc76">Graph Simplification</a></li>
    <li><a href="#toc77">Reverse-Postorder Node Enumeration</a></li>
    <li><a href="#toc78">Graph Printing</a></li>
      <ul compact>
      <li><a href="#toc79">Printing the whole graph.</a></li>
      <li><a href="#toc80">Printing one node.</a></li>
      </ul>
    </ul>
  <li><a href="#toc81">Annotations</a></li>
    <ul compact>
    <li><a href="#toc82">Keys</a></li>
    <li><a href="#toc83">Association Functions</a></li>
    <li><a href="#toc84">Basic Annotation Kinds</a></li>
      <ul compact>
      <li><a href="#toc85">Null annotations.</a></li>
      <li><a href="#toc86">Flag annotations.</a></li>
      <li><a href="#toc87">Singleton annotations.</a></li>
      <li><a href="#toc88">List annotations.</a></li>
      <li><a href="#toc89">Custom annotations.</a></li>
      </ul>
    </ul>
  </ul>
<li><a href="#toc90">Summary</a></li>
<li><a href="#toc91">Acknowledgments</a></li>
<li><a href="#toc92">References</a></li>
<li><a href="#toc93">Structure of a Machine-SUIF Pass</a></li>
  <ul compact>
    <ul compact>
      <ul compact>
      <li><a href="#toc94">File set handler.</a></li>
      <li><a href="#toc95">File handler.</a></li>
      <li><a href="#toc96">Procedure handler.</a></li>
      </ul>
    </ul>
  </ul>
<li><a href="#toc97">Glossary</a></li>
</ul>
</tableofcontents>
<p>
<!-- Start a new chunk to cause noweb to put source filename in heading-->



<hr>

<h2><a name=toc3>Introduction</a></h2>
<p>
The optimization programming interface (OPI) declares functions and
data structures for use in code optimization.  It allows you to
express optimization algorithms in a way that isolates their
machine-dependent aspects, so that the same algorithms can be used in
compiling for different target machines.  It also hides the support
system (i.e., the substrate) that provides symbol tables, data-type
descriptors, storage management, and so on, so that the same
algorithms used in a static compilation setting can be used for
run-time optimization as well.
<p>
This guide introduces the major data structures of the OPI and the
functions that create, inspect, and manipulate those data structures.
It is not an exhaustive reference manual.  The OPI is meant to be
extended by users, and the definitive description of its details
is contained in the individual library documents distributed with
your system.  Each system comes with a mechanism for automatically
constructing an <em>OPI Catalog</em>, which cross-references
OPI functions in the code with their descriptions in the library
documents.
<p>
The OPI is aimed at machine-level optimizations, so its principal data
structures and functions are for building and manipulating an
<em>intermediate representation</em> (IR) of machine instructions.  The
OPI also declares containers (lists and graphs) that organize
instructions for efficient code transformation, and annotations that
enable an open-ended set of properties to be attached to code.  Finally,
the OPI declares structures for representing target-machine
characteristics (like register architecture and instruction latencies),
so that algorithms can express machine dependences in a portable way.
<p>
The OPI is not a complete compilation infrastructure.  It is designed to
be implemented on a substrate that takes care of things like
intermediate-file I/O and pipelining of compiler passes.  Its role is to
segregate algorithms from the details of the substrate on which they
happen to be running and the machine that they happen to be targeting.
In our own research, we use the OPI to share optimizations between
Machine SUIF, an infrastructure that supports development of back ends
for use with the SUIF system, and Deco, a system for run-time code
optimization.
<p>
Efficiency and extensibility were important goals in the design of the
OPI.  The interface is expressed in C++, but it often avoids using
features of the language that are are hard to implement efficiently.
For example, it relies heavily on plain old functions.  This avoids
the run-time overhead associated with virtual-method dispatch, and it
allows easy extension through the addition of new functions.  The
Machine SUIF overview document&nbsp;<b>[cite&nbsp;<a href="#NWcite-biboverview">biboverview</a>]</b> provides a more
complete listing of our goals.
<p>
In this document, we take a top-down tour through the OPI.  The next
section describes the interface and structure of an optimization pass
written to conform to the OPI.  (Appendix&nbsp;<a href="#app-suif-pass">[-&gt;]</a>
illustrates how this substrate-independent pass is integrated into a
Machine-SUIF pass.)  Section&nbsp;<a href="#sec-datatypes">[-&gt;]</a> then reviews and
describes the connections between the main OPI data types.
Section&nbsp;<a href="#sec-conventions">[-&gt;]</a> summarizes the naming and other
conventions employed in the OPI.  These conventions are consistently
followed in our code, and they should make it easier to program using
the OPI.  Section&nbsp;<a href="#sec-building-ir">[-&gt;]</a> provides more details and
examples of the most-commonly used portions of the OPI.  After reading
this section, you should be ready to read <em>The Machine-SUIF
Cookbook</em>&nbsp;<b>[cite&nbsp;<a href="#NWcite-bibcookbook">bibcookbook</a>]</b> and write your own optimization passes.
<p>

<h2><a name=toc4>Structure of an OPI Pass</a></h2>
<a name="sec-opi-pass"><b>[*]</b></a>
<p>
In compiler jargon, a <em>pass</em> is a transformation applied to a segment
of the program being compiled.  Many algorithms written using the OPI are
intended for use as passes.
<p>
The OPI doesn't say everything there is to know about the sequencing
of passes.  This really depends on the optimization <em>setting</em>:
traditional static compilation involves more pass-sequencing
infrastructure and a different kind of optimization region than
run-time optimization.  An OPI pass finds the common ground in this
design space.  An OPI pass simply focuses on the work that needs to be
done to optimize a single code region, which might be a procedure, or a
trace that is known to be heavily used, or some other fragment of the
program being compiled.  Appendix&nbsp;<a href="#app-suif-pass">[-&gt;]</a> illustrates
how this simple interface is invoked in a traditional static
compilation environment where processing occurs at the level of the
file set, individual files, and individual procedures.
<p>
<h5><a name=toc5>Substrate-independent interface.</a></h5>
<p>
We build each substrate-independent optimization pass as a stand-alone
class, as illustrated by the class <code>Peep</code> in <code>peep/peep.h</code>.  This
class contains three public methods (repeated below) that define the
OPI pass interface. <b>[</b>Though the OPI does not legislate the
naming of these methods, the vast majority of our passes adhere to
this simple interface.<b>]</b> 
<p>
<pre>
    class Peep {
      public:
        Peep() { }

        void initialize();
        void do_opt_unit(OptUnit*);
        void finalize();

        // ...
    };
</pre>

The data type <code>OptUnit</code> represents the unit of optimization for the
current setting.  In Machine SUIF, <code>OptUnit</code> is a synonym for
<code>ProcedureDefinition</code>; in an on-line optimizer, <code>OptUnit</code> may be a
something as simple as a trace of instructions.
<p>
The method <code>do_opt_unit</code> performs the actual peephole transformation
on the optimization unit, while <code>initialize</code> and <code>finalize</code> allow
you to write code that runs before or after calls to <code>do_opt_unit</code>.
In <code>Peep</code>, we use these latter two methods to clear and print out
statistics about the peephole operations performed.
<p>
<h5><a name=toc6>Binding the OPI</a></h5>
<p>
The OPI hides the specific details of the target machine and the
underlying substrate behind its standardized interface.  Obviously,
you must connect an implementation to each OPI function and data
structure that you use.  How this binding is done is an issue outside
the OPI definition.  Appendix&nbsp;<a href="#app-suif-pass">[-&gt;]</a> shows how this
binding occurs in our implementation of the OPI under Machine SUIF.
<p>

<h2><a name=toc7>Overview of Data Types in the OPI</a></h2>
<a name="sec-datatypes"><b>[*]</b></a>
<p>
The OPI provides data types for representing machine code and for
capturing information specific to the target machine.  In this section
we sketch the big picture; Section&nbsp;<a href="#sec-building-ir">[-&gt;]</a> provides more
details and examples.
<p>
<h3><a name=toc8>Reference or Value Semantics</a></h3>
<a name="sec-ref-value"><b>[*]</b></a>
<p>
Before we describe the IR data types , we need to discuss a design
issue that affects how you use the OPI.  The OPI is expressed in C++,
and it uses an object-oriented style to achieve extensibility.  That
implies that pointers figure heavily in its implementation, either
explicitly or implicitly, since polymorphism in C++ relies on pointers
or references.  Furthermore, the use of pointers to objects often
matches our mental model of compilation data structures.  We draw
trees and graphs with arrows, and it is natural to realize those
arrows as pointers to node objects in the implementation.
Moreover, pointers are inexpensive to pass around, whereas IR
objects may be quite large, especially in a static system designed for
easy experimentation with compiler algorithms.
<p>
The OPI therefore makes considerable use of pointers, and rather than
hide that fact, we make the pointer types explicit.  For example, the
data types for instruction and CFG node are <code>Instr*</code> and <code>CfgNode*</code>,
not <code>Instr</code> and <code>CfgNode</code>.  This leaves no question that reference
semantics are in effect.
<p>
On the other hand, the OPI is meant to allow direct reuse of
algorithms in settings where optimization-time efficiency is paramount.
For example, there is a growing interest in the use of on-line
optimization techniques, which re-optimize a program while it is
running.  This is the research focus of many projects, including our
Deco project at Harvard University.  In these projects, one trades
flexibility in the infrastructure for efficiency during optimization.
Some IR components are best implemented without pointers in such a
setting, because they are easy to represent as lightweight values.
Anticipating the need to change the implementation of these IR
components, we have given them non-pointer types in the OPI.
<p>
An important example of this kind is the instruction operand, whose
type is <code>Opnd</code> (not <code>Opnd*</code>).  In Machine SUIF, the need for easy
extensibility has led to an operand representation based on a (hidden)
pointer to a bulky object.  This is appropriate for research in static
compilation, but for reusing OPI-based algorithms in dynamic
optimization on a specific target platform, we need to be able to give
<code>Opnd</code> a lean implementation.  The number of different kinds of
operands is typically small in on-line optimization (Deco implements
only a handful of the operand kinds found in Machine SUIF), and their
contents are not large, so an operand can often take less space than a
pointer.  It makes little sense to traffic in pointers for these
simple components.
<p>
This leaves us with a dilemma.  We could simply require all
implementations of the OPI to enforce value semantics for instances of
<code>Opnd</code>.  Thus, given two variables <code>x</code> and <code>y</code> whose type is
<code>Opnd</code>, an assignment <code>x = y</code> would leave <code>x</code> completely
independent of <code>y</code>, so that changes to the fields of one would not
affect the other.  That would satisfy the requirements of on-line
optimization, but at a sizable cost for other OPI implementations,
such as Machine SUIF, where large objects would frequently be copied
to prevent proscribed sharing.
<p>
For this reason, the OPI leaves open the question of whether instances
of non-pointer IR data types such as <code>Opnd</code> behave like references
or like independent values.  An implementation is free to use
reference semantics, and in fact, Machine SUIF does so.  For
algorithms that aren't meant to be reusable in an on-line setting,
that's all you need to know.  For maximum portability of your
OPI-based programs, however, you should explicitly copy operands to
prevent accidental mutation.  (See the description of <code>clone</code> in
Section&nbsp;<a href="#sec-opnd-ops">[-&gt;]</a>.)  In practice, this is seldom needed,
since the most frequently-used kinds of operands are immutable.
<p>
Compiler infrastructures written in C++ using IR components with
non-pointer data types have traditionally been difficult to extend
without rewriting code in the base system. <b>[</b>This was the
problem with the implementation of operands in SUIF version 1.<b>]</b>   To
make extending and programming with non-pointer data types as easy as
possible while not compromising our ability to share optimizations and
use them in a run-time-sensitive environment, we adhere to the
following approach.
<p>
We define a base class for each class of IR component (e.g., <code>Opnd</code>
for operands and <code>Note</code> for annotations).  This base class is the
only type that appears in the OPI function prototypes.  If you want to
extend the system with a new variant of a base class, you do so using
object-oriented techniques (i.e., you derive a new subclass of the
base class).  We postpone further discussion of this issue until
Section&nbsp;<a href="#sec-operands">[-&gt;]</a> where we can use <code>Opnd</code> and its
extensions as a specific example.
<p>

<h3><a name=toc9>Representing Machine Code</a></h3>
<a name="sec-representing-code"><b>[*]</b></a>
<p>
Starting at the atomic level, there are constants, symbols (e.g.,
source-variable symbols), and types (e.g., representations of source data
types like ``array of type <i>T</i>'').  Next there are data types for
machine instructions and their operands, and for grouping instructions into
optimization units.  Finally, there are annotation types that enable you to
attach properties to the program representation.
<p>

<h5><a name=toc10>Constant values, symbols, and types.</a></h5>
<p>
The OPI provides types that are useful for representing source
literals and other constant values in a manner that is independent of
the host machine's peculiarities.  Type <code>Integer</code> represents
integers of arbitrary length.  Type <code>IdString</code> is a text-string
type that's used both for string and floating-point literals; this
type includes efficient operators for comparison, concatenation, etc.
<p>
Symbols from the source program (the identifiers of variables, constants,
and code labels), and analogous symbols generated during compilation, have
type <code>Sym*</code> or one of its refinements <code>VarSym*</code>, <code>ProcSym*</code>, and
<code>LabelSym*</code>.  You can think of a symbol as a pointer to a symbol-table
entry.  You can test equality of symbols by simple pointer comparison, and
you can fetch the attributes of a symbol (such as the scope or the initial
value of a variable) efficiently through the pointer.
<p>
Source types have the OPI type <code>TypeId</code>.  Types play a limited role
in OPI optimizations, and hence we have found it useful to think of
source types as having value semantics.  In general, they serve mainly
to specify the size and alignment properties of values.
<p>

<h5><a name=toc11>Instructions and operands.</a></h5>
<p>
Every instruction in the IR has type <code>Instr*</code>.  Although each
instance represents a machine instruction, there's nothing in the data
structure itself that identifies the machine in question.
Machine-specific interpretation of an instruction is always done via
OPI functions.
<p>
Each instruction has an integer opcode component, and in general, it
has operand components as well.  The type of an operand is <code>Opnd</code>.
You access and modify the components of an instruction using
functions, not methods.
<p>
The OPI classifies instructions into several broad categories.  This
machine-independent breakdown distinguishes pseudo-instructions from
real instructions, for example, and it also identifies
control-transfer instructions (CTI) as special.  You cannot however
distinguish one kind of instruction from another by its
substrate-specific data type.  Instead, you must use the value of its
fields (e.g., its opcode value) or the result of an OPI predicate
function (e.g., <code>is_cti</code> or <code>reads_memory</code>).  The set of predicate
functions, as we explain later, is easy to extend.
<p>
The OPI also defines several common kinds of operands.  Every operand
in the IR has the base class <code>Opnd</code> or some subclass of <code>Opnd</code>.
The OPI includes predicate functions to distinguish one kind of
operand from another.  For example, to ask whether operand <code>opnd</code>
represents the occurrence of a variable, you evaluate
<code>is_var(opnd)</code>.
<p>
Once you have determined the kind of operand you have, you know what
components of that operand you can access/change and what operations
you must perform to access/change them.  Continuing with the <code>opnd</code>
example from above, once you have determined that <code>is_var(opnd)</code> is
true, then you know that the OPI function <code>get_var(opnd)</code> is valid.
This particular function returns the variable-symbol component of the
operand.  Please see Section&nbsp;<a href="#sec-operands">[-&gt;]</a> for further examples
and a discussion of operands built using subclasses of <code>Opnd</code>.
<p>

<h5><a name=toc12>Optimization-unit bodies.</a></h5>
<p>
The OPI currently provides two ways of collecting instructions to form
a procedure body or other optimization unit: the linear list and the
control flow graph (CFG).  (Again, you can add your own alternatives.)
<p>
The linear list form has type <code>InstrList*</code>.  It serves as a container for
an instruction sequence.  The functions associated with this type tell you
the length of the sequence, they allow you to iterate through the contents
and to insert, replace, or remove instructions.
<p>
The CFG form has type <code>Cfg*</code>.  It makes the control flow of the unit body
explicit by identifying the basic blocks (maximal straight-line instruction
sequences) of the unit and connecting them with flow edges.  Each basic
block (of type <code>CfgNode*</code>) contains at most one control-transfer
instruction (CTI).  As an optimization writer, you can transform the
program either by graph manipulations or by altering the instructions
contained in basic blocks.  (The OPI provides a function that updates the
flow edges emanating from a block to reflect the correct flow after its CTI
has been modified.)
<p>
Naturally, there are functions for translating a unit body from
linear-list form to CFG form and <em>vice versa</em>.
<p>

<h5><a name=toc13>Annotations.</a></h5>
<p>
The IR data types provided by the OPI are meant to cover all
commonly-occurring representation issues.  But it is very useful to
have a way to handle special-purpose representations and to mark
particular IR objects without needing to extend the OPI's types.  The
annotation mechanism provides these capabilities.  Annotations are
persistent; they survive even if the IR is written to disk and read
back.
<p>
In the OPI, annotations have the base class <code>Note</code> or some subclass
of <code>Note</code>.  A note associates zero or more values with an IR object.
An object can have any number of notes, and so each is labeled with a
key.  Keys are given the type <code>NoteKey</code>.  The values attached
using a note can be integers, strings, or IR objects.  For instance,
to mark an instruction with the source-code location that gave rise to
it, we use a note whose key is <code>`line'</code> and whose attached values
are the file name (a string) and a line number (an integer).
<p>
Not all IR data structures are ``note-able''.  The rule of thumb is that if
the OPI's IR type is an explicit pointer type, such as <code>VarSym*</code> or
<code>Instr*</code>, then you can annotate the corresponding IR objects.  You
can't attach a <code>Note</code> to an <code>Opnd</code> or to a <code>TypeId</code>.  The OPI has a
type that represents the union of all note-able object types: <code>IrObject*</code>.
That is, <code>VarSym*</code>, <code>Instr*</code>, <code>Cfg*</code>, and so on, are all special
cases of <code>IrObject*</code>.  An <code>IrObject*</code> is also one of the types of
values (along with <code>Integer</code> and <code>IdString</code>) that can serve as an
attached note value.  Thus, you can connect a label symbol with the CFG
node to which it corresponds by attaching a note to the symbol with the
node object (whose type <code>CfgNode*</code> refines <code>IrObject*</code>) as the value.
<p>


<h3><a name=toc14>Representing Target-Specific Information</a></h3>
<p>
As mentioned above, one purpose of the OPI is to make it possible to write
optimizations that depend on information about the target machine, but that
can be used without modification for a wide variety of target machines.  We
call these <em>parameterized</em> algorithms, in the sense that they abstract
away machine-specific details.  To allow algorithms to refer to
machine-specific features, the OPI provides several functions and data
types that express the characteristics of the target system.
<p>
These data structures fall into three broad categories.  First, there
are functions that reveal simple facts about the target, or answer
target-specific questions about elements of the IR.  Next, there are
straightforward machine descriptors, which are records that collect
facts about some aspect of the target hardware and/or operating
system (OS).  Finally, there are classes whose methods encapsulate the
machine-dependent parts of an important back-end pass, such as
machine-code selection or assembly-code generation.
<p>
<h5><a name=toc15>Machine-specific functions.</a></h5>
<p>
Some of these express simple facts about the target.  The parameterless
function <code>type_addr</code>, for instance, returns a <code>TypeId</code> that represents
the generic pointer in the target.  Other functions are predicates for
making machine-dependent distinctions between IR components.  The function
<code>is_move</code>, for instance, is applied to an instruction to determine
whether it represents a register-to-register move on the target.  (For some
targets, this entails inspecting both the opcode and the operands.)  Other
functions generate machine-specific details; for example, <code>opcode_load</code>
takes a <code>TypeId</code> and produces the correct opcode for loading a value of
that type into a register.
<p>
<h5><a name=toc16>Machine-description records.</a></h5>
<p>
These data structures collect related facts about the target.  For example,
<code>RegInfo</code> is an OPI class for describing the register architecture of the
target machine and the register-use conventions of the OS.  The function
<code>target_regs</code> returns a <code>RegInfo*</code>, on which the methods of
<code>RegInfo</code> can be used to determine the number and population of register
files, the number and identities of argument registers, and so on.
<p>
<h5><a name=toc17>Pass-specialization classes.</a></h5>
<p>
Certain compilation passes are more ``target specific'' than others.
When the percentage of code in a pass that is target specific becomes
very large, we define an OPI object whose specific purpose is to
encapsulate the target-specific action.  Code generation is one
example of a ``target-specific'' pass; the only target-independent code
in our code generator is a switch statement that dispatches on a
SUIFvm opcode and possibly an outer loop that allows us to visit each
SUIFvm instruction in an <code>InstrList</code>.
<p>
In the case of code generation, the OPI defines a function called
<code>target_code_gen</code> that returns an object of type <code>CodeGen*</code>.  The
methods of class <code>CodeGen</code> handle the machine-dependent aspects of
translating SUIFvm code into code for the target machine.  The
principal method is <code>translate_instr</code>, which appends the translation
of one instruction to a growing list of target-machine code.
<p>
The OPI specifies a similar object for code ``finalization'' (stack-frame
layout and prologue/epilogue creation) and for emitting object code.  These
task-oriented target-characterizations are sometimes useful in situations
other than their corresponding passes.  For example, when an optimization
needs to create a bit of machine code to glue together existing segments,
it is often easiest to express this as a list of SUIFvm instructions and
then use the <code>CodeGen</code> object replace it by real-machine code.
<p>

<h2><a name=toc18>OPI Conventions</a></h2>
<a name="sec-conventions"><b>[*]</b></a>
<p>
Before going into more detail about using the OPI, we describe some naming
conventions that are intended to make it easier remember the names of the
important types and functions.
<p>
<h5><a name=toc19>Abbreviations.</a></h5>
<p>
The practice of using whole words in all identifier names has mnemonic
value.  The trouble is that the words get concatenated as concepts get
refined, and the convention of using whole words either gets violated or it
leads to unwieldy terms.  E.g., while neither ``variable'' nor ``symbol''
seems unreasonable, NestingVariableSymbol begins to get cumbersome.
<p>
To keep identifiers reasonably short, the OPI abbreviates many
commonly used terms.  Thus ``variable'' is shortened to ``var'' and
``operand'' to ``opnd''.  To compensate for the subjective choice of
abbreviations, we never vary our abbreviation of any term.  For example,
``operand'' is always shortened to ``opnd'', never to ``op'', and it's
never left unabbreviated.
<p>
Appendix&nbsp;<a href="#sec-glossary">[-&gt;]</a> lists all the current OPI abbreviations.
<p>

<h5><a name=toc20>Identifier formation.</a></h5>
<p>
The OPI uses two kinds of identifiers: those meant to represent types,
and all the rest.  Type identifiers are always capitalized, and token
separations within them are marked by internal capital letters, not by
underscores.  For instance, we use <code>ScopeTable</code>, and not
<code>Scope_table</code> or <code>Scope_Table</code>.  The fact that all or part of a
type identifier is an acronym that might be written with all capitals
in ordinary exposition doesn't affect the identifier-formation rule.
Thus, we write <code>Cfg</code> and <code>CfgNode</code>, not <code>CFG</code> or <code>CFGNode</code>.
<p>
All other identifiers are spelled entirely in lower case, using underscores
as token separators, as in the function name <code>new_cfg_node</code>.
<p>

<h5><a name=toc21>Function names.</a></h5>
<p>
The functions that access and replace simple components of an IR object are
prefixed with <code>get_</code> and <code>set_</code>, respectively.  For example, the opcode
component of an instruction <code>instr</code> is fetched with <code>get_opcode(instr)</code>
and set with something like <code>set_opcode(instr, MOV)</code>, where <code>MOV</code>
might represent the <code>mov</code> operation in the <i>x</i>86 ISA.
<p>
Many kinds of IR objects have components that are sequences.  For instance,
<code>InstrList</code> and <code>CfgNode</code> objects both contain sequences of
instructions; an <code>Instr</code> contains sequences of operands; and so on.  The
functions with which you operate on these sequences are named in a
consistent manner to make the names easier to remember.
<p>
In general, sequence elements can be accessed using a zero-based position
number or using a pointer-like position marker that we call a
<em>handle</em>.  Handles are similar to iterators over containers in
standard C++ (e.g., <code>list&lt;int&gt;::iterator</code>).  With a handle you can
iterate through the elements of a sequence, using the C++ increment
(<code>++</code>) and decrement (<code>--</code>) operators to move to the next or previous
element.  Some of OPI functions on sequences use a handle to guide where to
fetch, replace, insert, or remove a sequence element.  As with C++
iterators, there is a special handle value for each sequence that
represents the position just past the last element.  We call that
distinguished handle the <em>sentinel</em>.  Inserting an element before the
sentinel is equivalent to appending the element to the sequence.
<p>
The full space of sequence functions is illustrated below using the
source operand sequence in class <code>Instr</code>.  Our uniform abbreviation
for ``source operand'' is <code>src</code>, and you should imagine that the
source-operand sequence of an instruction has the name <code>srcs</code>.
Thus, the function named <code>srcs_size</code> gets the size of the <code>srcs</code>
collection (i.e., the number of operands in the sequence), and
<code>get_src</code> returns a particular member of that collection.
<p>
<blockquote>
<code>srcs_size(instr)</code> returns the number of source operands in <code>instr</code>. <br><code>srcs_start(instr)</code> returns a handle on the first source operand of
<code>instr</code>. <br><code>srcs_last(instr)</code> returns a handle on the last source operand of
<code>instr</code>. <br><code>srcs_end(instr)</code> returns the sentinel handle for the source-operand
sequence of <code>instr</code>. <br><code>get_src(instr, pos)</code> returns the source of <code>instr</code> at position
<code>pos</code> (a zero-based integer). <br><code>get_src(instr, handle)</code> returns the source of <code>instr</code> at <code>handle</code>. <br><code>set_src(instr, pos, opnd)</code> replaces the source at position <code>pos</code> in
<code>instr</code> by <code>opnd</code>. <br><code>set_src(instr, handle, opnd)</code> replaces the source at <code>handle</code> in
<code>instr</code> by <code>opnd</code>. <br><code>prepend_src(instr, opnd)</code> inserts <code>opnd</code> at the beginning of
<code>instr</code>'s sources. <br><code>append_src(instr, opnd)</code> inserts <code>opnd</code> at the end of <code>instr</code>'s
sources. <br><code>insert_before_src(instr, handle, opnd)</code> inserts <code>opnd</code> before <code>handle</code> in
<code>instr</code>'s sources. <br><code>insert_after_src(instr, handle, opnd)</code> inserts <code>opnd</code> after <code>handle</code> in
<code>instr</code>'s sources. <br><code>remove_src(instr, handle)</code> removes and returns the operand at
<code>handle</code> in <code>instr</code>'s sources.
</blockquote>
<p>
As described in the rest of this document, the OPI contains several
other sequences.  Since some of these sequences cannot be directly
manipulated, we don't necessarily supply an equivalent full set of
functions for every sequence.  The library documents are the ultimate
authority on which functions are available for each
sequence. <b>[</b>If you find that we have not yet have implemented
one of these functions for a mutable sequence, you can always add what
we've missed for yourself.<b>]</b> 
<p>
The destination operands in an <code>Instr</code> object and the instructions
in an <code>InstrList</code> object also form sequences.  Each has a
correspondingly named set of operations, except that <code>dst</code> and
<code>instr</code> replace <code>src</code>.  
<p>
Unlike class <code>Instr</code>, an <code>InstrList</code> contains only the one
sequence, and so it is convenient to define nicknames for its sequence
operations.  We create nicknames by dropping the <code>instrs_</code> prefix
and the <code>_instr</code> suffix on the sequence operations.  For example,
you can use <code>insert_before</code> instead of <code>insert_before_instr</code> when
modifying an <code>InstrList</code>, and you can just use the function <code>size</code>
to obtain its length.
<p>
<h5><a name=toc22>Argument order.</a></h5>
<p>
There are a couple of guidelines that can help you remember the order of
arguments to OPI functions.  When a function's purpose is to access or
modify a single object, that object is always the first argument.  Whenever
functions come in pairs, such as <code>get_src</code> and <code>set_src</code>, the positions
of corresponding arguments are as similar as possible.  Thus the
position-marking argument to <code>set_src</code> is the second argument, for
consistency with <code>get_src</code>.
<p>
<h5><a name=toc23>Use of explicit pointer types.</a></h5>
<p>
As you can see from the preceding section, many of the types defined
by the OPI are explicit pointer types, but some equally important
types, such as <code>Opnd</code>, are not.  When an OPI data type seems
destined to have reference semantics in any optimization setting, the
OPI makes the semantics explicit.  We use the term <em>object</em>
to refer to an IR data structure implemented as a pointer to a
heap-allocated record (although we often slur the distinction between
the pointer itself and the record).  Thus an instruction (<code>Instr*</code>)
is an object (in fact, an IR object), but an operand (<code>Opnd</code>),
though an important IR component, is not an object.
<p>
Using explicit pointer types serves as a reminder that objects are shared
unless explicitly copied, and that you must pay some attention to the
storage management of objects.  We also use the prefix <code>new_</code> on
the functions that produce objects, but not on those that produce
IR components with value semantics.
<p>
<h5><a name=toc24>Storage management.</a></h5>
<p>
The OPI describes when an object is the <em>owner</em> of one or more of its
components.  For example, an instruction-list object (of type
<code>InstrList*</code>) owns the instructions (type <code>Instr*</code>) that it contains.
Ownership means that reclaiming an object also reclaims the ones that it
owns.
<p>
The non-pointer components of an object are always owned by it.  An
instruction always owns its operands, for example.  Pointer components,
however, are often shared between objects, and you need to be aware of the
ownership rules, since if you excise an object from its owner and don't
attach it to another object, you must <code>delete</code> the excised-object
pointer.  For instance, when a dead-code elimination algorithm removes an
unneeded instruction from a CFG node, it applies <code>delete</code> to the
instruction pointer.
<p>
Section&nbsp;<a href="#sec-building-ir">[-&gt;]</a> gives the rules of object ownership as it goes
through the IR categories.
<p>
<h5><a name=toc25>Type resolution and casting.</a></h5>
<p>
Some IR object types are refinements of others.  For example, <code>VarSym</code>
is a refinement of <code>Sym</code>, which in turn refines <code>IrObject</code>.  Suppose
you have extracted an annotation value of type <code>IrObject*</code> and you want
to verify that it is a symbol and then test whether it's a variable symbol
or a label.  You could use the following code (where <code>target</code> is an
<code>IrObject*</code>):
<p>
<pre>
    claim(is_kind_of&lt;Sym&gt;(target));
    if (is_a&lt;LabelSym&gt;(target)) {
        LabelSym *label = (LabelSym*)target;
          ...
    } else {
        ProcSym *proc = to&lt;ProcSym&gt;(target);
          ...
    }        
</pre>

Here <code>is_kind_of</code>, <code>is_a</code>, and <code>to</code> are template functions for
testing object types.  The expression <code>is_kind_of&lt;Sym&gt;(target)</code> is true
provided the object bound to <code>target</code> is a <code>Sym</code> or a refinement of
<code>Sym</code>.  The expression <code>is_a&lt;LabelSym&gt;(target)</code> is true provided
<code>target</code> is exactly a <code>LabelSym*</code>.  As the example illustrates, once
the type of an object has been verified, it can safely be cast to that
type.  The expression <code>to&lt;ProcSym&gt;(target)</code> combines verification and
casting in one expression: it verifies that <code>is_kind_of&lt;ProcSym&gt;(target)</code>
is true and then casts <code>target</code> to type <code>ProcSym*</code>.
<p>
Note that the type parameter to each of these template functions omits the
<code>*</code>, even though the object type in question is always a pointer type.
<p>


<h2><a name=toc26>Building and Manipulating the Intermediate Representation</a></h2>
<a name="sec-building-ir"><b>[*]</b></a>
<p>
This section describes in more detail how to build and manipulate
machine-code IR using the OPI.
<p>
<h3><a name=toc27>Symbols and Scopes</a></h3>
<p>
The symbols of a unit being compiled, including variables and labels, are
not owned by the code representation.  They're recorded in a scope table,
which also owns them, so you don't have to worry about deleting a symbol if
you eliminate the last reference to it.
<p>
Scope tables aren't explicit in the OPI.  As explained below, there
are functions that help you to create a symbol in the current scope
and predicates that allow you to determine the scope of a symbol.
<p>
<h5><a name=toc28>Symbol creation.</a></h5>
<p>
To create a new variable in the current file, you evaluate
<code>new_unique_var(type, name)</code>.  The <code>type</code> argument sets the type
of the variable, and <code>name</code> is an <code>IdString</code> used as the basis of
its printed form.  To this base string, <code>new_unique_var</code> appends an
integer that makes the new symbol unique within the current
optimization scope.
<p>
There is an analogous function <code>new_unique_label</code> for creating label
symbols.
<p>
<h5><a name=toc29>Symbol properties.</a></h5>
<p>
To determine the declared type of a variable, apply <code>get_type</code> to its
symbol.  From the resulting <code>TypeId</code>, you can learn how much storage the
variable needs, which register file, if any, it ought to reside in, and so
on.
<p>
To determine the scope of any kind of symbol, use one or more of
the following:
<p>
<blockquote>
<code>is_global(sym)</code> is true if <code>sym</code> is not local to a procedure. <br><code>is_external(sym)</code> is true if <code>sym</code> is visible externally. <br><code>is_defined(sym)</code> is true if <code>sym</code> is global and defined in the current
file set. <br><code>is_private(sym)</code> is true if <code>sym</code> is global, but not visible externally. <br><code>is_auto(var)</code> is true of a variable symbol that's local to a procedure.
</blockquote>
<p>
A symbol visible externally may have its defining declaration in the
current file set (in which case is satisfies <code>is_defined</code>) or not.
<p>

<h3><a name=toc30>Instructions and Instruction Lists</a></h3>
<p>
<h5><a name=toc31>Instruction lists.</a></h5>
<p>
The instruction-list object (type <code>InstrList*</code>) is the representation of
choice for tasks that don't need control-flow or dependence information.
It is used for initial code generation and finalization (stack-frame
layout), for example.  Most of the operations on instruction lists were
mentioned above in describing the conventional sequence functions.  The one
that remains is the creation function <code>new_instr_list</code>, which takes no
arguments and returns a newly-allocated, empty <code>InstrList</code> object.
<p>
<h5><a name=toc32>Instructions.</a></h5>
<p>
The OPI divides instructions into broad categories and provides a mnemonic
for each:
<p>
<ul>
<li>Active instructions (real machine operations)
<ul>
<li>(<code>alm</code>) Arithmetic, logical, and memory instructions
<li>(<code>cti</code>) Control-transfer instructions
</ul>
<li>Inactive instructions
<ul>
<li>(<code>label</code>) Label instructions
<li>(<code>dot</code>) Assembler pseudo-operations <b>[</b>
Many assemblers use a leading period (``<code>.</code>'') to
identify non-code directives.<b>]</b> 
</ul>
</ul>
<p>
The <code>alm</code> category covers all actual instructions that don't modify the
program counter non-trivially.  The <code>cti</code> category covers
control-transfers like conditional and unconditional branches and function
calls.  Each contains a symbol that represents the transfer target.  On
some machines, a control-transfer instruction can perform arithmetic, so it
might have side effects other than modifying the program counter or
setting a return-address register.  A <code>label</code> ``instruction'' simply
labels a spot in the instruction list, typically to serve as the target of
a branch.  A <code>dot</code> instruction is a directive such a one that adjusts
alignment or initializes a data cell.
<p>
When creating an instruction, you pick the category that most closely
matches your need.  The only constraints to be aware of are pretty obvious:
an active instruction can never acquire a label, an instruction that needs
a transfer target (i.e., a <code>target</code> symbol) must be created as a
control-transfer instruction, and so on.
<p>
Classifying instructions helps in naming instruction-creation functions
(<em>creators</em>, for short).  Having creators tailored to the categories
is convenient because their argument types and numbers are appropriate for
the kind of instruction being created.  The breakdown into categories is
also conducive to efficient representation of instructions.
<p>
Here is a sampling of the instruction creators in the OPI:
<p>
<pre>
    Instr* new_instr_alm(int opcode);
    Instr* new_instr_alm(int opcode, Opnd src);

    Instr* new_instr_alm(Opnd dst, int opcode);
    Instr* new_instr_alm(Opnd dst, int opcode, Opnd src);

    Instr* new_instr_cti(int opcode, Sym *target);
    Instr* new_instr_cti(int opcode, Sym *target, Opnd src);

    Instr* new_instr_cti(Opnd dst, int opcode, Sym *target);
    Instr* new_instr_cti(Opnd dst, int opcode, Sym *target, Opnd src);

    Instr* new_instr_label(LabelSym* label);

    Instr* new_instr_dot(int opcode);
    Instr* new_instr_dot(int opcode, Opnd src);
</pre>

Note that the opcode argument always separates the destination from the
sources, if any.  The only difference between two overloadings with the
same name is that they allow different numbers of operands to be put in the
created instruction.  Of course, the number can always be adjusted later.
To obtain an instruction with more than one destination or more than two
sources, you must use one of the above creators and then add operands to
the result.
<p>
As an example, consider an Alpha instruction subtracts 64 from the contents
of the stack-pointer register <code>$sp</code>.  We want to create this instruction
and append it to an instruction list such as might be used in generating code.
After the instruction list has been initialized by a declaration like
<p>
<pre>
    InstrList* body = new_instr_list();
</pre>

you append the substract instruction as follows:
<p>
<pre>
    append(body, new_instr_alm(reg_sp, SUBQ, reg_sp, immed_64));
</pre>

Here <code>SUBQ</code> is the appropriate Alpha integer-subtraction opcode,
and we have assumed that <code>reg_sp</code> is a register operand representing
<code>$sp</code> and <code>immed_64</code> is an operand for the literal constant 64.
(You'll see how to create these in the next subsection.)
<p>
The OPI also contains typed opcode generators, such as
<code>opcode_load(TypeId)</code>.  These generators provide parameterized
optimizations with access to machine-specific opcodes.
<p>

<h3><a name=toc33>Operands</a></h3>
<a name="sec-operands"><b>[*]</b></a>
<p>
In the OPI, every instruction operand has the base type <code>Opnd</code>.  The
OPI typically implements several kinds of operands, though one
implementation of the OPI does not have to implement all of the kinds
found in another implementation.  Furthermore, you can
extend the OPI with new kinds of operands without modifying any
of the existing functions in the OPI.
<p>
<h5><a name=toc34>Atomic operands.</a></h5>
<p>
The OPI defines a distinguished set of these operand kinds as <em>atomic</em>.  An atomic operand is one that is immutable.  If you want to
change a component of one of these operands, you must create new one.
Here is a list of commonly-used atomic operands:
<p>
<ul>
<li><em>Null operands</em> are content free.  They are occasionally useful as
placeholders in instructions, but typically you will just use them in
coding to mean ``no operand at all''.
<li><em>Variable-symbol operands</em> stand for the occurrences of variables,
both those originating in the source program and those generated as
compiler temporaries.
<li><em>Register operands</em> designate registers used by
instructions.  They come in two flavors: real hardware registers
(called <em>hard</em> registers) and compiler-generated
temporaries or pseudo-registers (called <em>virtual</em>
registers).  A register allocation pass eliminates references to
variable symbols and virtual registers by replacing them with
hard registers and/or spilling their values to memory.
<li><em>Immediate operands</em> represent constants in the instruction stream.
<li><em>Address symbols</em> stand for effective address calculations
composed of a reference to a variable symbol's memory location,
i.e., the memory address of a variable.
</ul>
<p>
<h5><a name=toc35>Address expressions.</a></h5> These are the only kind of non-atomic
operand kind that we define today.  Address expressions are effective
addresses formed by operating on one or more suboperands.  Address
expressions are non-atomic because you can replace one or more of the
suboperands of an address-expression operand.  There are several
kinds of address expressions, and each is treated as a different kind
of operand.  
<p>
For example, an operand may refer to a memory-resident value using the
base-plus-displacement addressing mode.  This is an example of an
address-expression operand consisting of a register or variable-symbol
operand (base) plus an immediate operand (fixed displacement).
Address-expression operands have the type <code>AddrExpOpnd</code>, which is a
subclass of <code>Opnd</code>.  Address-expression operands representing the
base-plus-displacement addressing mode have the derived type
<code>BaseDispOpnd</code>, which is a subclass of <code>AddrExpOpnd</code>.
<p>
As you can see, address-expression operands are an extension of the
base class <code>Opnd</code>.  <em>The Extender's Guide</em> describes this
extension process in detail.  Here, we simply describe the common
features of address-expression operands and discuss the functionality
of two specific kinds.
<p>

<h4><a name=toc36>Common operations on all operands</a></h4>
<a name="sec-opnd-ops"><b>[*]</b></a>
<p>
Most of the OPI's operations on operands have to do with one kind or
another.  Before going through the kinds individually to sketch these
functions and class methods, we'll mention some properties associated
with every kind of operand.  You can think of these properties as
methods on the base class <code>Opnd</code>; however, we have implemented them
in the OPI as functions.
<p>
<h5><a name=toc37>Operand type.</a></h5>
<p>
Every operand has a type, i.e., a <code>TypeId</code> that gives the type of the
value represented by the operand.  Evaluate <code>get_type(opnd)</code> to obtain
the type of <code>opnd</code>.
<p>
For address operands (i.e., those that satisfy the <code>is_addr</code>
predicate), it is often useful to be able to determine the
<em>referent</em> type of the address operand.  The referent type is the
type of the value obtained by dereferencing the address that the
operand represents.  You can access this <code>TypeId</code> using the
function <code>get_deref_type(Opnd)</code>.  There is no corresponding ``set''
function; you must build the appropriate address operand from
scratch.
<p>

<h5><a name=toc38>Operand kind.</a></h5>
<p>
You often need to check the kind of an operand, e.g., to ask whether
it stands for a variable or a register.  For each operand kind, there
is a predicate that indicates whether an operand is of the kind in
question.  Thus, <code>is_reg(opnd)</code> returns true if <code>opnd</code> is a
register operand, and <code>is_var(opnd)</code> tests whether it's a
variable-symbol operand.  Other kind predicates will be mentioned as
we go through the kinds below.
<p>
Sometime you need to dispatch on the operand kind.  For that, the OPI
provides a <code>get_kind</code> function that returns an integer kind indicator.
For example,
<p>
<pre>
    switch (get_kind(opnd)) {
      case opnd::NONE:
        // opnd is null
      case opnd::REG:
        // opnd is a register operand
      ...
    }
</pre>

<h5><a name=toc39>Operand copying.</a></h5>
<p>
Any operand can be copied using the function <code>clone</code>.  As discussed
in Section&nbsp;<a href="#sec-ref-value">[&lt;-]</a>, we sometimes <code>clone</code> an operand,
as shown below, to ensure that we produce a completely independent copy.
<p>
<pre>
    Opnd d = get_dst(mi1, 0);
    set_src(mi2, 0, clone(d));
</pre>

This code sequence grabs the 0th destination operand out of the
instruction <code>mi1</code>, makes a copy of it using the function <code>clone</code>,
and then stores this new operand as the 0th source operand of the
instruction <code>mi2</code>.  For this example, the function <code>clone</code> is
harmless.  If <code>d</code> was a mutable kind of operand (e.g., an address
expression), we may use <code>clone</code> to make it very clear that we're
modifying a copy of <code>d</code> for use in <code>mi2</code> and not trying to change 
the original operand <code>d</code> in <code>mi1</code>.
<p>

<h5><a name=toc40>Operand equality.</a></h5>
<p>
Two operands are equal under operator (<code>==</code>) only if their kind
and type attributes are equal and they satisfy additional conditions.
These conditions are spelled out below.  The disequality operator (<code>!=</code>)
just inverts the equality result.
<p>

<h5><a name=toc41>Operand hashing.</a></h5>
<p>
Because you sometimes need to create hash maps keyed by operands, there is
a function <code>hash</code> that extracts a hash code from an operand.
<p>
<h5><a name=toc42>Operand printing.</a></h5>
<p>
For debugging purposes, function <code>fprint</code> prints an operand in a
machine-independent manner.  This is not the way operands are printed in
machine-specific assembly output, of course.  That's handled by a
target-specific library, as described in <em>The Extender's Guide</em>.
But for debugging printout of <code>opnd</code>, you can write, e.g.,
<code>fprint(stderr, opnd)</code>.
<p>

<h4><a name=toc43>Features and examples of atomic operands</a></h4>
<p>
Let's touch on the properties specific to each kind of atomic operand.
<p>
<h6><a name=toc44>Null operands.</a></h6>
<p>
A null operand has kind <code>opnd::NONE</code>.  Its type, as returned by
<code>get_type</code>, is always a representation of <code>void</code>.  Any null operand is
equal to another one.  The parameterless function <code>opnd_null</code> creates a
null operand.  The predicate <code>is_null</code> returns true exactly when applied
to a null operand.
<p>
<h6><a name=toc45>Variable-symbol operands.</a></h6>
<p>
A variable-symbol operand has kind <code>opnd::VAR</code>.  The type that
<code>get_type</code> returns for such an operand is always exactly the type of the
underlying variable symbol.  Two variable-symbol operands are equal if and
only if their embedded symbols are identical.  The predicate <code>is_var</code>
returns true exactly when applied to a variable-symbol operand.
<p>
To create a variable-symbol operand, apply <code>opnd_var</code> to the variable
symbol.  To retrieve the symbol from such a operand, apply <code>get_var</code> to
it.
<p>
<h6><a name=toc46>Register operands.</a></h6>
<p>
There are two kinds of register operands: one representing hard
(real machine) registers, and the other representing virtual
(compiler) registers.  Their kind identifiers, respectively,
are <code>opnd::REG_HARD</code> and <code>opnd::REG_VIRTUAL</code>.  
<p>
Each contains a non-negative integer register number and a value type
(<code>TypeId</code>).  Two register operands are equal if and only if their
kind, register numbers, and types are pairwise equal.  The predicates
<code>is_hard_reg</code> and <code>is_virtual_reg</code> identify hard-register operands
and virtual-register operands, respectively.  The predicate <code>is_reg</code>
returns true exactly when applied to any kind of register operand.
<p>
A hard register number is non-negative, and like the opcode of an
instruction, its meaning depends on the target machine with respect to
which the operand is interpreted.  The <code>RegInfo*</code> object for the target
tells you how to interpret its hard register numbers.  In particular, it
maintains the correspondence between the numbers used in operands and the
concrete encodings used by the hardware.
<p>
The exact number used for a virtual register number is typically
unimportant and is assigned automatically when you create the operand
using <code>opnd_reg(type)</code>, where <code>type</code> is the type of the value
contained in the register.  You can create as many distinct
virtual-register operands as you need.
<p>
To create a hard-register operand, evaluate <code>opnd_reg(num, type)</code>, where
<code>num</code> is a valid (non-negative) register number for the target.  If
you want to create a virtual-register operand with a specific register
number <code>num</code>, evaluate <code>opnd_reg(num, type, true)</code>, where the last
parameter to this function indicates that you desire a virtual register
and not a hard register.
<p>
To retrieve the register number of a register operand, apply <code>get_reg</code> to
it.
<p>
<h6><a name=toc47>Immediate operands.</a></h6>
<p>
There are two kinds of immediate operands: one holds integers and the
other strings.  Their kind identifiers, respectively, are
<code>opnd::IMMED_INTEGER</code> and <code>opnd::IMMED_STRING</code>.  Two immediate
operands are equal if and only if their kinds, types, and values
(integer or string) are pairwise equal.
<p>
Predicate <code>is_immed</code> returns true exactly when applied to an immediate
operand.  In addition, the predicates <code>is_immed_integer</code> and
<code>is_immed_string</code> detect integer-immediate and string-immediate
operands, respectively.
<p>
Integer immediates can represent either signed or unsigned integer
immediate values of any magnitude.  The accompanying type gives the
intended precision.  For floating-point immediate operands, we use strings
describing the numeric value, again paired with a type.  We also use
untyped immediate string operands, though they don't appear in active
(<code>alm</code> or <code>cti</code>) instructions.  They allow the pseudo-instruction
(<code>dot</code>) class, which sometimes requires string literals, to use the same
operand interface as the other instruction classes.
<p>
To create an integer immediate, evaluate <code>opnd_immed(integer, type)</code>,
where <code>integer</code> has an integral C type, or else type <code>Integer</code>, and
<code>type</code> is a <code>TypeId</code> that represents an integer type.  For example,
<code>opnd_immed(42, type_s32)</code> yields an immediate operand for the signed,
32-bit integer 42.  Creating a floating-point immediate operand is similar,
but you pass the literal's representation as a string:
<code>opnd_immed(&quot;3.141592653589793&quot;, type_f64)</code>.  To create an
untyped string-immediate operand, omit the type:
<code>opnd_immed(&quot;Hello, world.\n&quot;)</code>. 
<p>
When an <code>opnd</code> satisfies <code>is_immed_string(opnd)</code>, you can tell whether
it's a numeric operand or not by checking its type:
<code>is_null(get_type(opnd))</code> returns <code>true</code> if <code>opnd</code> represents a
simple string literal.  (In practice, the nature of the immediate operand
is nearly always apparent from the context.)
<p>
To retrieve the value part of an immediate <code>opnd</code>, use
<code>get_immed_integer(opnd)</code>, which returns an <code>Integer</code>, or
<code>get_immed_string(opnd)</code>, which returns an <code>IdString</code>.
<p>
<h6><a name=toc48>Address symbols.</a></h6>
<p>
An address-symbol operand has kind <code>opnd::ADDR_SYM</code>.  Its type component
is implicit; it's always the generic pointer type for the intended target.
Two address-symbol operands are equal if and only if they are based on
identical symbols.  The predicate <code>is_addr_sym</code> returns true exactly when
applied to an address-symbol operand.
<p>
To create one, apply <code>opnd_addr_sym</code> to a symbol:
<code>opnd_addr_sym(sym)</code>.  To retrieve the underlying symbol:
<code>get_sym(opnd)</code>.
<p>
As an example, consider an <i>x</i>86 add-to-memory instruction that adds 42 to
the contents of a memory-resident variable <code>foo</code>.  Although the <i>x</i>86 family has a
two-address ISA, the OPI representation of this instruction recognizes the
fact that <code>foo</code> is both an input and an output of it.  So <code>foo</code>'s
address appears as both a source and a destination.  If <code>var_foo</code> is the
<code>VarSym*</code> representing <code>foo</code>, the OPI code to create the add
instruction and append it to an instruction-list called <code>body</code> might look
like this:
<p>
<pre>
    Opnd addr  = opnd_addr_sym(var_foo);
    Opnd int42 = opnd_immed(42, type_s32);

    append(body, new_instr_alm(addr, xo_, ADDR, int42));
</pre>


<h4><a name=toc49>Features and examples of address-expression operands</a></h4>
<p>
An address-expression operand represents a non-trivial
effective-address calculation, such as the addition of a fixed
displacement to the contents of a base register to form a storage
address.  Since it represents a computation taking place within an
instruction, an address expression is a bit like a
``subinstruction''.  Many of the transformations optimizers perform
on the operands of an instruction need to be applicable as well to the
components of an address expression.  For example, a register
allocator wants to replace virtual registers with hard registers.
Since a virtual register might appear as the base register in an
address expression, the sweep over the IR that makes the register
substitution needs to treat the components of an address expression in
the same way as other instruction components.  Therefore, an address
expression, like an instruction, contains operands (in this case
suboperands) that you can inspect and change.
<p>
Given an operand <code>opnd</code>, you can determine if it is an address
expression by passing <code>opnd</code> as a parameter to the function
<code>is_addr_exp</code>.  The operations applicable to address expresssions
are defined by the public methods on the class <code>AddrExpOpnd</code> and its
base class <code>Opnd</code>.  You create an address-expression operand using
one of the class constructors.
<p>
For example, you can construct an empty address-expression operand
using <code>AddrExpOpnd</code>, access the type of that address expression
using the method <code>get_type</code>, and operate on the sequence of
suboperands using methods that are named like and act like the
sequence operators for instructions.  In particular, <code>srcs_size</code>
returns the number of suboperands and <code>get_src(0)</code> returns the
first suboperand.  Since IR components of type <code>Opnd</code> have value
semantics, if you get an address-expression operand <code>opnd_ae</code> from
an instruction <code>instr</code>, remember that you must replace <code>opnd_ae</code>
in <code>instr</code> if you modify any of its suboperands using the method
<code>set_src</code>.
<p>
All of the suboperands of an address-expression are considered to be
sources; there are no destinations.  The effective-address calculation
is always expressed without side effects.  (The side effects implicit
in hardware address modes like auto-increment are represented in other
ways.)
<p>
<h5><a name=toc50>Address-expression type.</a></h5>
<p>
Like address-symbol operands, address expressions have an implicit
type.  That is, you don't specify a type when creating one, and
<code>get_type</code> always returns the current target's generic pointer type
when it is applied to an address operand.
<p>
<h5><a name=toc51>Address-expression kind.</a></h5>  
<p>
Because you usually know from the context how many suboperands there
are in an address expression, you may find it more convenient to refer
to the address expression using a more descriptive name and its
component operands by their role rather than their numeric position.
The OPI defines several varieties of address expression, corresponding
to the addressing modes commonly used in hardware.  The <em>OPI
Extender's Guide</em> tells you how to add others, if you need to.  In the
rest of this section, we describe two example specializations of
<code>AddrExpOpnd</code> for base-plus-displacement (<code>BaseDispOpnd</code>) and
symbol-plus-displacement (<code>SymDispOpnd</code>) addressing modes.  The full
set we provide is present in the <em>Machine Library</em> document.
<p>
There is no operand kind that covers all varieties of address
expression.  Each is an operand kind in its own right.  Thus the
base-plus-displacement operands have kind <code>opnd::BASE_DISP</code>.  Another
variety we will mention below consists of an address symbol plus a
fixed displacement.  Its operand-kind identifier is <code>opnd::SYM_DISP</code>.
In general, the kind identifiers for address expressions are formed in
the same way, by concatenating the role names of their parts.
<p>
<h5><a name=toc52>Address-expression equality.</a></h5>
<p>
Two address expressions are equal exactly when they have the same kind
and their components are pairwise equal.
<p>

<h5><a name=toc53>Base-plus-displacement operands.</a></h5>
<p>
A base-plus-displacement operand has public methods for fetching
and replacing its base and displacement components.  To illustrate,
let's change our example of the <i>x</i>86 add-to-memory instruction that
adds 42 to <code>foo</code>.  Suppose now that <code>foo</code> has been allocated at
displacement -100 relative to the base of the stack frame of the
procedure in which it is declared.  If the hard-register operand
<code>ebp</code> represents the base pointer register, then the code to create
the add instruction might be revised as follows:
<p>
<pre>
    BaseDispOpnd addr(ebp, opnd_immed(-100, type_s32));
    Opnd int42 = opnd_immed(42, type_s32);

    append(body, new_instr_alm(addr, xo_, CLONE(addr), int42));
</pre>

The base may be either a register operand or a variable-symbol operand
(kind <code>opnd::VAR</code>).  In the latter case, the variable must eventually
be replaced by a register to make the compiled code executable.  The
base is fetched using <code>get_base</code> and replaced using <code>set_base</code>.
The displacement part has similar functions <code>get_disp</code> and
<code>set_disp</code>.
<p>
<h5><a name=toc54>Symbol-plus-displacement operands.</a></h5>
<p>
Another common address mode combines the address of a symbol with a
fixed displacement.  The corresponding operand kind is
<code>opnd::SYM_DISP</code>.  You create such an operand from an address-symbol
<code>addr_sym</code> and a displacement <code>disp</code> using the constructor
<code>SymDispOpnd(addr_sym, disp)</code>.  Please note that <code>addr_sym</code> is of
kind <code>opnd::ADDR_SYM</code>, not <code>opnd::VAR</code>.
<p>
The fetch and replace functions for the address-symbol part are
<code>get_addr_sym</code> and <code>set_addr_sym</code>.  Those for the displacement
part are again <code>get_disp</code> and <code>set_disp</code>.
<p>


<h3><a name=toc55>Control Flow Graphs</a></h3>
<a name="sec-cfg"><b>[*]</b></a>
<p>
As mentioned in Section&nbsp;<a href="#sec-representing-code">[&lt;-]</a>, the OPI provides a
flow-graph representation as an alternative to simple instruction lists.
In this representation, the body of a compilation unit has type <code>Cfg*</code>.
It stands for a collection of CFG nodes (of type <code>CfgNode*</code>), each of
which represents a basic block, i.e., a list of instructions that are
executed in sequence.  There are also distinguished entry and exit nodes
(one each) neither of which contains instructions.
<p>
The edges of the CFG are expressed implicitly: a node contains a set
representing its flow predecessors and a sequence representing its
successors.  One of the instructions of a node (normally the last) may be a
control-transfer instruction (CTI).  The identities and the order of its
target labels must correspond to the successor sequence of the node.  If a
node can ``fall through'', either because it has no CTI or because the CTI
might not divert control flow, then it also has a fall-through successor,
which always comes first in the successor sequence.  There can be multiple
flow edges from one node to another, in which case, the latter appears more
than once in the successor sequence of the former.
<p>
Sometimes an optimization wants to manipulate code in graph form but still
retain precise control over the layout of instructions when the code is
convert to linear (<code>InstrList</code>) form.  Under the OPI, you can give each
node layout constraints that require it to appear at a particular position
in relation to other nodes when the enclosing graph is linearized.
<p>

<h4><a name=toc56>Properties of <code>Cfg</code> Objects</a></h4>
<a name="sec-cfg-properties"><b>[*]</b></a>
<p>
The principal component of a <code>Cfg</code> is its collection of nodes.  You can
access these using sequence functions analogous to those for an
<code>InstrList</code> object.  However, you can't change a CFG by operating on its
node collection directly, so the only sequence functions defined are those
that inspect the collection, not those that modify it.  In addition, there
are functions <code>get_entry_node</code> and <code>get_exit_node</code> that return the
special entry and exit nodes of a CFG.
<p>
The sequence of nodes in a <code>Cfg</code> has the name <code>nodes</code>, and you can
apply the following functions to this sequence:
<p>
<blockquote>
<code>nodes_size(cfg)</code> returns the number of nodes in <code>cfg</code>. <br><code>nodes_start(cfg)</code> returns a handle on the first node of <code>cfg</code>. <br><code>nodes_last(cfg)</code> returns a handle on the last node of <code>cfg</code>. <br><code>nodes_end(cfg)</code> returns the sentinel handle for the node
sequence of <code>cfg</code>. <br><code>get_node(cfg, pos)</code> returns the node of <code>cfg</code> at position
<code>pos</code>, which is a zero-based integer. <br><code>get_node(cfg, handle)</code> returns the node of <code>cfg</code> at <code>handle</code>.
(This is the same as <code>*handle</code>.)
</blockquote>
<p>
A CFG has one special way of accessing its sequence members.  If you
evaluate <code>node_at(cfg, label)</code>, where <code>label</code> is a code label, you get
the node that contains the corresponding label instruction (or <code>NULL</code>, if
<code>cfg</code> has no such node).
<p>

<h4><a name=toc57>Properties of <code>CfgNode</code> Objects</a></h4>
<a name="sec-cfg-node-properties"><b>[*]</b></a>
<p>
A <code>CfgNode</code> object is made up of the following components:
<p>
<ul>
<li><code>parent</code>, the <code>Cfg</code> object that owns the node.
<li><code>number</code>, an identifying integer guaranteed to be less than the
number of nodes in the parent CFG.
<li><code>label</code>, a <code>LabelSym</code> that is one of the labels at the beginning
of the node's instructions.
<li><code>instrs</code>, the sequence of instructions that is the main content of
the node.
<li><code>cti_handle</code>, a handle on the <code>instrs</code> sequence that locates the
node's CTI, if any.
<li><code>preds</code> and <code>succs</code>, the sequences giving the node's control
predecessors and successors.
<li><code>layout_pred</code> and <code>layout_succ</code>, node pointers that if non-null,
dictate which node the current node must follow and/or precede when
laid out in linear order.
</ul>
<p>
<h5><a name=toc58>Checking a node's identity.</a></h5>
<p>
You fetch the parent CFG of <code>node</code> by evaluating <code>get_parent(node)</code>.
You fetch its <code>number</code> using <code>get_number(node)</code>.  The <code>label</code>
``component'' is produced by <code>get_label(node)</code>, but it is actually taken
from the first of <code>node</code>'s label instructions.  If there is no such,
<code>get_label</code> adds one with a new label symbol and returns that symbol.
 <b>[</b>To simply check whether a node <em>has</em> a label, write
<code>size(node) &gt; 0 &amp;&amp; is_label(*start(node))</code>.<b>]</b> 
<p>
<h5><a name=toc59>Manipulating the instruction sequence.</a></h5>
<p>
The main content of a CFG node is its instruction sequence.  You can scan
and edit this sequence using the same function calls that you'd use for the
contents of an <code>InstrList</code> object.  Simply pass a <code>CfgNode</code> as the
first argument instead of the instruction list.
<p>
In fact, the same nickname convention applies.  Although a <code>CfgNode</code>
contains three sequences, its principal role is as a container of
instructions, and you will need to use the <code>instrs</code> sequence functions a
lot.  So you can use the same nicknames as for the corresponding functions
of an <code>InstrList</code>.  E.g., <code>instrs_size(node)</code> can be shortened to
<code>size(node)</code>, and so on.
<p>
<h5><a name=toc60>Accessing successors and predecessors.</a></h5>
<p>
The other sequences in a node, <code>succs</code> and <code>preds</code>, aren't mutable
using sequence functions, except that <code>set_succ</code> alters an element of
<code>succs</code> and adjusts predecessor sets as necessary to maintain consistency
(see Section&nbsp;<a href="#sec-representing-code">[&lt;-]</a>).  However, for scanning the
<code>succs</code> and <code>preds</code> sequences, you use the usual sequence functions.
For example, this snippet returns <code>true</code> from its enclosing function if
node pair (<code>tail</code>,<code>head</code>) is an edge in the parent CFG, and returns
<code>false</code> otherwise.
<p>
<pre>
    for (CfgNodeHandle h = succs_start(tail); h != succs_end(tail); ++h)
        if (head == *h)
            return true;
    return false;
</pre>

Because conditional branches are so common, the OPI defines convenient
(though redundant) functions for accessing their successors:
<code>fall_succ(node)</code> is equivalent to <code>get_succ(node, 0)</code>, and
<code>taken_succ(node)</code> is equivalent to <code>get_succ(node, 1)</code>.
<p>
<h5><a name=toc61>Inspecting and testing the CTI.</a></h5>
<p>
To fetch the <code>cti_handle</code> of <code>node</code>, evaluate <code>get_cti_handle(node)</code>.
The result, which has type <code>InstrHandle</code>, is a handle on <code>node</code>'s CTI,
if it has one; otherwise, it's the sentinel handle for the <code>instrs</code> of
the node.  To simply fetch the CTI itself, use <code>get_cti(node)</code>.  There
are no corresponding <code>set_</code> functions for the CTI.  To change a node's
CTI, you first change the instruction sequence directly and then call
<code>reflect_cti</code>, which is described in Section&nbsp;<a href="#sec-flow-relations">[-&gt;]</a>.
<p>
Because it's often necessary to test whether a node is terminated by a CTI,
and if so, what kind, there are node predicates for doing so.
<p>
<blockquote>
<code>ends_in_cti(node)</code> returns true if <code>node</code> has a CTI. <br><code>ends_in_ubr(node)</code> returns true if <code>node</code> has a CTI satisfying
<code>is_ubr</code>. <br><code>ends_in_cbr(node)</code> returns true if <code>node</code> has a CTI satisfying
<code>is_cbr</code>. <br><code>ends_in_mbr(node)</code> returns true if <code>node</code> has a CTI satisfying
<code>is_mbr</code>. <br><code>ends_in_call(node)</code> returns true if <code>node</code> has a CTI satisfying
<code>is_call</code>. <br><code>ends_in_return(node)</code> returns true if <code>node</code> has a CTI satisfying
<code>is_return</code>.
</blockquote>
<p>

<h5><a name=toc62>Finding a node's boundary instructions.</a></h5>
<p>
It is sometimes useful to find the first ``real'' instruction in a node,
i.e., the first one other than a label or some other kind of marker.
It's occasionally useful to identify the last non-control-transfer
instruction in a node.  The following functions identify such ``boundary''
instructions within a node.
<p>
<blockquote>
<code>first_non_label(node)</code> returns the first instruction in <code>node</code>
that isn't a label. <br><code>first_active(node)</code> returns the first instruction in <code>node</code> that
isn't a label, a pseudo-instruction, or a null-opcode instruction. <br><code>last_non_cti(node)</code> returns the last instruction of <code>node</code> that
isn't its CTI.
</blockquote>
<p>
Each of these boundary-instruction functions returns <code>NULL</code> if there is
no qualifying instruction.
<p>
<h5><a name=toc63>Inspecting the layout constraints.</a></h5>
<p>
The <code>layout_pred</code> and <code>layout_succ</code> components of <code>node</code> are produced
by <code>get_layout_pred(node)</code> and <code>get_layout_succ(node)</code>.
Section&nbsp;<a href="#sec-layout-relations">[-&gt;]</a> describes how to modify these
components.
<p>

<h4><a name=toc64>Graph Construction and Deconstruction</a></h4>
<p>
You create a CFG by passing an <code>InstrList</code> object to function
<code>new_cfg</code>, which parses the linear instruction list into basic blocks.
There are optional Boolean arguments to <code>new_cfg</code> that control exactly what
constitutes a basic block and whether the original linear layout of the
instructions should be reflected through initial layout constraints.
<p>
Here, in order of appearance, are the optional flags to <code>new_cfg</code>:
<p>
<ul>
<li>If <code>keep_layout</code> is true, the CFG is built with layout constraints
that reflect its original linear order.  (You can dissolve any or all
of these constraints later.)
<li>If <code>break_at_call</code> is true, each procedure-call instruction is
treated as a CTI, so that it terminates the CFG node that contains
it.  Otherwise, a call is regarded like an ordinary instruction, in
the sense that a node may contain multiple calls.
<li>If <code>break_at_instr</code> is true, the graph is built with a separate
node for every non-label instruction.
</ul>
<p>
Given an existing CFG, you may want to ensure that it has the same form as
if built from scratch with a given option set.  The <code>canonicalize</code>
function serves this purpose.
<p>
Here's an example showing the use of <code>new_cfg</code> and <code>canonicalize</code>.
It's taken from a pass that wants to operate on each optimization unit in
CFG form, and it wants layout constraints imposed to remember the program's
linear order.  The optimization unit is called <code>unit</code>.
<p>
<pre>
    AnyBody *old_body = get_body(unit);
    Cfg *cfg;
    if (is_a&lt;InstrList&gt;(old_body)) {
        cfg = new_cfg((InstrList*)old_body, true);      // true =&gt; keep layout
        copy_notes(old_body, cfg);
        set_body(unit, cfg);
        delete old_body;
    } else if (is_a&lt;Cfg&gt;(old_body)) {
        cfg = (Cfg*)old_body;
        canonicalize(cfg, true);                        // true =&gt; keep layout
    } else
        claim(false, &quot;Unexpected kind of compilation unit body&quot;);
</pre>

The snippet above completely replaces the body of <code>unit</code> if it is in
linear form.  It copies any annotations from the old body to the new one in
CFG form, and it deletes the now-unreferenced instruction list.  If the
unit is already in CFG form, neither of these steps is necessary, but
<code>canonicalize</code> is called to be sure the graph has the properties that the
pass expects.
<p>
This pass chooses to preserve layout constraints, which is typical for a
pass that does little graph transformation.  Even in this mode, it can
modify the layout, either using functions on specific nodes (see
Section&nbsp;<a href="#sec-cfg-node-properties">[&lt;-]</a>) or by applying
<code>remove_layout_info</code> to the whole cfg, which clears all of its layout
constraints.
<p>
To reverse the transformation and relinearize a CFG, you call
<code>to_instr_list</code>, which takes an <code>AnyBody</code> and returns an <code>InstrList</code>.
After doing so, you typically want to delete the graph.  Since a CFG is the
owner of all its nodes, that deletes the nodes as well.
<p>


<h4><a name=toc65>Control-Flow Relations</a></h4>
<a name="sec-flow-relations"><b>[*]</b></a>
<p>
<h5><a name=toc66>Normal edges.</a></h5>
<p>
Normally, the number of successors of a <code>CfgNode</code> depends on the control
instruction that ends the node:
<p>
<ul>
<li>Unconditional-branch nodes and fall-through nodes (those that have
no terminating control instruction or that have a call instruction
as their CTI) have just one successor.        
<li>Conditional branches have two successors.  The fall-through
node is always successor number 0; the taken successor, number 1.
<li>Multiway branches have as many successors as there are entries
in the branch dispatch table.  Changing the <i>j</i>th successor of a
multiway branch modifies the <i>j</i>th dispatch table entry.  (There is
no ``default'' target label.)
</ul>
<p>
The edges induced by these flow properties of control instructions are
called <em>normal</em> edges.
<p>
<h5><a name=toc67>Abnormal edges.</a></h5>
<p>
The OPI also supports the creation of two other kinds of edges:
<em>exceptional</em> and <em>impossible</em>.  Together, we call these
<em>abnormal</em> edges.
<p>
The assumption usually made when the CFG creator encounters a procedure
call instruction is that it returns exactly once for each time the call is
executed.  In many languages, it is possible to write procedures that may
not return in the normal way, or that may return more than once for each
call.  To reflect such exceptional control paths, we provide a special kind
of successor relation, used to describe flow of control from a call site
directly to the exit node, or from the entry node to the point immediately
after a call.  We call such flow <em>exceptional</em>, since it is not the
usual thing, and since it is often associated with the raising of an
exception.  We provide functions for creating and recognizing exceptional
edges in a CFG.
<p>
Though unusual, exceptional edges are at least possible control paths.
On the other hand, there are important analysis techniques that insert
completely <em>impossible</em> edges in the CFG <b>[cite&nbsp;<a href="#NWcite-bibmorgan">bibmorgan</a>]</b>.  They may
require that every node lies on a path to the exit node, for example.
To handle an infinite loop, they insert an impossible edge from one of
the loop nodes to the exit.  We also provide functions to create and
recognize impossible edges.
<p>
When the CFG is constructed, impossible edges are included to be sure
that every node is reachable from the entry, and every node has a path
to the exit.  However, no exceptional edges appear in the CFG when it is
first constructed.  To add them, you call <code>set_exceptional_succ</code>, which
is described below.
<p>
In the <code>succs</code> component of a node, all exceptional and impossible
successors occur after the normal successors. 
<p>

<h5><a name=toc68>Making new neighbors.</a></h5>
<p>
You set the normal successors of a node using one of the following:
<p>
<blockquote>
<code>set_succ(node, pos, succ)</code>
substitutes <code>succ</code> for the node at position <code>pos</code> in the successor
sequence of <code>node</code>. <br><code>set_fall_succ(node, succ)</code> is the same as <code>set_succ(node, 0, succ)</code>. <br><code>set_taken_succ(node, succ)</code> is the same as <code>set_succ(node, 1, succ)</code>.
</blockquote>
<p>
Thus <code>set_succ(node, </code><i>n</i><code>, succ)</code> makes <code>succ</code> the new <i>n</i>-th
successor of <code>node</code>.  If necessary, each of the above functions extends
the successor sequence of <code>node</code> to accommodate at least <i>n</i>+1 elements.
It disconnects the former <i>n</i>-th successor (if any), and updates the
predecessor lists of the old and new successors.  If necessary, it also
modifies <code>node</code>'s CTI, which should be consistent with the existing
successor sequence, to reflect the change.  For example, if <code>node</code> ends
with a conditional branch, then <code>set_succ(node, 1, succ)</code> unlinks any
previous ``taken'' successor, sets it to <code>succ</code>, and replaces the target
symbol of <code>node</code>'s branch instruction with the first label of node
<code>succ</code>.
<p>
Functions <code>set_fall_succ</code> and <code>set_taken_succ</code> are provided for
convenience.  The former sets the fall-through successor.  The latter sets
the taken-branch successor of a conditional node.  You can also
conveniently swap the taken and fall-through successors of a conditional
branch node using <code>invert_branch(node)</code>.  This inverts the sense
<code>node</code>'s branch instruction by changing its opcode, with the help of the
target-specific function <code>opcode_cbr_inverse</code>.  At the same time, it
exchanges <code>node</code>'s successors.
<p>
The entry node of a CFG may have multiple successors, even though it
contains no code, and therefore has no CTI.  This allows you to introduce
exceptional edges from the entry to account for non-local control transfers
into the middle of a compilation unit.
<p>

<h5><a name=toc69>Creating abnormal edges.</a></h5>
<p>
For exceptional and impossible edges, there are special ways of setting a
successor node.
<p>
<blockquote>
<code>set_exceptional_succ(node, pos, succ)</code>
is like <code>set_succ(node, pos, succ)</code> but it also marks the new edge as
exceptional. <br><code>set_impossible_succ(node, pos, succ)</code>
is like <code>set_succ(node, pos, succ)</code> but it also marks the new edge as
impossible.
</blockquote>
<p>
<h5><a name=toc70>Testing for abnormal edges.</a></h5>
<p>
Detecting whether a particular numbered successor represents a normal,
exceptional, or impossible edge is handled by the following predicates.
For completeness, we say that a <em>possible</em> edge is one that isn't
impossible.
<p>
<blockquote>
<code>is_normal_succ(node, succ)</code> returns <code>true</code> exactly when
(<code>node</code>,<code>succ</code>) is a normal edge in the parent CFG. <br><code>is_exceptional_succ(node, succ)</code> returns <code>true</code> exactly when
(<code>node</code>,<code>succ</code>) is an exceptional edge in the parent CFG. <br><code>is_possible_succ(node, succ)</code> returns <code>true</code> exactly when
(<code>node</code>,<code>succ</code>) is a possible edge in the parent CFG. <br><code>is_impossible_succ(node, succ)</code> returns <code>true</code> exactly when
(<code>node</code>,<code>succ</code>) is an impossible edge in the parent CFG.
</blockquote>
<p>

<h5><a name=toc71>Replacing the control-transfer instruction.</a></h5>
<p>
To this point, we have not described any way of reducing the number of
successors of a node.  The <code>set_succ</code> function diverts an existing
edge, and it updates the CTI accordingly.  But sometimes, there's no
substitute for replacing the control instruction entirely.
<p>
As mentioned earlier, the OPI has no <code>set_cti</code> function.  To replace the
CTI of a node, you first change the instruction list directly and then call
<code>reflect_cti</code>.  This function records the new <code>cti_handle</code> component
and changes the node's flow successors to reflect the new control
instruction.  Obviously, if that instruction can fall through, or if the
revised node has no CTI, <code>reflect_cti</code> needs to know what to use as the
fall-through successor node.  So in general, you evaluate
<code>reflect_cti(node, cti, fall_thru)</code>, where <code>cti</code> is the intended new
CTI in <code>node</code>'s instruction sequence, and <code>fall_thru</code> is the (optional)
fall-through successor.
<p>
<code>reflect_cti</code> erases the previous successor links of <code>node</code>, including
those of exceptional and impossible successors.  If its second argument is
<code>NULL</code>, rather than a CTI instruction, the node's <code>cti_handle</code> is set
to the sentinel value <code>end(node)</code>, and the <code>fall_thru</code> node becomes its
only successor.
<p>

<h4><a name=toc72>Layout relations</a></h4>
<a name="sec-layout-relations"><b>[*]</b></a>
<p>
The OPI supports basic block placement and layout by allowing the user to
specify an ordering (partial or total) of the nodes in a CFG and its
associated procedure.  The ordering is specified by a doubly-linked list
formed by the <code>layout_pred</code> and <code>layout_succ</code> components of the graph's
nodes.  Null pointers in this linked list indicate ``don't care''
orderings, while connected components of the list will be laid out in order
when the graph is linearized.  This gives you complete flexibility between
specifying no order at all (all layout links null) and imposing a total
layout order on the CFG.
<p>
<h5><a name=toc73>Changing layout constraints.</a></h5>
<p>
To modify layout information, the OPI provides the following functions.
<p>
<blockquote>
<code>clear_layout_succ(node)</code> breaks the layout constraint between
<code>node</code> and its layout successor. <br><code>set_layout_succ(node, succ)</code> makes <code>succ</code> the layout successor of
<code>node</code>. <br><code>set_layout_succ(node, succ_label)</code> makes <code>node_at(succ_label)</code> the
layout successor of <code>node</code>.
</blockquote>
<p>
Note that the first argument to each of the above functions is the
predecessor member of the layout constraint being made or broken.  The
<code>layout_pred</code> component of the layout successor is always adjusted
implicitly.
<p>
To remove a layout constraint, use <code>clear_layout_succ</code>.  To establish a
layout constraint, use <code>set_layout_succ</code>, indicating the new layout
successor (either directly or through one of its labels) as its second
argument.
<p>

<h5><a name=toc74>Effects of layout constraints on code.</a></h5>
<p>
When a CFG is constructed, no instructions are added or removed,
whether or not layout constraints are specified.  Thus a procedure can
be transformed into CFG form and back to instruction-list form with no
changes, whether or not the layout-retention option is selected.
<p>
When no layout links have been specified, the CFG is treated as a general
graph.  You are free to transform it without having to ensure that there is
a linearization of its current instructions that is in valid executable
order.
<p>
On the other hand, nodes with layout successors be valid standard basic
blocks.  This makes <code>set_layout_succ</code> picky about the conditions under
which it allows a link to be set.
<p>
<ul>
<li>It is always legal to set the layout successor of a fall-through
node or a node ending in an unconditional branch.  If the
layout successor is also the control-flow successor, then an
unneeded unconditional branch instruction will be removed.  If
not, a goto will be created to be the terminating control
instruction in the node (i.e. it will be returned by
<code>get_cti</code>).  These constraints ensure that any necessary
explicit goto's become visible for timing analysis and
instruction scheduling.
<p>
<li>It is legal to set the layout successor of a conditional branch node
only if the layout successor is either the fall-through successor
or the taken successor of the node.  <code>set_layout_succ</code> inverts
the branch polarity, if necessary, so that the layout successor
becomes the fall-through successor of the node.  It returns a
Boolean result, which is true exactly when this flip has been made.
<p>
If you actually want the layout successor of a conditional branch
node not to be a control-flow successor, then you are responsible
for creating a new unconditional branch node below the conditional
branch.  This is easily done using the <code>insert_empty_node</code>
function.
<li>It is legal to set the layout successor of a node ending
in a call instruction only if the layout successor is also
the control flow successor.
<li>It is always legal to set the layout successor of a multiway
branch node.
<li>It is never legal to set a layout successor if adding that
link to the layout list would create a layout cycle.  Moreover,
it is never legal to change the fall-through successor of a node
after its layout successor has been set.  (You're allowed to set
the fall-through successor to the same value, though.)
</ul>
<p>

<h4><a name=toc75>Adding New Nodes</a></h4>
<p>
New CFG nodes are created with respect to a particular CFG and are
immediately included in the graph's roster of nodes, even though they
may have no connection to other nodes.
<p>
<blockquote>
<code>new_empty_node(cfg)</code>
returns a new empty and isolated node of <code>cfg</code>. <br><code>insert_empty_node(cfg, tail, head)</code>
inserts a new node along edge (<code>tail</code>,<code>head</code>). <br><code>insert_empty_node(cfg, tail, succ_pos)</code>
inserts a new node between <code>tail</code> and successor number
<code>succ_pos</code>. <br><code>clone_node(cfg, node)</code>
replicates <code>node</code> in <code>cfg</code>, leaving it disconnected.
</blockquote>
<p>
Recall that the sequence of successors of a node is an ordered multiset:
there may be several edges from node <code>tail</code> to some node <code>head</code>.  The
second form of <code>insert_empty_node</code> allows you to say exactly which edge
to split with a new node.
<p>

<h4><a name=toc76>Graph Simplification</a></h4>
<p>
The following functions perform graph simplification.  Each returns
<code>true</code> if it succeeds in changing the graph.  Since one kind of
simplification can create opportunities for others, you may want to
repeat these transformations until no progress is made by any of them.
<p>
<blockquote>
<code>remove_unreachable_nodes(cfg)</code>
removes nodes unreachable from <code>cfg</code>'s entry. <br><code>merge_node_sequences(cfg)</code>
merges sequences of control-equivalent nodes. <br><code>optimize_jumps(cfg)</code>
eliminates jumps to jumps.
</blockquote>
<p>
You should know that <code>remove_unreachable_nodes</code> renumbers the CFG,
so it could invalidate node numbers that you may have saved.
<p>

<h4><a name=toc77>Reverse-Postorder Node Enumeration</a></h4>
<p>
Class <code>CfgNodeListRpo</code> gives you a way to enumerate the nodes of a CFG in
reverse postorder <b>[cite&nbsp;<a href="#NWcite-bibmorgan">bibmorgan</a>]</b>.  Construct an instance of this class,
passing a <code>Cfg</code> object and an optional flag indicating whether to view
the graph in the normal forward direction or in reverse.  The methods of
<code>CfgNodeListRpo</code> for scanning the nodes are the same as the corresponding
sequence functions.  For instance, here's a snippet that prints the nodes
of <code>cfg</code> in reverse postorder:
<p>
<pre>
    CfgNodeListRpo rpo(cfg);
    for (CfgNodeHandle h = rpo.start(); h != rpo.end(); ++h)
        fprint(stdout, *h); 
</pre>


<h4><a name=toc78>Graph Printing</a></h4>
<p>
<h5><a name=toc79>Printing the whole graph.</a></h5>
<p>
When debugging code that uses a CFG, it is often useful to print an ASCII
representation of the graph.  To do so, evaluate
<code>fprint(file, cfg, show_layout, show_code)</code>.
Here <code>file</code> is a <code>FILE*</code>, and the last two
arguments are optional flags: <code>show_layout</code> causes the printout to
indicate the layout predecessor and successor of any node that
has such constraints and <code>show_code</code> causes the instructions in each node
to be printed.  Both flags default to <code>false</code>.
<p>
<h5><a name=toc80>Printing one node.</a></h5>
<p>
To print the line for a single node, evaluate
<code>fprint(file, node, show_code)</code>.
This prints a line containing <code>node</code>'s number, the nature of its CTI,
if any, and the lists of its successor and predecessor numbers.  If the
optional Boolean argument <code>show_code</code> is true, it prints the node's
instructions as well.
<p>

<h3><a name=toc81>Annotations</a></h3>
<p>
An annotation is an association between an <code>IrObject</code>, a key, and a
(potentially empty) sequence of values.  The base class of all
annotations is <code>Note</code>.  Like the IR component <code>Opnd</code>, the OPI
provides a couple of atomic annotations, uses classes to support the
definition of new annotations, and includes several example
specializations.
<p>
<h4><a name=toc82>Keys</a></h4>
<p>
Annotation keys have the opaque type <code>NoteKey</code>, where the actual
implementation of these IR objects may vary from one implementation of
the OPI to another.  In general, you can think of a key as a character
string like <code>&quot;line&quot;</code>; Machine SUIF in fact implements a <code>NoteKey</code>
as an <code>IdString</code>.  By convention, we name our <code>NoteKey</code> variables by
prepending a <code>k_</code> to the front of the character string describing
the key.  Thus, <code>k_line</code> is the <code>NoteKey</code> variable for the key
<code>&quot;line&quot;</code>.  We use this particular key for the annotations that
associate line number information with an instruction.
<p>
<h4><a name=toc83>Association Functions</a></h4>
<p>
The following is a listing of the functions that check and manipulate
the <code>Note</code> sequence associated with an <code>IrObject</code>.
<p>
<blockquote>
<code>has_notes(object)</code>
returns <code>true</code> if <code>object</code> has any annotations. <br><code>has_note(object, key)</code>
returns <code>true</code> if <code>object</code> has a <code>Note</code> under <code>key</code>. <br><code>get_note(object, key)</code>
returns the <code>Note</code> attached to <code>object</code> under <code>key</code>. <br><code>take_note(object, key)</code>
removes and returns the <code>Note</code> attached
to <code>object</code> under <code>key</code>. <br><code>set_note(object, key, note)</code>
attaches <code>note</code> to object under <code>key</code>. <br><code>copy_notes(object1, object2)</code>
makes copies of all the notes attached to <code>object1</code>
and attaches them to <code>object2</code>.
</blockquote>
<p>
As you can see from the functions above, we use a key as the index
into the <code>Note</code> sequence attached to an <code>IrObject</code>.  You can
attach any number of annotations to an <code>IrObject</code>, and an
<code>IrObject</code> may have one or more annotations with the same key.
<p>

<h4><a name=toc84>Basic Annotation Kinds</a></h4>
<p>
The OPI contains five basic kinds of annotations: null, flag,
singleton, list, and custom notes.  Null and flag are atomic
annotations.  They do not have any components that you can modify, and
they are built using creator functions.  The rest are modifiable, and
they defined by derived classes of the base class <code>Note</code>.  You build
them using the appropriate class constructor, and you modify them
using the public methods of the appropriate specialization class.
<p>
Except for the null annotation, we do not provide predicate functions
to distinguish between the different kinds of notes, as we do for
other OPI components. <b>[</b>We do not have a kind enumeration for
annotations for similar reasons.<b>]</b>   As illustrated above, a key is used
to get a <code>Note</code> from an <code>IrObject</code>.  The key determines the kind
of <code>Note</code> returned and thus makes predicate functions unnecessary.
When extending the OPI, you should maintain the invariant that a key
never maps to more than one <code>Note</code> kind.  (It is perfectly
acceptable to have multiple different keys return the same kind of
<code>Note</code>.)  In our derived <code>Note</code> classes, we provide a constructor
that takes a <code>Note</code> so that you never have to cast the return value
of <code>get_note</code> and <code>take_note</code>.
<p>
The rest of this section reviews the properties of each basic kind of
annotation in turn.  Notice that annotation equality is the only
operation common to all annotations.
<p>
<h5><a name=toc85>Null annotations.</a></h5> 
<p>
When <code>object</code> has no annotation under key <code>key</code>, then <code>get_note</code>
and <code>take_note</code> return the null annotation, an IR component
representing the condition ``non-existent'' <code>Note</code>.  Since you were
expecting a different kind of annotation from these functions, we
provide the <code>is_null</code> predicate to determine when <code>get_note</code> and
<code>take_note</code> fail.  This is the only purpose for null annotations.
<p>
Remember that <code>Note</code> is not a pointer type; <code>NULL</code> does not stand
for the ``non-existent'' note.
<p>

<h5><a name=toc86>Flag annotations.</a></h5> 
<p>
These annotations are useful when the mere presence of an annotation
with a given key carries all of the information that you want
associated with the <code>IrObject</code>.  You can create a flag annotation
using the creator function <code>note_flag()</code>.  These annotations do not
include a value sequence.
<p>
<pre>
    set_note(instr, k_necessary_instr, note_flag());
</pre>

In the example above, we attach a flag note with the key
<code>k_necessary_instr</code> to an instruction <code>instr</code>.  We use this code
in our dead-code elimination pass to mark instructions as necessary.
<p>

<h5><a name=toc87>Singleton annotations.</a></h5>
<p>
We refer to any annotation that provides you with a single storage
location as a <em>singleton</em> annotation.  The templated class
<code>OneNote&lt;</code><em>ValueType</em><code>&gt;</code> provides you with a storage location
of type <em>ValueType</em>, where <em>ValueType</em> must be one of the
following types: <code>long</code>, <code>Integer</code>, <code>IdString</code>, or
<code>IrObject*</code>.  When you invoke the parameterless constructor for one
of these singleton notes, you construct a singleton note with a single
uninitialized storage location.
<p>
The templated class <code>OneNote&lt;</code><em>ValueType</em><code>&gt;</code> provides you with the
following methods for inspecting and manipulating the singleton value:
<p>
<blockquote>
<code>get_value()</code>
returns the value. <br><code>set_value(value2)</code>
replaces the value by <code>value2</code>.
</blockquote>
<p>
You can change the value of a singleton note before or after attaching
it to an <code>IrObject</code>.
<p>

<h5><a name=toc88>List annotations.</a></h5>
<p>
We refer to any annotation that provides you with storage for a
sequence of values as a <em>list</em> annotation.  
<p>
The templated class <code>ListNote&lt;</code><em>ValueType</em><code>&gt;</code> provides you with a
homogeneous value list of one of the following types: <code>long</code>,
<code>Integer</code>, <code>IdString</code>, or <code>IrObject*</code>.  When you invoke the
parameterless constructor for one of these list notes, you construct
a list note with an empty value sequence.
<p>
The templated class <code>ListNote&lt;</code><em>ValueType</em><code>&gt;</code> provides you
with the following methods for inspecting and manipulating the value
list:
<p>
<blockquote>
<code>values_size()</code>
returns the number of values in the sequence. <br><code>get_value(pos)</code>
returns the value at position <code>pos</code>. <br><code>set_value(pos, value2)</code>
replaces the value at position <code>pos</code> by <code>value2</code>. <br><code>append(value)</code>
appends <code>value</code> to the end of the sequence. <br><code>insert_before(pos, value)</code>
inserts <code>value</code> before position <code>pos</code>. <br><code>remove(pos)</code>
removes the sequence item at position <code>pos</code>.
</blockquote>
<p>
You can add, remove, or change one or more items of a list note's
value sequence before or after attaching it to an <code>IrObject</code>.
<p>
As an example, suppose that <code>instr</code> is an instruction arising from
line 1234 of the source file <code>demo.c</code>.  The following snippet
attaches a <code>ListNote&lt;IdString&gt;</code> under the key <code>k_line</code> with a value
sequence consisting of the source file name and line number (as a
string):
<p>
<pre>
    ListNote&lt;IdString&gt; note;
    note.append(IdString(&quot;demo.c&quot;));
    note.append(IdString(&quot;1234&quot;));
    set_note(instr, k_line, note);
</pre>

The explicit conversion of the file name and line number to
<code>IdString</code> is not very pretty, and it is hard to remember if the file
name comes before or after the line number.  Use of custom annotations
(described next) eliminates these annoyances and makes for clearer and
more type-safe code.
<p>

<h5><a name=toc89>Custom annotations.</a></h5>
<p>
For annotations that are going to survive from pass to pass or that
are widely used within a single pass, we build custom kinds of notes
along with custom functions for inspection and manipulation.  This
approach can eliminate the need for explicit conversions like
<code>IdString(&quot;demo.c&quot;)</code> in the example above, and it makes the code
easier to read and more robust against sequence-order bugs and
representation changes.
<p>
Let's consider the source-location annotation example again.  We've
built a custom <code>Note</code> class called <code>LineNote</code>, and with this custom
note, we can construct a <code>LineNote</code> as follows:
<p>
<pre>
    LineNote note;
    note.set_file(note, &quot;demo.c&quot;);
    note.set_line(note, 1234);
    set_note(instr, k_line, note);
</pre>

We read back the annotation attached to <code>instr</code> as follows:
<p>
<pre>
    LineNote note = get_note(instr, k_line);
    claim(!is_null(note));

    fprintf(stdout, &quot;Instruction from file %s, line %d:\n\t&quot;,
            note.get_file().chars(), note.get_line());
    fprintf(stdout, instr);
</pre>

We may in the future define other constructors that make line notes
even easier to build.  In this way, the creation and attachment of the
above annotation could easily be reduced to a single line:
<p>
<pre>
    set_note(instr, k_line, LineNote(&quot;demo.c&quot;, 1234));
</pre>

To learn how to create custom annotation types like <code>LineNote</code>, see
<em>The Extender's Guide</em>.
<p>

<h2><a name=toc90>Summary</a></h2>
<p>
This guide provides a rudimentary introduction to our Optimization
Programming Interface (OPI).  We encourage the reader to consult the
library documents that came with the system implementing the OPI for
the full prototype definitions of the OPI functions and for more
details on their use.  Furthermore, this guide was never meant to be
exhaustive in its listing of the available OPI functions and data
structures, or in its presentation of coding examples.  The <em>OPI
Catalog</em> and the ``cookbook'' that came with the system were written
to address these issues.
<p>

<h2><a name=toc91>Acknowledgments</a></h2>
<p>
This work was supported in part by an DARPA/NSF infrastructure grant
(NDA904-97-C-0225), a NSF Young Investigator award (CCR-9457779), and
a NSF Research Infrastructure award (CDA-9401024).  We also gratefully
acknowledge the generous support of this research by Advanced Micro
Devices, Compaq, Digital Equipment, Hewlett-Packard, International
Business Machines, Intel, and Microsoft.
<p>

<h2><a name=toc92>References</a></h2>
<p>
<a name="NWcite-eric-thesis"><b>[1]</b></a>  Eric Feigin.
<em>A Case for Automatic Run-Time Code Optimization</em>.
Undergraduate thesis, Harvard University, April 1999.
<p>
<a name="NWcite-bibbvd"><b>[2]</b></a>  G. Holloway and A. Dimock.
<em>The Machine-SUIF Bit-vector Data-flow Analysis Library.</em>
The Machine SUIF documentation set, Harvard University,
1998.
<p>
<a name="NWcite-bibcookbook"><b>[3]</b></a>  G. Holloway and M. D. Smith.  <em>The Machine-SUIF
Cookbook.</em>  The Machine-SUIF documentation set, Harvard University, 2000.
<p>
<a name="NWcite-bibmachine"><b>[4]</b></a>  G. Holloway and M. D. Smith.
<em>The SUIF Machine Library.</em>
The Machine SUIF documentation set, Harvard University,
2000.
<p>
<a name="NWcite-bibmorgan"><b>[5]</b></a>  Robert Morgan.  <em>Building an Optimizing
Compiler.</em>  Digital Press, 1998.
<p>
<a name="NWcite-biboverview"><b><a name="NWD2">[6]</a></b></a>  M. D. Smith and G. Holloway.
<em>An Introduction to Machine SUIF and Its Portable Libraries
for Analysis and Optimization.</em>
The Machine SUIF documentation set, Harvard University,
2000.
<p>



<h2><a name=toc93>Structure of a Machine-SUIF Pass</a></h2>
<a name="app-suif-pass"><b>[*]</b></a>
<p>
This appendix describes how we map the methods of a Machine-SUIF pass
to those of an OPI pass.  In Machine SUIF, each SUIF pass wraps a
single OPI pass.  The only real complication in the mapping of the
SUIF pass methods onto the OPI pass methods results from the need to
initialize the substrate's state, as described below.
<p>
Machine SUIF creates an optimization pass by deriving a class from
SUIF's <code>PipelinablePass</code> class.  The public methods of interest
are <code>do_file_set_block</code>, <code>do_file_block</code>,
<code>do_procedure_definition</code>, and <code>finalize</code>.  We will use the
implementations of these methods from <code>peep/suif_pass.cpp</code> as our
running example.
<p>
<a name="NWD3">As illustrated in </a><code>peep/suif_pass.h</code>, the class <code>PeepSuifPass</code>
embeds an instance of the class <code>Peep</code> within itself, and then the
implementation of the public methods of interest in <code>PeepSuifPass</code>
simply invoke the <code>initialize</code>, <code>do_opt_unit</code>, and <code>finalize</code>
methods of the embedded <code>Peep</code> object.  The simplest of these
connections occurs in <code>finalize</code>, as shown below, where we just
invoke <code>peep.finalize</code>.  The contents of the other <code>PeepSuifPass</code>
methods are described below.
<p>
<pre><a name="NW13f676-hTELt-1" href="#NWD3"><dfn>&lt;<code>finalize</code>&gt;=</dfn></a>
void
PeepSuifPass::finalize()
{ 
    peep.finalize();
}
</pre><p>

<h5><a name=toc94><a name="NWD4">File set handler.</a></a></h5>
<p>
A <em>file set</em> is an object that represents the whole input of a
compilation.  Its C++ type is <code>FileSetBlock*</code>.  The file-set handler
<code>do_file_set_block</code> takes an object of this type and performs any
once-only initialization that the SUIF pass requires.
<p>
<pre><a name="NW13f676-qlzwd-1" href="#NWD4"><dfn>&lt;<code>do_file_set_block</code>&gt;=</dfn></a>
void
PeepSuifPass::do_file_set_block(FileSetBlock *fsb)
{
    claim(o_fname.is_empty() || fsb-&gt;get_file_block_count() == 1,
          &quot;Command-line output file =&gt; file set must be a singleton&quot;);

    set_opi_predefined_types(fsb);
}

</pre><p>

In addition, our implementation of <code>do_file_set_block</code> invokes
<code>set_opi_predefined_types</code>.  This creates a cache of
machine-independent types such as <code>type_v0</code> and <code>type_s32</code>
<b>[cite&nbsp;<a href="#NWcite-bibmachine">bibmachine</a>]</b> and attaches it to the file-set object.
<p>

<h5><a name=toc95>File handler.</a></h5>
<p>
Each file in a file set has an associated <code>FileBlock*</code> object.  The
file handler <code>do_file_block</code> takes this object and performs any
needed per-file processing.  
<p>
Under Machine SUIF, facts about the compilation target are dynamically
bound to functions and data structures in the OPI.  OPI functions and
<a name="NWD5">data structures that rely on the specifics of the underlying substrate</a>
are bound statically when the Machine-SUIF libraries are compiled.
<p>
Binding of the OPI to a particular target requires the construction of
a Machine-SUIF <code>Context</code> object.  This object is created in
<code>do_file_block</code> by the call <code>focus(FileBlock*)</code>.  The contents of
the <code>target_lib</code> annotation attached to the <code>FileBlock</code> determines
the specific <code>Context</code> object created.
<p>
<pre><a name="NW13f676-26syMW-1" href="#NWD5"><dfn>&lt;<code>do_file_block</code>&gt;=</dfn></a>
void
PeepSuifPass::do_file_block(FileBlock *fb)
{
    claim(has_note(fb, k_target_lib),
          &quot;expected target_lib annotation on file block&quot;);

    focus(fb);

    peep.initialize();
}

</pre><p>

The call <code>focus(FileBlock*)</code> also informs the OPI that the
optimization focus now resides in the indicated <code>FileBlock</code>.  The
call <code>peep.initialize()</code> allows the OPI pass to perform its setup;
remember that this initialization call may invoke target-specific
functions and thus must occur after <code>focus</code>.
<p>

<h5><a name=toc96><a name="NWD6">Procedure handler.</a></a></h5>
<p>
Machine SUIF performs optimizations at the granularity of procedures
by invoking <code>do_procedure_definition</code>.  In SUIF, a procedure is
given the object type <code>ProcedureDefinition</code>.  As stated in
Section&nbsp;<a href="#sec-opi-pass">[&lt;-]</a>, <code>OptUnit</code> is a synonym for
<code>ProcedureDefinition</code>.
<p>
<pre><a name="NW13f676-4ajXsR-1" href="#NWD6"><dfn>&lt;<code>do_procedure_definition</code>&gt;=</dfn></a>
void
PeepSuifPass::do_procedure_definition(ProcedureDefinition *pd)
{
    focus(pd);
    peep.do_opt_unit(pd);
    defocus(pd);
}

</pre><p>

<a name="NWD7">The body of this method simply informs the OPI that the optimization</a>
focus is now moving to <code>pd</code>, a <code>ProcedureDefinition*</code>, and then
invokes the optimizer on that <code>ProcedureDefinition</code>.  When the
optimizer is done, we invoke the Machine-SUIF function <code>defocus</code> to
move the optimization focus back to the <code>FileBlock</code>.
<p><h2><a name=toc97>Glossary</a></h2>
<a name="sec-glossary"><b>[*]</b></a>
<p>
This glossary summarizes our naming conventions and patterns.  If we
abbreviate a word or phrase, we use the same abbreviation everywhere
in our code.  If a word or an abbreviation for that word does not
appear in our list, we probably spell it out.  However, we encourage
you to check the list for synonyms.  If multiple words seem
appropriate, we often use the shortest English word instead of using
an abbreviation.
<p>
As discussed in Section&nbsp;<a href="#sec-conventions">[&lt;-]</a>, we are consistent in
our naming of the IR components and their accessors/manipulators,
espeically when there is a pattern in their structure.  Some of this
consistency is evident in the list below.
<p>
Lastly, we do not claim to follow these conventions for variable names
in our code that are local in scope.  We're not dictators.  We just
want to make it easy to use the functions, classes, and objects in the
OPI and our other support packages.
<p>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code>addr</code>          </td><td align=left valign=top>Shorthand for ``address''.                           </td></tr>
<tr><td align=left valign=top><code>alm</code>           </td><td align=left valign=top>Shorthand for ``ALU, logic, or memory''.             </td></tr>
<tr><td align=left valign=top>annotation        </td><td align=left valign=top>See <code>note</code>.                                        </td></tr>
<tr><td align=left valign=top><code>append</code>        </td><td align=left valign=top>The way to put an object before the last element in
a sequence.                                          </td></tr>
<tr><td align=left valign=top><code>arg</code>           </td><td align=left valign=top>Shorthand for ``argument''.                          </td></tr>
<tr><td align=left valign=top><code>assert</code>        </td><td align=left valign=top>See <code>claim</code>.
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code>cfg</code>           </td><td align=left valign=top>Shorthand for ``control flow graph''.                </td></tr>
<tr><td align=left valign=top><code>claim</code>         </td><td align=left valign=top>Our replacement for assert to avoid name clashes.    </td></tr>
<tr><td align=left valign=top><code>cmove</code>         </td><td align=left valign=top>Shorthand for ``conditional move''.                  </td></tr>
<tr><td align=left valign=top><code>count</code>         </td><td align=left valign=top>A count value.  Not used to refer to the cardinality
of a sequence.  See <code>size</code>.                        </td></tr>
<tr><td align=left valign=top><code>cti</code>           </td><td align=left valign=top>Shorthand for ``control transfer instruction''.
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code>desc</code>          </td><td align=left valign=top>Shorthand for ``description''.                       </td></tr>
<tr><td align=left valign=top><code>def</code>           </td><td align=left valign=top>Shorthand for ``definition''.                        </td></tr>
<tr><td align=left valign=top><code>disp</code>          </td><td align=left valign=top>Shorthand for ``displacement''.                      </td></tr>
<tr><td align=left valign=top><code>dom</code>           </td><td align=left valign=top>Shorthand for ``dominator'' or ``dominance'',
depending upon the context. (This is one case where
we don't always use the abbreviation.)               </td></tr>
<tr><td align=left valign=top><code>dst</code>           </td><td align=left valign=top>Shorthand for ``destination''.  Often referring to an
<code>instr</code>'s destination operand.                     </td></tr>
<tr><td align=left valign=top><code>dsts</code>          </td><td align=left valign=top>A sequence of destinations.
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top>...<code>_end</code>    </td><td align=left valign=top>A handle just beyond the last element of the ...
sequence.                                            </td></tr>
<tr><td align=left valign=top><code>exp</code>           </td><td align=left valign=top>Shorthand for ``expression''.
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code>get_</code>...</td><td align=left valign=top>The way to get a copy of the structure member ....
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code>id</code>            </td><td align=left valign=top>Shorthand for ``identifier''.                        </td></tr>
<tr><td align=left valign=top><code>immed</code>         </td><td align=left valign=top>Shorthand for ``immediate''.                         </td></tr>
<tr><td align=left valign=top><code>init</code>          </td><td align=left valign=top>Shorthand for ``initialize'' (or any variant of
initial).                                            </td></tr>
<tr><td align=left valign=top><code>insert_after</code>  </td><td align=left valign=top>The way to put an object after the specified handle
into a sequence.                                     </td></tr>
<tr><td align=left valign=top><code>insert_before</code> </td><td align=left valign=top>The way to put an object before the specified handle
into a sequence.                                     </td></tr>
<tr><td align=left valign=top><code>instr</code>         </td><td align=left valign=top>Shorthand for ``instruction''.                       </td></tr>
<tr><td align=left valign=top><code>ir</code>            </td><td align=left valign=top>Shorthand for ``intermediate representation''.
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code>k_</code>...</td><td align=left valign=top>The global <code>IdString</code> constant for the string
``...''.
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code>ldc</code>           </td><td align=left valign=top>Shorthand for ``load constant''.
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code>mbr</code>           </td><td align=left valign=top>Shorthand for ``multiway branch''.
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code>note</code>          </td><td align=left valign=top>Annotation attached to an <code>IrObject</code>.
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code>op</code>            </td><td align=left valign=top>Should never appear in the OPI.  See <code>opcode</code>.     </td></tr>
<tr><td align=left valign=top><code>opcode</code>        </td><td align=left valign=top>When we refer to the opcode of an <code>IrObject</code>, we
always write opcode and never write ``op'', which
may mean opcode, operation, or operand.              </td></tr>
<tr><td align=left valign=top>opi               </td><td align=left valign=top>Shorthand for ``optimization programming interface''.</td></tr>
<tr><td align=left valign=top><code>opnd</code>          </td><td align=left valign=top>Shorthand for ``operand''.
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code>param</code>         </td><td align=left valign=top>Shorthand for ``parameter''.                         </td></tr>
<tr><td align=left valign=top><code>prepend</code>       </td><td align=left valign=top>The way to put an object before the first element in
a sequence.                                          </td></tr>
<tr><td align=left valign=top><code>pred</code>          </td><td align=left valign=top>Shorthand for ``predecessor''.                       </td></tr>
<tr><td align=left valign=top><code>preds</code>         </td><td align=left valign=top>A sequence of predecessors.                          </td></tr>
<tr><td align=left valign=top><code>proc</code>          </td><td align=left valign=top>Shorthand for ``procedure''.
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code>reg</code>           </td><td align=left valign=top>Shorthand for ``register''.
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code>set_</code>...</td><td align=left valign=top>The way to set the value of the structure member
....                                              </td></tr>
<tr><td align=left valign=top><code>size</code>          </td><td align=left valign=top>Always refers to the cardinality of a sequence.      </td></tr>
<tr><td align=left valign=top>...<code>_size</code>   </td><td align=left valign=top>The number of items in the ... sequence.         </td></tr>
<tr><td align=left valign=top><code>src</code>           </td><td align=left valign=top>Shorthand for ``source''.  Often referring to a
source operand of an instruction.                    </td></tr>
<tr><td align=left valign=top><code>srcs</code>          </td><td align=left valign=top>A sequence of sources.                               </td></tr>
<tr><td align=left valign=top>...<code>_start</code>  </td><td align=left valign=top>A handle to the start of the ... sequence.       </td></tr>
<tr><td align=left valign=top><code>succ</code>          </td><td align=left valign=top>Shorthand for ``successor''.                         </td></tr>
<tr><td align=left valign=top><code>succs</code>         </td><td align=left valign=top>A sequence of successors.                            </td></tr>
<tr><td align=left valign=top><code>sym</code>           </td><td align=left valign=top>Shorthand for ``symbol''.                            </td></tr>
<tr><td align=left valign=top><code>sym_table</code>     </td><td align=left valign=top>Shorthand for ``symbol table''.
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code>ubr</code>           </td><td align=left valign=top>Shorthand for ``unconditional branch''.
</td></tr></table>
</blockquote>
<blockquote>
<table><!-- alignment is p{.15\textwidth}p{.78\textwidth}--><!-- 2 columns--><tr><td align=left valign=top><code><a name="NWD8">var</a></code>           </td><td align=left valign=top>Shorthand for ``variable''.
</td></tr></table>
</blockquote>
<p>
<!-- Make \end{document} a chunk by itself to allow cross-reference info-->
<!-- to be dumped in before it (noweave -delay).-->




<ul>
<li><a href="#NWD5"><i>&lt;<code>do_file_block</code>&gt;</i></a>: <a href="#NWD5">D1</a>
<li><a href="#NWD4"><i>&lt;<code>do_file_set_block</code>&gt;</i></a>: <a href="#NWD4">D1</a>
<li><a href="#NWD6"><i>&lt;<code>do_procedure_definition</code>&gt;</i></a>: <a href="#NWD6">D1</a>
<li><a href="#NWD3"><i>&lt;<code>finalize</code>&gt;</i></a>: <a href="#NWD3">D1</a>
</ul>
</body></html>

